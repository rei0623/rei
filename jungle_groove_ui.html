<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- MODIFIED_CODE: Default title will be updated by JS -->
    <title>Jungle Groove - Wild Music Safari</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&family=Montserrat:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* jungle_groove_styles.css */
        :root {
            --jg-bg-deep-jungle: #1A3A3A;
            --jg-bg-forest-floor: #4A3B31;
            --jg-surface-bark: #785C4A;
            --jg-surface-leaf: #5C824D;
            --jg-accent-sunburst: #FFA726;
            --jg-accent-canopy: #4CAF50;
            --jg-accent-waterfall: #29B6F6;
            --jg-text-light: #F5EFE6;
            --jg-text-earth: #D2B48C;
            --jg-text-shadow: #A08A72;
            --jg-border-vine: #6B4F3A;
            --jg-shadow-heavy: rgba(0,0,0,0.4);
            --jg-shadow-light: rgba(0,0,0,0.2);

            --font-display-jg: 'Kalam', cursive;
            --font-body-jg: 'Montserrat', sans-serif;

            --jg-surface-bark-rgb: 120, 92, 74;
            --jg-surface-leaf-rgb: 92, 130, 77;
            --jg-bg-forest-floor-rgb: 74, 59, 49;
            --jg-accent-canopy-rgb: 76, 175, 80;

            --jg-placeholder-bg: var(--jg-surface-bark);
        }

        body.jungle-theme {
            font-family: var(--font-body-jg);
            background-color: var(--jg-bg-deep-jungle);
            color: var(--jg-text-light);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .jungle-background-layers { position: fixed; inset: 0; z-index: -1; }
        .jungle-background-layers .layer {
            position: absolute; inset: 0;
            transition: transform 0.5s ease-out, opacity 0.5s ease;
        }
        .layer-1 {
            background: linear-gradient(to bottom, #3A506B, #1C2541 70%);
            opacity: 0.8;
        }
        .layer-2 {
            background-color: rgba(var(--jg-surface-leaf-rgb), 0.15);
            opacity: 0.4;
            transform: scale(1.05);
        }
        .layer-3 {
            opacity: 0.6;
            transform: scale(1.1);
        }

        .app-safari-hut {
            width: 95vw;
            height: 90vh;
            max-width: 1500px;
            max-height: 850px;
            margin: 2.5vh auto;
            background-color: rgba(40, 30, 20, 0.65);
            backdrop-filter: blur(15px) saturate(120%);
            -webkit-backdrop-filter: blur(15px) saturate(120%);
            border: 3px solid var(--jg-surface-bark);
            border-radius: 25px;
            box-shadow: 0 10px 40px var(--jg-shadow-heavy);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .safari-map-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.5rem;
            background-color: rgba(var(--jg-surface-bark-rgb), 0.85);
            border-bottom: 2px solid var(--jg-border-vine);
            box-shadow: 0 4px 10px var(--jg-shadow-light);
        }
        .compass-logo {
            font-family: var(--font-display-jg);
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--jg-text-light);
        }
        .compass-logo i { color: var(--jg-accent-sunburst); margin-right: 0.5rem; transform: rotate(-15deg); }
        .text-accent-jg { color: var(--jg-accent-canopy); }

        /* MODIFIED_CODE: For search clear button positioning */
        .search-outpost {
            display: flex;
            align-items: center;
            background-color: rgba(var(--jg-bg-forest-floor-rgb), 0.75);
            padding: 0.5rem 1rem;
            border-radius: 30px;
            border: 1px solid var(--jg-border-vine);
            position: relative; /* For clear button */
        }
        .search-outpost i.fa-binoculars { color: var(--jg-text-shadow); margin-right: 0.7rem; }
        #animal-tracker {
            background: transparent; border: none; outline: none;
            color: var(--jg-text-light); font-size: 0.9rem; width: 250px;
            padding-right: 25px; /* Space for clear button */
        }
        #animal-tracker::placeholder { color: var(--jg-text-shadow); opacity: 0.8; }
        /* NEW_CODE_START: Search clear button styles */
        #clear-search-btn-jg {
            position: absolute;
            right: 0.8rem; /* Adjusted for padding of search-outpost */
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            color: var(--jg-text-shadow);
            cursor: pointer;
            font-size: 1rem;
            padding: 0.2rem;
            line-height: 1;
        }
        #clear-search-btn-jg:hover {
            color: var(--jg-text-light);
        }
        body.light-mode-jg #clear-search-btn-jg { color: var(--jg-text-shadow); }
        body.light-mode-jg #clear-search-btn-jg:hover { color: var(--jg-text-light); }
        /* NEW_CODE_END */


        .safari-tools { display: flex; align-items: center; gap: 0.75rem; }
        .tool-btn-jg {
            background-color: var(--jg-surface-bark);
            border: 1px solid var(--jg-border-vine);
            color: var(--jg-text-earth);
            width: 40px; height: 40px;
            border-radius: 50%;
            display: inline-flex; align-items: center; justify-content: center;
            font-size: 1.1rem;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px var(--jg-shadow-light);
        }
        .tool-btn-jg:hover {
            background-color: var(--jg-accent-sunburst);
            color: var(--jg-bg-deep-jungle);
            transform: scale(1.1);
        }
        .tool-btn-jg.profile .profile-avatar-placeholder {
            width: 30px; height: 30px; border-radius: 50%;
            background-color: var(--jg-text-shadow); 
        }

        .safari-zone {
            flex-grow: 1;
            display: flex;
            padding: 1.5rem;
            gap: 1.5rem;
            overflow: hidden;
        }

        .watering-hole-player {
            flex: 3;
            background: linear-gradient(135deg, rgba(var(--jg-surface-leaf-rgb),0.7), rgba(var(--jg-surface-bark-rgb),0.5));
            border-radius: 20px;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: inset 0 0 15px var(--jg-shadow-light);
            border: 2px solid var(--jg-border-vine);
        }
        .album-canopy {
            width: 280px; height: 280px;
            border-radius: 15px;
            margin-bottom: 1.5rem;
            position: relative;
            box-shadow: 0 8px 25px var(--jg-shadow-heavy);
            overflow: hidden;
            background-color: var(--jg-bg-forest-floor);
        }
        #main-album-art-jg.album-art-placeholder {
            width: 100%; height: 100%;
            border: 4px solid var(--jg-surface-bark);
            background-color: var(--jg-text-shadow);
            display: flex; align-items: center; justify-content: center;
            font-size: 3rem; color: var(--jg-bg-deep-jungle);
        }
        .leaf-overlay {
            position: absolute; inset: 0;
            /* background-image: url('path/to/leaf-texture.png'); */ /* Example */
            opacity: 0.1;
            pointer-events: none;
        }
        .track-details-jg { text-align: center; margin-bottom: 1.5rem; }
        #song-title-jg {
            font-family: var(--font-display-jg);
            font-size: 2.5rem; font-weight: 700;
            color: var(--jg-text-light); margin-bottom: 0.25rem;
            min-height: 1.2em; 
        }
        #artist-name-jg {
            font-size: 1.1rem; color: var(--jg-text-earth);
            min-height: 1.2em; 
        }

        .player-controls-jg { display: flex; align-items: center; gap: 1rem; margin-bottom: 1.5rem; }
        .control-rock {
            background-color: var(--jg-surface-bark);
            border: 2px solid #5C4033;
            color: var(--jg-text-earth);
            border-radius: 50%;
            width: 60px; height: 60px;
            font-size: 1.2rem;
            display: inline-flex; align-items: center; justify-content: center;
            box-shadow: 2px 2px 5px var(--jg-shadow-light), inset 1px 1px 3px rgba(255,255,255,0.1);
            transition: all 0.15s ease-out;
            text-shadow: 1px 1px 2px var(--jg-shadow-heavy);
        }
        .control-rock:hover { transform: translateY(-2px) scale(1.05); box-shadow: 4px 4px 8px var(--jg-shadow-light), inset 1px 1px 3px rgba(255,255,255,0.1); }
        .control-rock:active { transform: translateY(1px) scale(0.98); box-shadow: 1px 1px 3px var(--jg-shadow-light), inset 1px 1px 3px rgba(0,0,0,0.2); }
        .control-rock.small { width: 45px; height: 45px; font-size: 1rem; }
        .control-rock.play {
            width: 75px; height: 75px; font-size: 2rem;
            background-color: var(--jg-accent-canopy);
            border-color: var(--jg-accent-canopy);
            color: var(--jg-text-light);
        }
        .control-rock.play i.fa-paw { font-size: 2.2rem; }

        .progress-liana-jg { display: flex; align-items: center; gap: 0.75rem; width: 100%; max-width: 400px; margin-bottom: 1rem; }
        .progress-liana-jg span { font-size: 0.8rem; color: var(--jg-text-shadow); }
        .liana-slider {
            -webkit-appearance: none; appearance: none; flex-grow: 1; height: 8px;
            background-color: var(--jg-border-vine);
            border-radius: 4px; cursor: pointer;
        }
        .liana-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 18px; height: 18px;
            background-color: var(--jg-accent-canopy);
            /* background-image: url('path/to/leaf-thumb.svg'); */ /* Example */
            background-size: contain;
            border: none;
            border-radius: 50%;
        }

        .volume-fruit-jg { display: flex; align-items: center; gap: 0.5rem; }
        .animal-icon { font-size: 1.2rem; color: var(--jg-text-shadow); }
        .fruit-slider {
            -webkit-appearance: none; appearance: none; width: 120px; height: 10px;
            background: var(--jg-surface-bark); border-radius: 5px; cursor: pointer;
        }
        .fruit-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 16px; height: 16px;
            background: var(--jg-accent-sunburst);
            /* background-image: url('path/to/fruit-thumb.svg'); */ /* Example */
            border-radius: 50%; border: 1px solid #D47500;
        }

        .explorers-log {
            flex: 2;
            background-color: rgba(var(--jg-surface-bark-rgb), 0.65);
            border-radius: 15px;
            border: 2px solid var(--jg-border-vine);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .log-tabs-jg { display: flex; border-bottom: 2px solid var(--jg-border-vine); margin-bottom: 1rem; }
        .log-tab-jg {
            flex-grow: 1; padding: 0.75rem 0.5rem;
            font-family: var(--font-display-jg); font-size: 1.1rem;
            color: var(--jg-text-earth); border: none; background: transparent;
            position: relative; opacity: 0.7; transition: opacity 0.2s, color 0.2s;
            cursor: pointer; 
        }
        .log-tab-jg:hover { opacity: 1; color: var(--jg-accent-sunburst); }
        .log-tab-jg.active {
            opacity: 1; color: var(--jg-accent-sunburst); font-weight: 700;
        }
        .log-tab-jg.active::after {
            content: ''; position: absolute;
            bottom: -2px; left: 10%; width: 80%; height: 3px;
            background-color: var(--jg-accent-sunburst); border-radius: 1.5px;
        }
        .log-tab-jg i { margin-right: 0.4rem; }
        #queue-count-jg {
            background: var(--jg-accent-waterfall); color: white; font-size: 0.7rem;
            padding: 1px 5px; border-radius: 8px; margin-left: 0.3rem;
            font-family: var(--font-body-jg);
            display: none; /* Initially hidden, shown by JS */
        }

        .log-content-jg { flex-grow: 1; overflow-y: auto; }
        .log-panel-jg { display: none; padding-top: 0.5rem; }
        .log-panel-jg.active { display: block; animation: revealPanel 0.4s ease-in-out; }
        @keyframes revealPanel { from { opacity:0; transform:scale(0.98); } to { opacity:1; transform:scale(1); } }

        .log-entry-jg {
            display: flex; align-items: center; padding: 0.75rem;
            margin-bottom: 0.5rem; border-radius: 10px;
            background-color: rgba(var(--jg-bg-forest-floor-rgb), 0.55);
            transition: background-color 0.2s, transform 0.2s;
            cursor: pointer; /* Default cursor, will be 'grab' if draggable */
        }
        .log-entry-jg:hover {
            background-color: rgba(var(--jg-surface-leaf-rgb),0.5);
            transform: translateX(5px);
        }
        .log-entry-jg.active-song {
            background-color: rgba(var(--jg-accent-canopy-rgb),0.4);
            border-left: 4px solid var(--jg-accent-canopy);
            padding-left: calc(0.75rem - 4px);
        }
        /* NEW_CODE_START: Drag and Drop Styles */
        .log-entry-jg.dragging-jg {
            opacity: 0.4;
            background-color: rgba(var(--jg-accent-sunburst-rgb, 255, 167, 38), 0.3); /* Define --jg-accent-sunburst-rgb if needed or use direct rgba */
            border: 2px dashed var(--jg-accent-sunburst);
        }
        .drag-over-placeholder-jg {
            height: 2px;
            background-color: var(--jg-accent-sunburst);
            margin: 2px 0;
            border-radius: 1px;
            pointer-events: none; /* Important so it doesn't interfere with drop target */
        }
        /* NEW_CODE_END */
        .log-entry-jg .img-placeholder.list-thumb-placeholder {
            width: 40px; height: 40px; border-radius: 6px; margin-right: 0.75rem;
            background-color: var(--jg-text-shadow);
            display: flex; align-items: center; justify-content: center;
            font-size: 1rem; color: var(--jg-bg-forest-floor);
            object-fit: cover; 
            flex-shrink: 0; 
        }
         .log-entry-jg > img {
            width: 40px; height: 40px; border-radius: 6px; margin-right: 0.75rem;
            object-fit: cover;
            flex-shrink: 0;
        }

        .log-entry-jg > div { flex-grow: 1; overflow:hidden; min-width: 0; }
        .log-entry-jg .title { display: block; font-weight: 600; color: var(--jg-text-light); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
        .log-entry-jg .artist { display: block; font-size: 0.85rem; color: var(--jg-text-earth); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
        .log-entry-jg .duration { font-size: 0.85rem; color: var(--jg-text-shadow); margin-left: auto; padding-left:0.5rem; flex-shrink: 0; }
        
        .log-entry-actions-jg { display: flex; align-items: center; flex-shrink: 0; margin-left: 0.25rem;}
        .log-entry-jg .song-item-action-jg {
            background: none; border: none; padding: 0.3rem 0.4rem; 
            cursor: pointer;
        }
        .log-entry-jg .song-item-action-jg i {
            font-size: 1rem; color: var(--jg-text-shadow); transition: color 0.2s;
        }
        .log-entry-jg:hover .song-item-action-jg i { color: var(--jg-accent-sunburst); }
        .log-entry-jg .song-item-action-jg.favorite-action-jg i.fa-heart { color: var(--jg-accent-sunburst); } /* Custom applied class */
        .log-entry-jg:hover .song-item-action-jg.favorite-action-jg i.fa-heart { color: var(--jg-accent-waterfall); } 
        .log-entry-jg .song-item-action-jg.remove-from-playlist-action-jg i { color: var(--jg-text-shadow); } /* default red-500 in HTML */
        .log-entry-jg:hover .song-item-action-jg.remove-from-playlist-action-jg i { color: #EF4444; } /* Tailwind red-500 on hover */


        .log-entry-jg > i.fa-feather-alt, .log-entry-jg > i.fa-play-circle {
             font-size: 1rem; color: var(--jg-text-shadow); transition: color 0.2s; margin-left: auto; padding-left:0.5rem; flex-shrink: 0;
        }
        .log-entry-jg:hover > i.fa-feather-alt { color: var(--jg-accent-sunburst); }


        .log-actions-jg {
            padding-top: 1rem; border-top: 1px solid var(--jg-border-vine);
            display: flex; gap: 0.75rem; justify-content: center;
            flex-wrap: wrap; /* Allow buttons to wrap on smaller screens if many */
        }
        .log-actions-jg button {
            background-color: var(--jg-surface-leaf); color: var(--jg-text-light);
            padding: 0.5rem 1rem; border-radius: 20px; border: 1px solid var(--jg-accent-canopy);
            font-size: 0.85rem; font-weight: 500; transition: all 0.2s;
             cursor: pointer; 
        }
        .log-actions-jg button:hover {
            background-color: var(--jg-accent-canopy);
            transform: translateY(-1px); box-shadow: 0 2px 8px var(--jg-shadow-light);
        }
        .log-actions-jg button i { margin-right: 0.4rem; }

        .control-rock.active-control {
            color: var(--jg-accent-sunburst) !important;
            border-color: var(--jg-accent-sunburst);
            box-shadow: 0 0 10px var(--jg-accent-sunburst), inset 1px 1px 3px rgba(255,255,255,0.1);
        }
        .loop-indicator-jg {
            position: absolute;
            top: 0px; right: 5px; font-size: 0.6rem; font-weight: bold;
            background-color: var(--jg-accent-sunburst); color: var(--jg-bg-deep-jungle);
            border-radius: 50%; width: 12px; height: 12px;
            line-height: 12px; text-align: center; font-family: var(--font-body-jg);
        }

        .img-placeholder {
            display: inline-block;
            background-color: var(--jg-placeholder-bg); /* Defined in :root */
            object-fit: cover; /* Ensures image covers area if it's an <img> */
        }

        @media (max-width: 1024px) {
            .app-safari-hut { width: 100vw; height: 100vh; margin: 0; border-radius: 0; max-height: none; }
            .safari-zone { flex-direction: column; padding: 0.75rem; }
            .watering-hole-player { flex: 1; padding: 1rem; min-height: 350px; } /* Adjusted min-height */
            .album-canopy { width: 180px; height: 180px; }
            #song-title-jg { font-size: 1.8rem; }
            .explorers-log { flex: 1; }
            #animal-tracker { width: 150px; padding-right: 22px; /* Space for clear button */ }
             /* NEW_CODE_START: Adjust clear button position for smaller search */
            #clear-search-btn-jg { right: 0.6rem; font-size: 0.9rem; }
            /* NEW_CODE_END */
        }
        @media (max-width: 767px) {
            .safari-map-bar { padding: 0.75rem 1rem; }
            .compass-logo { font-size: 1.2rem;}
            .search-outpost { padding: 0.4rem 0.8rem;}
            #animal-tracker { width: 120px; font-size: 0.8rem; padding-right: 20px; /* Space for clear button */ }
            /* NEW_CODE_START: Adjust clear button position for smallest search */
            #clear-search-btn-jg { right: 0.5rem; font-size: 0.8rem; }
            /* NEW_CODE_END */

            .tool-btn-jg { width: 36px; height: 36px; font-size: 1rem; }
            .watering-hole-player { padding: 0.75rem; }
            .album-canopy { width: 150px; height: 150px; margin-bottom: 1rem; }
            #main-album-art-jg.album-art-placeholder { font-size: 2rem; }
            #song-title-jg { font-size: 1.5rem; }
            #artist-name-jg { font-size: 0.9rem; }
            .player-controls-jg { gap: 0.75rem; margin-bottom: 1rem; }
            .control-rock { width: 50px; height: 50px; font-size: 1rem; }
            .control-rock.small { width: 40px; height: 40px; font-size: 0.9rem; }
            .control-rock.play { width: 65px; height: 65px; font-size: 1.8rem; }
            .log-tabs-jg { margin-bottom: 0.75rem; }
            .log-tab-jg { font-size: 0.95rem; padding: 0.6rem 0.3rem; }
            .log-entry-jg { padding: 0.6rem; }
            .log-entry-jg .img-placeholder.list-thumb-placeholder,
            .log-entry-jg > img {
                width: 35px; height: 35px; margin-right: 0.5rem;
            }
            .log-entry-jg .title { font-size: 0.9rem;}
            .log-entry-jg .artist { font-size: 0.75rem;}
            .log-entry-actions-jg { margin-left: 0.1rem; }
            .log-entry-jg .song-item-action-jg { padding: 0.2rem 0.3rem; }
            .log-entry-jg .song-item-action-jg i { font-size: 0.9rem; }
            .log-actions-jg button { font-size: 0.8rem; padding: 0.4rem 0.8rem; } /* Adjust action buttons on small screens */
        }

        body.light-mode-jg {
            --jg-bg-deep-jungle: #E0F2E9; 
            --jg-bg-forest-floor: #F5EFE6; 
            --jg-surface-bark: #BCAAA4;    
            --jg-surface-leaf: #A5D6A7;    
            --jg-accent-sunburst: #FF8F00; 
            --jg-accent-canopy: #388E3C;   
            --jg-accent-waterfall: #1976D2;
            --jg-text-light: #37474F;      
            --jg-text-earth: #5D4037;      
            --jg-text-shadow: #78909C;     
            --jg-border-vine: #8D6E63;     

            --jg-surface-bark-rgb: 188, 170, 164;
            --jg-surface-leaf-rgb: 165, 214, 167;
            --jg-bg-forest-floor-rgb: 245, 239, 230;
            --jg-accent-canopy-rgb: 56, 142, 60;
            /* NEW_CODE_START: For light mode dragging style if needed */
            /* --jg-accent-sunburst-rgb: 255, 143, 0; */
            /* NEW_CODE_END */
        }

        body.light-mode-jg .app-safari-hut {
            background-color: rgba(250, 250, 250, 0.75); 
            border-color: var(--jg-surface-bark);
        }
        body.light-mode-jg .safari-map-bar {
            background-color: rgba(var(--jg-surface-bark-rgb), 0.85);
        }
        body.light-mode-jg .search-outpost {
            background-color: rgba(var(--jg-bg-forest-floor-rgb), 0.85);
        }
        body.light-mode-jg #animal-tracker::placeholder { color: var(--jg-text-shadow); }

        body.light-mode-jg .watering-hole-player {
             background: linear-gradient(135deg, rgba(var(--jg-surface-leaf-rgb),0.7), rgba(var(--jg-surface-bark-rgb),0.5));
             border-color: var(--jg-border-vine);
        }
        body.light-mode-jg #main-album-art-jg.album-art-placeholder {
            border-color: var(--jg-surface-bark);
            background-color: var(--jg-text-shadow);
            color: var(--jg-bg-deep-jungle);
        }
        body.light-mode-jg .control-rock {
            background-color: var(--jg-surface-bark);
            border-color: #A1887F; 
            color: var(--jg-text-earth);
        }
        body.light-mode-jg .control-rock.play {
            background-color: var(--jg-accent-canopy);
            border-color: var(--jg-accent-canopy);
            color: var(--jg-text-light); /* Should be light for contrast */
        }
         body.light-mode-jg .control-rock.active-control {
            color: var(--jg-accent-sunburst) !important;
            border-color: var(--jg-accent-sunburst);
            box-shadow: 0 0 10px var(--jg-accent-sunburst), inset 1px 1px 3px rgba(0,0,0,0.05);
        }
        body.light-mode-jg .liana-slider { background-color: var(--jg-border-vine); }
        body.light-mode-jg .liana-slider::-webkit-slider-thumb { background-color: var(--jg-accent-canopy); }
        body.light-mode-jg .fruit-slider { background: var(--jg-surface-bark); }
        body.light-mode-jg .fruit-slider::-webkit-slider-thumb { background: var(--jg-accent-sunburst); border-color: #BF6A00; }

        body.light-mode-jg .explorers-log {
            background-color: rgba(var(--jg-surface-bark-rgb), 0.65);
            border-color: var(--jg-border-vine);
        }
        body.light-mode-jg .log-tabs-jg { border-bottom-color: var(--jg-border-vine); }
        body.light-mode-jg .log-tab-jg { color: var(--jg-text-earth); }
        body.light-mode-jg .log-tab-jg:hover { color: var(--jg-accent-sunburst); }
        body.light-mode-jg .log-tab-jg.active { color: var(--jg-accent-sunburst); }
        body.light-mode-jg .log-tab-jg.active::after { background-color: var(--jg-accent-sunburst); }

        body.light-mode-jg .log-entry-jg { background-color: rgba(var(--jg-bg-forest-floor-rgb), 0.7); }
        body.light-mode-jg .log-entry-jg:hover { background-color: rgba(var(--jg-surface-leaf-rgb),0.6); }
        body.light-mode-jg .log-entry-jg.active-song {
            background-color: rgba(var(--jg-accent-canopy-rgb),0.3);
            border-left-color: var(--jg-accent-canopy);
        }
        body.light-mode-jg .log-entry-jg .img-placeholder.list-thumb-placeholder {
            background-color: var(--jg-text-shadow);
            color: var(--jg-bg-forest-floor);
        }
        body.light-mode-jg .log-entry-jg .song-item-action-jg.remove-from-playlist-action-jg i { color: var(--jg-text-shadow); }
        body.light-mode-jg .log-entry-jg:hover .song-item-action-jg.remove-from-playlist-action-jg i { color: #DC2626; } /* Tailwind red-600 */

        body.light-mode-jg .log-actions-jg { border-top-color: var(--jg-border-vine); }
        body.light-mode-jg .log-actions-jg button {
            background-color: var(--jg-surface-leaf);
            color: var(--jg-text-light); /* Check contrast */
            border-color: var(--jg-accent-canopy);
        }
        body.light-mode-jg .log-actions-jg button:hover {
            background-color: var(--jg-accent-canopy);
        }

        /* Modal Light Mode Styles */
        body.light-mode-jg #createPlaylistModalJG .bg-jg-surface-bark {
            background-color: var(--jg-surface-bark); /* Or a lighter variant like --jg-bg-forest-floor */
        }
        body.light-mode-jg #createPlaylistModalJG .text-jg-text-light {
            color: var(--jg-text-light); /* This will be dark text on light bg */
        }
        body.light-mode-jg #createPlaylistModalJG .text-jg-accent-sunburst {
            color: var(--jg-accent-sunburst);
        }
        body.light-mode-jg #createPlaylistModalJG #newPlaylistNameJG {
            background-color: var(--jg-bg-forest-floor);
            border-color: var(--jg-border-vine);
            color: var(--jg-text-light); /* Dark text */
        }
        body.light-mode-jg #createPlaylistModalJG #newPlaylistNameJG::placeholder {
            color: var(--jg-text-shadow);
        }
        body.light-mode-jg #createPlaylistModalJG #cancelCreatePlaylistJG {
            background-color: var(--jg-text-shadow);
            color: var(--jg-bg-deep-jungle); /* Light text on darkish gray */
        }
         body.light-mode-jg #createPlaylistModalJG #confirmCreatePlaylistJG {
            background-color: var(--jg-accent-canopy);
            color: #FFFFFF; /* White text on green */
        }

        body.light-mode-jg #addToPlaylistModalJG .bg-jg-surface-bark {
            background-color: var(--jg-surface-bark);
        }
        body.light-mode-jg #addToPlaylistModalJG .text-jg-text-light {
            color: var(--jg-text-light);
        }
        body.light-mode-jg #addToPlaylistModalJG .text-jg-accent-sunburst {
            color: var(--jg-accent-sunburst);
        }
        body.light-mode-jg #addToPlaylistModalJG .text-jg-text-earth {
            color: var(--jg-text-earth);
        }
        body.light-mode-jg #addToPlaylistModalJG #addToPlaylistListJG {
            border-color: var(--jg-border-vine);
        }
        body.light-mode-jg #addToPlaylistModalJG #cancelAddToPlaylistJG {
            background-color: var(--jg-text-shadow);
            color: var(--jg-bg-deep-jungle);
        }
        /* Playlist Select Item Styles */
        #addToPlaylistListJG .playlist-select-item-jg {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--jg-border-vine);
            transition: background-color 0.2s;
        }
        #addToPlaylistListJG .playlist-select-item-jg:last-child {
            border-bottom: none;
        }
        #addToPlaylistListJG .playlist-select-item-jg:hover {
            background-color: rgba(var(--jg-surface-leaf-rgb), 0.3);
        }
        body.light-mode-jg #addToPlaylistListJG .playlist-select-item-jg {
            border-bottom-color: var(--jg-border-vine); /* Ensure this is different for light mode if needed */
        }
        body.light-mode-jg #addToPlaylistListJG .playlist-select-item-jg:hover {
            background-color: rgba(var(--jg-surface-leaf-rgb), 0.4); /* Ensure contrast */
        }

    </style>
</head>
<body class="jungle-theme">

    <div class="jungle-background-layers">
        <div class="layer layer-1"></div>
        <div class="layer layer-2"></div>
        <div class="layer layer-3"></div>
    </div>

    <div class="app-safari-hut">

        <header class="safari-map-bar">
            <div class="compass-logo">
                <i class="fas fa-compass"></i>
                <span>Jungle<span class="text-accent-jg">Groove</span></span>
            </div>
            <!-- MODIFIED_CODE: Added clear button -->
            <div class="search-outpost">
                <i class="fas fa-binoculars"></i>
                <input type="text" id="animal-tracker" placeholder="Track your tunes...">
                <button id="clear-search-btn-jg" style="display:none;" title="クリア"><i class="fas fa-times"></i></button>
            </div>
            <div class="safari-tools">
                <button id="weather-toggle" class="tool-btn-jg" title="Toggle Ambience (Theme)"><i class="fas fa-sun"></i></button>
                <button id="profile-ranger" class="tool-btn-jg profile">
                    <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="Ranger Profile" class="img-placeholder profile-avatar-placeholder">
                </button>
            </div>
        </header>

        <main class="safari-zone">
            <section class="watering-hole-player">
                <div class="album-canopy">
                    <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="Album Art" id="main-album-art-jg" class="img-placeholder album-art-placeholder">
                    <div class="leaf-overlay"></div>
                </div>
                <div class="track-details-jg">
                    <h2 id="song-title-jg">Wild Rhythms</h2>
                    <p id="artist-name-jg">The Jungle Cats</p>
                </div>
                <div class="player-controls-jg">
                    <button class="control-rock small" id="btn-shuffle-jg" title="Shuffle (S)"><i class="fas fa-random"></i></button>
                    <button class="control-rock" id="btn-prev-jg" title="Previous (P)"><i class="fas fa-step-backward"></i></button>
                    <button class="control-rock play" id="btn-play-jg" title="Play/Pause (Space)"><i class="fas fa-play"></i></button>
                    <button class="control-rock" id="btn-next-jg" title="Next (N)"><i class="fas fa-step-forward"></i></button>
                    <button class="control-rock small" id="btn-loop-jg" title="Loop (L)"><i class="fas fa-redo-alt"></i></button>
                </div>
                <div class="progress-liana-jg">
                    <span id="current-time-jg">0:00</span>
                    <input type="range" id="progress-slider-jg" class="liana-slider" value="0" title="Seek (←/→)">
                    <span id="total-time-jg">0:00</span>
                </div>
                <div class="volume-fruit-jg">
                    <i class="fas fa-volume-mute animal-icon monkey" title="Mute/Unmute (M)"></i>
                    <input type="range" id="volume-slider-jg" class="fruit-slider" value="75" min="0" max="100" title="Volume (↑/↓)">
                    <i class="fas fa-volume-up animal-icon parrot" title="Volume (icon might change)"></i>
                </div>
            </section>

            <aside class="explorers-log">
                <div class="log-tabs-jg">
                    <button class="log-tab-jg active" data-panel="log-library"><i class="fas fa-tree"></i> Library</button>
                    <button class="log-tab-jg" data-panel="log-paths"><i class="fas fa-map-signs"></i> Playlists</button>
                    <button class="log-tab-jg" data-panel="log-discoveries"><i class="fas fa-paw"></i> Queue <span id="queue-count-jg">0</span></button>
                    <button class="log-tab-jg" data-panel="log-trophies"><i class="fas fa-gem"></i> Favorites</button>
                    <button class="log-tab-jg" data-panel="log-history"><i class="fas fa-history"></i> History</button>
                </div>
                <div class="log-content-jg">
                    <div id="log-library" class="log-panel-jg active">
                        <!-- Library items will be dynamically inserted here -->
                        <div class="log-entry-jg"> <!-- Example, will be cleared -->
                            <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="Song Thumbnail" class="img-placeholder list-thumb-placeholder">
                            <div><span class="title">King of the Beats</span><span class="artist">Leo Roars</span></div>
                            <span class="duration">3:15</span>
                            <div class="log-entry-actions-jg">
                                <button class="song-item-action-jg add-to-queue-action-jg" title="キューに追加" aria-label="キューに追加"> <i class="fas fa-stream"></i></button>
                                <button class="song-item-action-jg favorite-action-jg" title="お気に入りに追加" aria-label="お気に入りに追加"> <i class="fas fa-feather-alt"></i></button>
                            </div>
                        </div>
                    </div>
                    <div id="log-paths" class="log-panel-jg">
                        <!-- Playlist items or songs in playlist will be dynamically inserted here -->
                         <div class="text-center p-8 text-jg-text-shadow">
                            <i class="fas fa-map-signs fa-3x mb-4 opacity-50"></i>
                            <h4 class="font-display-jg text-xl text-jg-text-earth mb-2">No Paths Yet</h4>
                            <p class="text-sm">Create playlists to map your musical journeys!</p>
                        </div>
                    </div>
                    <div id="log-discoveries" class="log-panel-jg">
                        <!-- Queue items will be dynamically inserted here -->
                    </div>
                    <div id="log-trophies" class="log-panel-jg">
                        <!-- Favorite items will be dynamically inserted here -->
                    </div>
                     <div id="log-history" class="log-panel-jg">
                        <!-- History items will be dynamically inserted here -->
                    </div>
                </div>
                 <div id="log-actions-container-jg" class="log-actions-jg">
                    <!-- Buttons will be dynamically inserted here by switchLogPanelJG -->
                </div>
            </aside>
        </main>
    </div>
    
    <!-- Create Playlist Modal (Initially Hidden) -->
    <div id="createPlaylistModalJG" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50" style="display: none;">
        <div class="bg-jg-surface-bark p-6 rounded-lg shadow-xl w-full max-w-md text-jg-text-light">
            <h3 class="font-display-jg text-2xl mb-4 text-jg-accent-sunburst">新しい道 (プレイリスト) を作成</h3>
            <input type="text" id="newPlaylistNameJG" class="w-full p-2 rounded bg-jg-bg-forest-floor border border-jg-border-vine text-jg-text-light placeholder-jg-text-shadow focus:ring-2 focus:ring-jg-accent-canopy outline-none" placeholder="プレイリスト名を入力...">
            <div class="mt-6 flex justify-end gap-3">
                <button id="cancelCreatePlaylistJG" class="px-4 py-2 rounded bg-jg-text-shadow hover:bg-opacity-80 transition-colors">キャンセル</button>
                <button id="confirmCreatePlaylistJG" class="px-4 py-2 rounded bg-jg-accent-canopy hover:bg-opacity-80 text-white transition-colors">作成</button>
            </div>
        </div>
    </div>

    <!-- Add to Playlist Modal (Initially Hidden) -->
    <div id="addToPlaylistModalJG" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50" style="display: none;">
        <div class="bg-jg-surface-bark p-6 rounded-lg shadow-xl w-full max-w-md text-jg-text-light">
            <h3 class="font-display-jg text-2xl mb-1 text-jg-accent-sunburst">プレイリストに追加</h3>
            <p class="text-sm text-jg-text-earth mb-4" id="addToPlaylistSongTitleJG">曲名...</p>
            <div id="addToPlaylistListJG" class="max-h-60 overflow-y-auto mb-4 border border-jg-border-vine rounded">
                <!-- Available playlists will be listed here -->
            </div>
            <div class="mt-6 flex justify-end gap-3">
                <button id="cancelAddToPlaylistJG" class="px-4 py-2 rounded bg-jg-text-shadow hover:bg-opacity-80 transition-colors">キャンセル</button>
            </div>
        </div>
    </div>

    <script src="https://www.youtube.com/iframe_api"></script>
    
    <script>
        // jungle_groove_script.js
        console.log("jungle_groove_script.js parsing started. Waiting for YouTube API...");

        let elementsJG = {}; 
        let appStateJG = {}; 
        // NEW_CODE_START: For drag and drop
        let draggedItemJG = null;
        let draggedItemOriginalIndexJG = -1;
        let currentDragContextJG = null; // 'queue' or 'playlistSongs'
        let dragOverPlaceholderJG = null;
        // NEW_CODE_END

        // ==========================================================================
        // YouTube Player API Ready Callback
        // ==========================================================================
        function onYouTubeIframeAPIReady() {
            console.log("GLOBAL onYouTubeIframeAPIReady CALLED BY YOUTUBE API SCRIPT!");

            if (Object.keys(elementsJG).length === 0 || !elementsJG.youtubePlayerContainer) {
                console.warn("onYouTubeIframeAPIReady: elementsJG not fully initialized or youtubePlayerContainer missing. Initializing elements now for player creation.");
                initializeElementsJG(); 
            }

            if (!elementsJG.youtubePlayerContainer) {
                console.error("onYouTubeIframeAPIReady: Still no youtubePlayerContainer. Player cannot be created.");
                const msg = "プレイヤー表示領域が見つかりません。ページを再読み込みしてください。";
                if (typeof showSnackbarJG === 'function') showSnackbarJG(msg, "error", 10000); else alert(msg);
                return;
            }
            console.log("onYouTubeIframeAPIReady: youtubePlayerContainer found:", elementsJG.youtubePlayerContainer.id);

            try {
                if (Object.keys(appStateJG).length < 5) { 
                    console.warn("onYouTubeIframeAPIReady: appStateJG seems partially initialized, re-setting basic player state.");
                    appStateJG.player = null;
                    appStateJG.isPlayerReady = false;
                    // appStateJG.volume = appStateJG.volume || 75; // Volume is initialized in appStateJG definition
                }

                appStateJG.player = new YT.Player(elementsJG.youtubePlayerContainer.id, {
                    height: '1', 
                    width: '1',  
                    playerVars: {
                        'autoplay': 0,
                        'controls': 0, 
                        'playsinline': 1, 
                        'origin': window.location.origin 
                    },
                    events: {
                        'onReady': onPlayerReadyJG,
                        'onStateChange': onPlayerStateChangeJG,
                        'onError': onPlayerErrorJG
                    }
                });
                console.log("onYouTubeIframeAPIReady: YT.Player instance creation attempted.");
                if (!appStateJG.player) {
                    console.error("onYouTubeIframeAPIReady: YT.Player instance creation FAILED.");
                }
            } catch (e) {
                console.error("onYouTubeIframeAPIReady: Error creating YT.Player instance:", e);
                const message = "YouTubeプレイヤーの作成中にエラー: " + e.message;
                if (typeof showSnackbarJG === 'function') showSnackbarJG(message, "error"); else alert(message);
            }
        }
       
        // ==========================================================================
        // Constants & State
        // ==========================================================================
        const MAX_HISTORY_JG = 20;
        const VOLUME_STEP_JG = 5;
        const SEEK_STEP_JG = 5; // seconds
        const DEFAULT_TITLE_JG = "Jungle Groove - Wild Music Safari"; // NEW_CODE
        const LS_KEYS_JG = {
            HISTORY: 'jungleGrooveHistory',
            FAVORITES: 'jungleGrooveFavorites',
            PLAYLISTS: 'jungleGroovePlaylists',
            USER: 'jungleGrooveUser', // Not currently used, but good to have
            THEME: 'jungleGrooveTheme',
            QUEUE: 'jungleGrooveQueue',
            VOLUME: 'jungleGrooveVolume' // NEW_CODE for persistent volume
        };

        appStateJG = {
            player: null,
            songs: [],
            filteredSongs: [],
            currentSongIndex: -1,
            isPlaying: false,
            isShuffle: false,
            loopMode: 'none', // 'none', 'all', 'one'
            currentPanel: 'log-library',
            volume: 75, // Default volume
            previousVolumeBeforeMute: 75, // NEW_CODE for mute functionality
            isMuted: false, // NEW_CODE
            progressInterval: null,
            history: [],
            favorites: [],
            userPlaylists: [], 
            queue: [], 
            currentQueueIndex: -1, // Index within the current playing list (queue or playlist.songs)
            playMode: 'library', // 'library', 'queue', 'playlist'
            isPlayerReady: false,
            snackbarTimeoutId: null,
            activeModalId: null,
            currentTheme: 'dark',
            buttonsForPanel: { 
                'log-library': ['btn-refresh-feed-jg', 'btn-create-playlist-jg'],
                'log-paths': ['btn-refresh-feed-jg', 'btn-create-playlist-jg'], 
                'playlistSongs': ['btn-refresh-feed-jg', 'btn-create-playlist-jg'], 
                'log-discoveries': ['btn-clear-queue-jg', 'btn-refresh-feed-jg', 'btn-create-playlist-jg'],
                'log-trophies': ['btn-refresh-feed-jg', 'btn-create-playlist-jg'],
                'log-history': ['btn-clear-history-jg', 'btn-refresh-feed-jg', 'btn-create-playlist-jg']
            },
            currentViewingPlaylistId: null, // ID of playlist whose songs are being viewed
            currentPlayingPlaylistId: null // ID of playlist currently being played (if playMode is 'playlist')
        };

        // ==========================================================================
        // Element Initialization
        // ==========================================================================
        function initializeElementsJG() {
            console.log("initializeElementsJG - START");
            elementsJG = {
                body: document.body,
                searchInput: document.getElementById('animal-tracker'),
                clearSearchButton: document.getElementById('clear-search-btn-jg'), // NEW_CODE
                themeToggle: document.getElementById('weather-toggle'),
                profileButton: document.getElementById('profile-ranger'),
                mainAlbumArt: document.getElementById('main-album-art-jg'),
                songTitleDisplay: document.getElementById('song-title-jg'),
                artistNameDisplay: document.getElementById('artist-name-jg'),
                btnShuffle: document.getElementById('btn-shuffle-jg'),
                btnPrev: document.getElementById('btn-prev-jg'),
                btnPlay: document.getElementById('btn-play-jg'),
                btnNext: document.getElementById('btn-next-jg'),
                btnLoop: document.getElementById('btn-loop-jg'),
                currentTimeDisplay: document.getElementById('current-time-jg'),
                totalTimeDisplay: document.getElementById('total-time-jg'),
                progressSlider: document.getElementById('progress-slider-jg'),
                volumeSlider: document.getElementById('volume-slider-jg'),
                volumeIconMute: document.querySelector('.volume-fruit-jg .fa-volume-mute'),
                volumeIconUp: document.querySelector('.volume-fruit-jg .fa-volume-up'),
                logTabs: document.querySelectorAll('.log-tab-jg'),
                logPanels: document.querySelectorAll('.log-panel-jg'),
                libraryPanel: document.getElementById('log-library'),
                queuePanel: document.getElementById('log-discoveries'),
                favoritesPanel: document.getElementById('log-trophies'),
                historyPanel: document.getElementById('log-history'),
                playlistsPanel: document.getElementById('log-paths'),
                queueCountBadge: document.getElementById('queue-count-jg'),
                youtubePlayerContainer: null, // Will be created if not exists
            };

            let ytContainer = document.getElementById('youtube-player-container-jg');
            if (!ytContainer) {
                console.log("initializeElementsJG: youtube-player-container-jg not found, creating it.");
                ytContainer = document.createElement('div');
                ytContainer.id = 'youtube-player-container-jg';
                ytContainer.style.position = 'absolute';
                ytContainer.style.top = '-9999px'; // Keep it off-screen
                ytContainer.style.left = '-9999px';
                ytContainer.style.width = '1px'; // Minimal size
                ytContainer.style.height = '1px';
                document.body.appendChild(ytContainer);
            }
            elementsJG.youtubePlayerContainer = ytContainer;

            console.log("Jungle Groove Elements Initialized (from initializeElementsJG):", Object.keys(elementsJG).length > 0 ? "Success" : "Failed or Partial");
        }

        // ==========================================================================
        // YouTube API & Song Loading
        // ==========================================================================
        const youtubeAPI_JG = {
            apiKey: 'AIzaSyCbzvjP9vFa5I8N1qLI5H9LUpYim0nkQS4', // <<< ここをあなたのAPIキーに置き換えてください!!!
            channelId: 'UCYAuSEKhuk3v4ZKzm5Lqb1Q', 

            async getLatestVideos(maxResults = 15) {
                console.log("getLatestVideos - START. API Key used:", this.apiKey ? 'Yes' : 'No');
                if (!this.apiKey || this.apiKey === 'YOUR_YOUTUBE_API_KEY_HERE' || this.apiKey.length < 30) { 
                    showSnackbarJG("YouTube APIキーが設定されていません。管理者に連絡してください。", "error", 10000);
                    console.error("getLatestVideos: YouTube API Key is invalid or not set!");
                    return [];
                }
                const apiUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=${this.channelId}&maxResults=${maxResults}&order=date&type=video&key=${this.apiKey}`;
                console.log("Fetching YouTube videos from:", apiUrl);
                try {
                    const response = await fetch(apiUrl);
                    console.log("YouTube API Response Status:", response.status, response.statusText);
                    if (!response.ok) {
                        const errorText = await response.text();
                        let errorData = null;
                        try { errorData = JSON.parse(errorText); } catch (e) { console.warn("Could not parse API error response as JSON:", errorText); }

                        const errorMessage = errorData?.error?.message || `YouTube APIエラー: ${response.status} - ${response.statusText || errorText}`;
                        console.error("API Error Data (if JSON):", errorData);
                        console.error("API Error Text (if not JSON or for details):", errorText);
                        throw new Error(errorMessage);
                    }
                    const data = await response.json();
                    console.log("YouTube API Response Data:", data);
                    if (!data.items) {
                        console.warn("No items found in YouTube API response. Full data:", data);
                        return [];
                    }
                    return data.items.map(item => ({
                        id: item.id.videoId,
                        title: item.snippet.title,
                        artist: item.snippet.channelTitle, 
                        thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.medium?.url || item.snippet.thumbnails.default?.url,
                        duration: "--:--" // Fetched later
                    }));
                } catch (error) {
                    console.error('Error in getLatestVideos fetch operation:', error);
                    showSnackbarJG(`曲の読み込み中にエラーが発生しました: ${error.message}`, "error");
                    return [];
                }
            },

            async getVideoDetails(videoIds) {
                console.log("getVideoDetails - START. Fetching for IDs:", videoIds);
                if (!videoIds || videoIds.length === 0) return {};
                if (!this.apiKey || this.apiKey === 'YOUR_YOUTUBE_API_KEY_HERE' || this.apiKey.length < 30) {
                    console.error("youtubeAPI_JG.getVideoDetails: YouTube API Key is invalid or not set!");
                    return {};
                }
                const MAX_IDS_PER_REQUEST = 50;
                const details = {};
                for (let i = 0; i < videoIds.length; i += MAX_IDS_PER_REQUEST) {
                    const chunkIds = videoIds.slice(i, i + MAX_IDS_PER_REQUEST);
                    try {
                        const response = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=contentDetails&id=${chunkIds.join(',')}&key=${this.apiKey}`);
                        if (!response.ok) throw new Error(`YouTube Video Details API error: ${response.status}`);
                        const data = await response.json();
                        if (data.items) {
                            data.items.forEach(item => {
                                if (item.contentDetails) {
                                details[item.id] = this.convertDuration(item.contentDetails.duration);
                                } else {
                                details[item.id] = "--:--"; // Fallback
                                console.warn(`Video item ${item.id} missing contentDetails.`);
                                }
                            });
                        }
                    } catch (error) {
                        console.error('Error fetching video details chunk:', error);
                        // Assign fallback to chunkIds that failed
                        chunkIds.forEach(id => { if (!details[id]) details[id] = "--:--"; });
                    }
                }
                return details;
            },

            convertDuration(isoDuration) {
                if (!isoDuration) return '--:--';
                const regex = /PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/;
                const matches = isoDuration.match(regex);
                if (!matches) return '--:--';
                const hours = parseInt(matches[1] || 0);
                const minutes = parseInt(matches[2] || 0);
                const seconds = parseInt(matches[3] || 0);
                if (hours > 0) {
                    return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        };

        async function loadInitialSongsJG() {
            console.log("loadInitialSongsJG - START");
             if (!youtubeAPI_JG.apiKey || youtubeAPI_JG.apiKey === 'YOUR_YOUTUBE_API_KEY_HERE' || youtubeAPI_JG.apiKey.length < 30) {
                showSnackbarJG("YouTube APIキーが設定されていません。管理者に連絡してください。", "error", 10000);
                console.error("loadInitialSongsJG: YouTube API Key is invalid or not set! Cannot load songs.");
                if (elementsJG.libraryPanel) {
                    showEmptyMessageInPanelJG(elementsJG.libraryPanel, "APIキーエラー", "YouTube APIキーが正しく設定されていません。曲を読み込めません。");
                }
                return;
            }

            if (!elementsJG.libraryPanel) {
                console.error("loadInitialSongsJG: Library panel element not found for loading songs.");
                return;
            }
            console.log("loadInitialSongsJG: Showing loading indicator.");
            showLoadingInPanelJG(elementsJG.libraryPanel, true);

            let songs = [];
            try {
                songs = await youtubeAPI_JG.getLatestVideos(25); 
                console.log("loadInitialSongsJG: Fetched songs from getLatestVideos:", songs.length);
            } catch (error) {
                console.error("loadInitialSongsJG: Error occurred while calling getLatestVideos:", error);
                appStateJG.songs = [];
                appStateJG.filteredSongs = [];
                if (elementsJG.libraryPanel) {
                    renderSongListJG(elementsJG.libraryPanel, [], 'library');
                    showLoadingInPanelJG(elementsJG.libraryPanel, false);
                    showEmptyMessageInPanelJG(elementsJG.libraryPanel, "読み込み失敗", `曲の取得中にエラーが発生しました。APIの割り当て上限、またはネットワークの問題かもしれません。詳細: ${error.message}`);
                }
                return;
            }

            if (songs && songs.length > 0) {
                console.log("loadInitialSongsJG: Fetching durations for " + songs.length + " songs.");
                const videoIds = songs.map(s => s.id).filter(id => id);
                if (videoIds.length > 0) {
                    try {
                        const durations = await youtubeAPI_JG.getVideoDetails(videoIds);
                        console.log("loadInitialSongsJG: Fetched durations:", durations);
                        songs = songs.map(song => ({
                            ...song,
                            artist: song.artist || "Rei Kikuchi", // Default artist if API doesn't provide
                            duration: durations[song.id] || "--:--"
                        }));
                    } catch (error) {
                        console.error("loadInitialSongsJG: Error fetching video details (durations):", error);
                    }
                }
            }

            appStateJG.songs = songs || [];
            appStateJG.filteredSongs = [...(songs || [])];
            console.log("loadInitialSongsJG: Calling renderSongListJG for library with songs:", appStateJG.filteredSongs.length);
            if (elementsJG.libraryPanel) {
                renderSongListJG(elementsJG.libraryPanel, appStateJG.filteredSongs, 'library');
                showLoadingInPanelJG(elementsJG.libraryPanel, false);
            }

            if ((!songs || songs.length === 0)) {
                if (elementsJG.libraryPanel) {
                     showEmptyMessageInPanelJG(elementsJG.libraryPanel, "まだ曲がありません", "新しい冒険が始まるのを待とう！または、APIから曲が返されませんでした。");
                }
            }
            loadInitialDataJG(true); 
        }
        // ==========================================================================
        // UI Rendering
        // ==========================================================================
        function renderSongListJG(panelElement, songsToRender, context) {
            // MODIFIED_CODE: Added drag and drop related logic
            if (!panelElement) {
                console.warn(`Panel element for context "${context}" not found.`);
                return;
            }
            panelElement.innerHTML = ''; 

            const isDraggableContext = (context === 'queue' || context === 'playlistSongs');
            if (isDraggableContext) {
                // Remove old listeners if any, before adding new ones for the container
                panelElement.removeEventListener('dragover', handleDragOverJG);
                panelElement.removeEventListener('drop', handleDropJG);
                panelElement.removeEventListener('dragleave', handleDragLeaveJG); // NEW_CODE

                panelElement.addEventListener('dragover', handleDragOverJG);
                panelElement.addEventListener('drop', (event) => handleDropJG(event, panelElement, context));
                panelElement.addEventListener('dragleave', handleDragLeaveJG); // NEW_CODE
            }


            if (!songsToRender || songsToRender.length === 0) {
                let emptyTitle = "何も見つからない...";
                let emptyMessage = "このエリアにはまだ何もないようだ。";
                if (context === 'library' && elementsJG.searchInput?.value) {
                    emptyTitle = "検索結果なし";
                    emptyMessage = `「${escapeHTMLJG(elementsJG.searchInput.value)}」に合う冒険は見つからなかった...`;
                } else if (context === 'queue') {
                    emptyTitle = "キューは空っぽ";
                    emptyMessage = "次の冒険の準備をしよう！ライブラリから曲を追加できます。";
                } else if (context === 'favorites') {
                    emptyTitle = "お気に入りの宝物なし";
                    emptyMessage = "まだお気に入りの発見がないようだ。曲の羽アイコンをクリック！";
                } else if (context === 'history') {
                    emptyTitle = "足跡なし";
                    emptyMessage = "まだどの曲も探検していないようだ。";
                }
                showEmptyMessageInPanelJG(panelElement, emptyTitle, emptyMessage);
                return;
            }

            const fragment = document.createDocumentFragment();
            songsToRender.forEach((song, listIndex) => { 
                if (!song || !song.id) {
                    console.warn("Skipping invalid song object in renderSongListJG:", song);
                    return;
                }
                const originalSongIndex = appStateJG.songs.findIndex(s => s.id === song.id); // Index in the main appStateJG.songs
                const currentPlayingSong = appStateJG.songs[appStateJG.currentSongIndex];
                const isActive = currentPlayingSong && currentPlayingSong.id === song.id;
                const isFavorited = appStateJG.favorites.some(fav => fav.id === song.id);
                const artistName = song.artist || "Rei Kikuchi";

                const entry = document.createElement('div');
                entry.className = `log-entry-jg ${isActive ? 'active-song' : ''}`;
                entry.dataset.id = song.id;
                entry.dataset.originalIndex = originalSongIndex; // For playing the song from the main list
                // For queue/playlist context, listIndex refers to its position in that specific list (queue or playlist.songs)
                entry.dataset.listIndex = listIndex; 

                // MODIFIED_CODE: Add draggable attributes and listeners if applicable
                if (isDraggableContext) {
                    entry.draggable = true;
                    entry.style.cursor = 'grab';
                    entry.addEventListener('dragstart', (event) => handleDragStartJG(event, song.id, listIndex, context));
                    entry.addEventListener('dragend', handleDragEndJG);
                } else {
                    entry.style.cursor = 'pointer';
                }


                let actionButtonsHTML = '';
                if (context !== 'queue') { 
                    actionButtonsHTML += `
                        <button class="song-item-action-jg add-to-queue-action-jg" title="キューに追加" aria-label="キューに追加">
                            <i class="fas fa-stream"></i>
                        </button>
                    `;
                }
                if (context !== 'queue') { // Also prevent adding from queue to playlist (though UI doesn't show it)
                    actionButtonsHTML += `
                        <button class="song-item-action-jg add-to-playlist-action-jg" title="プレイリストに追加" aria-label="プレイリストに追加">
                            <i class="fas fa-folder-plus"></i>
                        </button>
                    `;
                }
                actionButtonsHTML += `
                    <button class="song-item-action-jg favorite-action-jg" title="${isFavorited ? 'お気に入りから削除' : 'お気に入りに追加'}" aria-label="${isFavorited ? 'お気に入りから削除' : 'お気に入りに追加'}">
                        <i class="fas ${isFavorited ? 'fa-heart text-jg-accent-sunburst' : 'fa-feather-alt'}"></i>
                    </button>
                `;
                if (context === 'playlistSongs' && appStateJG.currentViewingPlaylistId) {
                    actionButtonsHTML += `
                        <button class="song-item-action-jg remove-from-playlist-action-jg" title="このプレイリストから削除" aria-label="このプレイリストから削除">
                            <i class="fas fa-minus-circle text-red-500 hover:text-red-400"></i>
                        </button>
                    `;
                }


                entry.innerHTML = `
                    <img src="${song.thumbnail || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'}"
                         alt="${escapeHTMLJG(song.title || '')}"
                         class="${!song.thumbnail ? 'img-placeholder list-thumb-placeholder' : ''}">
                    <div>
                        <span class="title">${escapeHTMLJG(song.title || '不明なタイトル')}</span>
                        <span class="artist">${escapeHTMLJG(artistName)}</span>
                    </div>
                    <span class="duration">${song.duration || '--:--'}</span>
                    <div class="log-entry-actions-jg">
                        ${actionButtonsHTML}
                    </div>
                `;

                const favButton = entry.querySelector('.favorite-action-jg');
                if (favButton) {
                    favButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleFavoriteJG(song.id, favButton.querySelector('i'), favButton);
                    });
                }

                const addToQueueButton = entry.querySelector('.add-to-queue-action-jg');
                if (addToQueueButton) {
                    addToQueueButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        addToQueueJG(song.id);
                    });
                }

                const addToPlaylistButton = entry.querySelector('.add-to-playlist-action-jg');
                if (addToPlaylistButton) {
                    addToPlaylistButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showAddToPlaylistModalJG(song.id);
                    });
                }

                const removeFromPlaylistButton = entry.querySelector('.remove-from-playlist-action-jg');
                if (removeFromPlaylistButton) {
                    removeFromPlaylistButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (appStateJG.currentViewingPlaylistId) { 
                            confirmRemoveSongFromPlaylistJG(song.id, appStateJG.currentViewingPlaylistId, song.title);
                        }
                    });
                }
                
                // Click to play (only if not dragging, dragstart will handle its own logic)
                entry.addEventListener('click', (e) => {
                    if (e.target.closest('.song-item-action-jg') || entry.classList.contains('dragging-jg')) return; 
                    
                    const songIdToPlay = entry.dataset.id;
                    const originalIdx = parseInt(entry.dataset.originalIndex, 10); // Index in appStateJG.songs

                    if (isNaN(originalIdx) || originalIdx < 0 || originalIdx >= appStateJG.songs.length) {
                         const freshIndex = appStateJG.songs.findIndex(s => s.id === songIdToPlay);
                         if (freshIndex === -1) {
                            showSnackbarJG("この曲は現在再生できません (情報不足)。", "error");
                            return;
                         }
                         console.warn("playSongAtIndexJG: originalIndex was invalid, using freshly found index:", freshIndex);
                         playSongAtIndexJG(freshIndex); 
                         return; 
                    }

                    // Set playMode and currentQueueIndex (which is the index within the specific list like queue or playlist)
                    if (context === 'queue') {
                        appStateJG.playMode = 'queue';
                        appStateJG.currentQueueIndex = parseInt(entry.dataset.listIndex, 10);
                        appStateJG.currentPlayingPlaylistId = null;
                    } else if (context === 'playlistSongs' && appStateJG.currentViewingPlaylistId) {
                        appStateJG.playMode = 'playlist';
                        appStateJG.currentPlayingPlaylistId = appStateJG.currentViewingPlaylistId;
                        appStateJG.currentQueueIndex = parseInt(entry.dataset.listIndex, 10);
                    } else { 
                        appStateJG.playMode = 'library'; // or 'favorites', 'history' - these don't use currentQueueIndex for next/prev logic
                        appStateJG.currentQueueIndex = -1; 
                        appStateJG.currentPlayingPlaylistId = null;
                    }
                    playSongAtIndexJG(originalIdx); 
                });
                fragment.appendChild(entry);
            });
            panelElement.appendChild(fragment);
        }

        function showLoadingInPanelJG(panelElement, isLoading) {
            if (!panelElement) return;
            if (isLoading) {
                panelElement.innerHTML = `<div class="flex justify-center items-center h-full text-jg-text-shadow"><i class="fas fa-spinner fa-spin fa-2x"></i><p class="ml-2">探検中...</p></div>`;
            }
        }

        function showEmptyMessageInPanelJG(panelElement, title, message) {
            if (!panelElement) return;
            panelElement.innerHTML = `
                <div class="text-center p-8 text-jg-text-shadow">
                    <i class="fas fa-map-marked-alt fa-3x mb-4 opacity-50"></i>
                    <h4 class="font-display-jg text-xl text-jg-text-earth mb-2">${escapeHTMLJG(title)}</h4>
                    <p class="text-sm">${escapeHTMLJG(message)}</p>
                </div>`;
        }

        function updatePlayerUIGJ(song) {
            const playerElement = document.querySelector('.watering-hole-player');
            if (song) {
                elementsJG.mainAlbumArt.src = song.thumbnail || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                if (!song.thumbnail) {
                    elementsJG.mainAlbumArt.classList.add('album-art-placeholder');
                    elementsJG.mainAlbumArt.innerHTML = '<i class="fas fa-music"></i>';
                } else {
                    elementsJG.mainAlbumArt.classList.remove('album-art-placeholder');
                    elementsJG.mainAlbumArt.innerHTML = '';
                }
                elementsJG.songTitleDisplay.textContent = song.title || "Wild Rhythms";
                elementsJG.artistNameDisplay.textContent = song.artist || "The Jungle Cats";
                playerElement?.classList.add('has-song');
            } else {
                elementsJG.mainAlbumArt.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                elementsJG.mainAlbumArt.classList.add('album-art-placeholder');
                elementsJG.mainAlbumArt.innerHTML = '<i class="fas fa-music"></i>';
                elementsJG.songTitleDisplay.textContent = "Wild Rhythms";
                elementsJG.artistNameDisplay.textContent = "The Jungle Cats";
                elementsJG.currentTimeDisplay.textContent = "0:00";
                elementsJG.totalTimeDisplay.textContent = "0:00";
                elementsJG.progressSlider.value = 0;
                playerElement?.classList.remove('has-song');
            }
            updatePlayPauseButtonJG();
            updateActiveListItemJG();
            updateDocumentTitleJG(); // NEW_CODE
        }

        function updatePlayPauseButtonJG() {
            if (!elementsJG.btnPlay) return;
            const iconClass = appStateJG.isPlaying ? 'fa-pause' : 'fa-play';
            elementsJG.btnPlay.innerHTML = `<i class="fas ${iconClass}"></i>`;
            document.querySelector('.watering-hole-player')?.classList.toggle('is-playing', appStateJG.isPlaying);
        }

        function updateActiveListItemJG() {
            document.querySelectorAll('.log-entry-jg.active-song').forEach(el => el.classList.remove('active-song'));
            if (appStateJG.currentSongIndex !== -1 && appStateJG.songs && appStateJG.currentSongIndex < appStateJG.songs.length) {
                const currentSongId = appStateJG.songs[appStateJG.currentSongIndex]?.id;
                if (currentSongId) {
                    const activeItems = document.querySelectorAll(`.log-entry-jg[data-id="${currentSongId}"]`);
                    activeItems.forEach(item => item.classList.add('active-song'));
                }
            }
        }
        // NEW_CODE_START: Update document title based on player state
        function updateDocumentTitleJG() {
            if (appStateJG.currentSongIndex === -1 || !appStateJG.songs[appStateJG.currentSongIndex]) {
                document.title = DEFAULT_TITLE_JG;
                return;
            }
            const song = appStateJG.songs[appStateJG.currentSongIndex];
            if (!song) { // Should not happen if currentSongIndex is valid
                 document.title = DEFAULT_TITLE_JG;
                return;
            }
            const prefix = appStateJG.isPlaying ? "▶ " : "❚❚ ";
            document.title = `${prefix}${song.title} - ${song.artist} | Jungle Groove`;
        }
        // NEW_CODE_END

        // ==========================================================================
        // Player Controls
        // ==========================================================================
        function playSongAtIndexJG(index) { 
            if (index < 0 || !appStateJG.songs || index >= appStateJG.songs.length) {
                console.warn("playSongAtIndexJG: Invalid song index:", index, "Song list length:", appStateJG.songs?.length);
                showSnackbarJG("無効な曲のインデックスです。", "error");
                return;
            }
            appStateJG.currentSongIndex = index;
            const song = appStateJG.songs[index];
            if (!song || !song.id) { 
                console.error("playSongAtIndexJG: Song object or song ID is invalid at index:", index, song);
                showSnackbarJG("曲の情報が正しくありません。", "error");
                updatePlayerUIGJ(null); 
                return;
            }

            console.log(`playSongAtIndexJG: Attempting to play song: "${song.title}" (ID: ${song.id}), OriginalIndex: ${index}, PlayMode: ${appStateJG.playMode}, CurrentListIndex: ${appStateJG.currentQueueIndex}`);
            updatePlayerUIGJ(song); // This will also call updateDocumentTitleJG

            if (appStateJG.player && appStateJG.isPlayerReady) {
                try {
                    console.log("playSongAtIndexJG: Calling player.loadVideoById with ID:", song.id);
                    appStateJG.player.loadVideoById(song.id);
                    // Play is handled by onStateChange or triggered after load if needed
                    // appStateJG.player.playVideo(); // YT API docs suggest video plays automatically after loadVideoById IF autoplay is enabled in playerVars. We have it as 0.
                                                  // However, onStateChange to CUED then PLAYING is expected. Let's rely on that. If not, call playVideo() in CUED.
                } catch (error) {
                    console.error("playSongAtIndexJG: Error during loadVideoById:", error);
                    showSnackbarJG("動画の読み込みに失敗しました。", "error");
                }
            } else {
                console.warn("playSongAtIndexJG: Player not ready or song ID missing. Player:", !!appStateJG.player, "Ready:", appStateJG.isPlayerReady, "Song ID:", song.id);
                 if (!appStateJG.isPlayerReady) {
                    showSnackbarJG("プレイヤーの準備ができていません。少々お待ちください。", "warning");
                 } else if (!song.id) {
                    showSnackbarJG("再生する曲のIDが見つかりません。", "error");
                 }
            }
            addToHistoryJG(song);
            if (appStateJG.currentPanel === 'log-history' && elementsJG.historyPanel) renderHistoryListJG();
        }

        function togglePlayPauseJG() {
            if (!appStateJG.player || !appStateJG.isPlayerReady) {
                showSnackbarJG("プレイヤーの準備ができていません。", "warning");
                return;
            }
            if (appStateJG.currentSongIndex === -1 && appStateJG.songs && appStateJG.songs.length > 0) {
                // If no song is selected, play the first from library (or current view if applicable)
                appStateJG.playMode = 'library'; // Default to library
                appStateJG.currentQueueIndex = -1;
                playSongAtIndexJG(0);
                return;
            }
            if (appStateJG.currentSongIndex === -1 && (!appStateJG.songs || appStateJG.songs.length === 0)) {
                showSnackbarJG("再生する曲がありません。", "info");
                return;
            }

            if (appStateJG.isPlaying) {
                appStateJG.player.pauseVideo();
            } else {
                appStateJG.player.playVideo();
            }
            // State change will handle UI updates
        }

        function playNextJG() {
            if (!appStateJG.songs || appStateJG.songs.length === 0) {
                showSnackbarJG("再生リストに曲がありません。", "info");
                return;
            }
            
            let nextSongOriginalIndex = -1; // Index in appStateJG.songs
            let currentList; // The list we are iterating (queue, playlist.songs, or appStateJG.filteredSongs for library)
            let nextListIndex; // The index for the next song within currentList

            if (appStateJG.playMode === 'queue' && appStateJG.queue.length > 0) {
                currentList = appStateJG.queue.map(id => findSongByIdJG(id)).filter(s => s); // Array of song objects
                nextListIndex = appStateJG.currentQueueIndex + 1;

                if (nextListIndex >= currentList.length) { 
                    if (appStateJG.loopMode === 'all') {
                        nextListIndex = 0;
                    } else {
                        showSnackbarJG("キューの再生が終わりました。", "info");
                        appStateJG.isPlaying = false;
                        updatePlayPauseButtonJG();
                        updateDocumentTitleJG();
                        // Optionally, switch back to library play mode or stop
                        // appStateJG.playMode = 'library'; 
                        // appStateJG.currentQueueIndex = -1;
                        return; 
                    }
                }
                appStateJG.currentQueueIndex = nextListIndex;
                const nextSongIdInQueue = appStateJG.queue[appStateJG.currentQueueIndex];
                nextSongOriginalIndex = appStateJG.songs.findIndex(s => s.id === nextSongIdInQueue);
                
            } else if (appStateJG.playMode === 'playlist' && appStateJG.currentPlayingPlaylistId) {
                const playlist = appStateJG.userPlaylists.find(p => p.id === appStateJG.currentPlayingPlaylistId);
                if (playlist && playlist.songs.length > 0) {
                    currentList = playlist.songs.map(id => findSongByIdJG(id)).filter(s => s);
                    nextListIndex = appStateJG.currentQueueIndex + 1; 

                    if (nextListIndex >= currentList.length) {
                        if (appStateJG.loopMode === 'all') {
                            nextListIndex = 0;
                        } else {
                            showSnackbarJG(`プレイリスト「${escapeHTMLJG(playlist.name)}」の再生が終わりました。`, "info");
                            appStateJG.isPlaying = false;
                            updatePlayPauseButtonJG();
                            updateDocumentTitleJG();
                            return;
                        }
                    }
                    appStateJG.currentQueueIndex = nextListIndex;
                    const nextSongIdInPlaylist = playlist.songs[appStateJG.currentQueueIndex];
                    nextSongOriginalIndex = appStateJG.songs.findIndex(s => s.id === nextSongIdInPlaylist);
                } else { 
                    appStateJG.playMode = 'library'; // Fallback
                    appStateJG.currentPlayingPlaylistId = null;
                    appStateJG.currentQueueIndex = -1;
                }
            }
            
            // Fallback to library mode if not in queue/playlist or if song not found
            if (appStateJG.playMode === 'library' || nextSongOriginalIndex === -1) {
                 currentList = appStateJG.isShuffle ? appStateJG.songs : appStateJG.filteredSongs; // Use filtered for non-shuffle library
                 if (currentList.length === 0) currentList = appStateJG.songs; // Absolute fallback
                 if (currentList.length === 0) return;


                 if (appStateJG.isShuffle) {
                    if (currentList.length <= 1) nextSongOriginalIndex = appStateJG.songs.findIndex(s => s.id === currentList[0]?.id);
                    else {
                        let randomOriginalIndex;
                        let randomSongId;
                        do { 
                            randomSongId = currentList[Math.floor(Math.random() * currentList.length)].id;
                            randomOriginalIndex = appStateJG.songs.findIndex(s => s.id === randomSongId);
                        } while (randomOriginalIndex === appStateJG.currentSongIndex && currentList.length > 1);
                        nextSongOriginalIndex = randomOriginalIndex;
                    }
                } else { 
                    // Find current song in filteredSongs to get its index for next calculation
                    let currentFilteredIndex = -1;
                    if (appStateJG.currentSongIndex !== -1) {
                        const currentActualSongId = appStateJG.songs[appStateJG.currentSongIndex].id;
                        currentFilteredIndex = appStateJG.filteredSongs.findIndex(s => s.id === currentActualSongId);
                    }
                    
                    nextListIndex = (currentFilteredIndex === -1) ? 0 : currentFilteredIndex + 1;
                    if (nextListIndex >= appStateJG.filteredSongs.length) {
                        if (appStateJG.loopMode === 'all') {
                            nextListIndex = 0;
                        } else {
                            showSnackbarJG("探検の終わりです！", "info");
                            appStateJG.isPlaying = false;
                            updatePlayPauseButtonJG();
                            updateDocumentTitleJG();
                            return; 
                        }
                    }
                    if (appStateJG.filteredSongs[nextListIndex]) {
                        nextSongOriginalIndex = appStateJG.songs.findIndex(s => s.id === appStateJG.filteredSongs[nextListIndex].id);
                    }
                }
            }
            
            if (nextSongOriginalIndex !== -1) {
                playSongAtIndexJG(nextSongOriginalIndex);
            } else {
                 console.warn("Could not determine next song. Current playMode:", appStateJG.playMode);
                 // Potentially stop playback or reset
                appStateJG.isPlaying = false;
                updatePlayPauseButtonJG();
                updateDocumentTitleJG();
            }
        }


        function playPrevJG() {
            if (!appStateJG.songs || appStateJG.songs.length === 0) {
                showSnackbarJG("再生リストに曲がありません。", "info");
                return;
            }

            if (appStateJG.player && appStateJG.isPlayerReady && appStateJG.player.getCurrentTime && appStateJG.player.getCurrentTime() > SEEK_STEP_JG) {
                appStateJG.player.seekTo(0);
                return;
            }

            let prevSongOriginalIndex = -1;
            let currentList;
            let prevListIndex;

            if (appStateJG.playMode === 'queue' && appStateJG.queue.length > 0) {
                currentList = appStateJG.queue.map(id => findSongByIdJG(id)).filter(s => s);
                prevListIndex = appStateJG.currentQueueIndex - 1;

                if (prevListIndex < 0) { 
                    if (appStateJG.loopMode === 'all' && currentList.length > 0) {
                        prevListIndex = currentList.length - 1;
                    } else {
                        // Stay at the first song, or seek to 0 if already there
                        prevListIndex = 0; 
                        if (appStateJG.player && appStateJG.isPlayerReady && appStateJG.player.seekTo) appStateJG.player.seekTo(0);
                        // If we don't want to replay the first song, we might return here.
                        // For now, it will effectively restart the first song if at the beginning.
                    }
                }
                appStateJG.currentQueueIndex = prevListIndex;
                const prevSongIdInQueue = appStateJG.queue[appStateJG.currentQueueIndex];
                prevSongOriginalIndex = appStateJG.songs.findIndex(s => s.id === prevSongIdInQueue);

            } else if (appStateJG.playMode === 'playlist' && appStateJG.currentPlayingPlaylistId) {
                const playlist = appStateJG.userPlaylists.find(p => p.id === appStateJG.currentPlayingPlaylistId);
                if (playlist && playlist.songs.length > 0) {
                    currentList = playlist.songs.map(id => findSongByIdJG(id)).filter(s => s);
                    prevListIndex = appStateJG.currentQueueIndex - 1; 
                     if (prevListIndex < 0) {
                        if (appStateJG.loopMode === 'all') {
                            prevListIndex = currentList.length - 1;
                        } else {
                            prevListIndex = 0;
                            if (appStateJG.player && appStateJG.isPlayerReady && appStateJG.player.seekTo) appStateJG.player.seekTo(0);
                        }
                    }
                    appStateJG.currentQueueIndex = prevListIndex;
                    const prevSongIdInPlaylist = playlist.songs[appStateJG.currentQueueIndex];
                    prevSongOriginalIndex = appStateJG.songs.findIndex(s => s.id === prevSongIdInPlaylist);
                } else {
                    appStateJG.playMode = 'library';
                    appStateJG.currentPlayingPlaylistId = null;
                    appStateJG.currentQueueIndex = -1;
                }
            }
            
            if (appStateJG.playMode === 'library' || prevSongOriginalIndex === -1) {
                 currentList = appStateJG.isShuffle ? appStateJG.songs : appStateJG.filteredSongs;
                 if (currentList.length === 0) currentList = appStateJG.songs;
                 if (currentList.length === 0) return;

                if (appStateJG.isShuffle) {
                     if (currentList.length <= 1) prevSongOriginalIndex = appStateJG.songs.findIndex(s => s.id === currentList[0]?.id);
                     else {
                        let randomOriginalIndex;
                        let randomSongId;
                        do { 
                            randomSongId = currentList[Math.floor(Math.random() * currentList.length)].id;
                            randomOriginalIndex = appStateJG.songs.findIndex(s => s.id === randomSongId);
                        } while (randomOriginalIndex === appStateJG.currentSongIndex && currentList.length > 1);
                        prevSongOriginalIndex = randomOriginalIndex;
                    }
                } else { 
                    let currentFilteredIndex = -1;
                    if (appStateJG.currentSongIndex !== -1) {
                        const currentActualSongId = appStateJG.songs[appStateJG.currentSongIndex].id;
                        currentFilteredIndex = appStateJG.filteredSongs.findIndex(s => s.id === currentActualSongId);
                    }
                    
                    prevListIndex = currentFilteredIndex - 1;
                    if (prevListIndex < 0) {
                        if (appStateJG.loopMode === 'all' && appStateJG.filteredSongs.length > 0) {
                            prevListIndex = appStateJG.filteredSongs.length - 1;
                        } else {
                            prevListIndex = 0; 
                            if (appStateJG.player && appStateJG.isPlayerReady && appStateJG.player.seekTo) appStateJG.player.seekTo(0);
                        }
                    }
                     if (appStateJG.filteredSongs[prevListIndex]) {
                        prevSongOriginalIndex = appStateJG.songs.findIndex(s => s.id === appStateJG.filteredSongs[prevListIndex].id);
                    }
                }
            }
            
            if (prevSongOriginalIndex !== -1) {
                playSongAtIndexJG(prevSongOriginalIndex);
            } else {
                 console.warn("Could not determine previous song. Current playMode:", appStateJG.playMode);
            }
        }

        function handleSongEndJG() {
            if (appStateJG.loopMode === 'one' && appStateJG.currentSongIndex !== -1) {
                playSongAtIndexJG(appStateJG.currentSongIndex); 
            } else {
                playNextJG(); 
            }
        }

        function updateProgressJG() {
            if (!appStateJG.player || !appStateJG.isPlayerReady || typeof appStateJG.player.getDuration !== 'function' || !elementsJG.progressSlider) return;
            const currentTime = appStateJG.player.getCurrentTime ? appStateJG.player.getCurrentTime() : 0;
            const duration = appStateJG.player.getDuration ? appStateJG.player.getDuration() : 0;

            if (elementsJG.progressSlider && elementsJG.currentTimeDisplay && elementsJG.totalTimeDisplay) {
                if (duration > 0) {
                    const progressPercent = (currentTime / duration) * 100;
                    elementsJG.progressSlider.value = progressPercent;
                    elementsJG.currentTimeDisplay.textContent = formatTimeJG(currentTime);
                    elementsJG.totalTimeDisplay.textContent = formatTimeJG(duration);

                    const currentSong = appStateJG.songs[appStateJG.currentSongIndex];
                    if (currentSong && currentSong.duration === "--:--") { // Update duration if it was a placeholder
                        currentSong.duration = formatTimeJG(duration);
                        // Update duration in the list items if visible
                        document.querySelectorAll(`.log-entry-jg[data-id="${currentSong.id}"] .duration`).forEach(el => {
                           el.textContent = currentSong.duration;
                        });
                    }
                } else {
                    elementsJG.progressSlider.value = 0;
                    elementsJG.currentTimeDisplay.textContent = "0:00";
                    // totalTimeDisplay might still show old value if duration is 0 (e.g. before first play)
                    // It gets updated once a song with duration is played.
                }
            }
        }
        // ==========================================================================
        // YouTube Player Event Handlers
        // ==========================================================================
        function onPlayerReadyJG(event) {
            console.log("Jungle Groove Player Ready! (onPlayerReadyJG called). Player object available:", !!event.target);
            appStateJG.isPlayerReady = true;
            if (event.target && typeof event.target.setVolume === 'function') {
                try {
                    // Volume is now loaded from localStorage in loadInitialDataJG and applied via setVolumeJG
                    setVolumeJG(appStateJG.volume, false); // Apply initial volume without saving again
                    console.log("onPlayerReadyJG: Volume set to", appStateJG.volume);
                } catch(e){
                    console.warn("onPlayerReadyJG: Could not set volume on ready", e);
                }
            } else {
                console.warn("onPlayerReadyJG: event.target or setVolume not available for volume setting.");
            }
            console.log("onPlayerReadyJG: Calling loadInitialSongsJG...");
            loadInitialSongsJG();
        }

        function onPlayerStateChangeJG(event) {
            const playerState = event.data;
            console.log("onPlayerStateChangeJG - Player state changed to:", playerState, "(Compare with YT.PlayerState: UNSTARTED -1, ENDED 0, PLAYING 1, PAUSED 2, BUFFERING 3, CUED 5)");

            if (playerState === YT.PlayerState.PLAYING) { // 1
                appStateJG.isPlaying = true;
                if (appStateJG.progressInterval) clearInterval(appStateJG.progressInterval);
                appStateJG.progressInterval = setInterval(updateProgressJG, 500);
                updatePlayerUIGJ(appStateJG.songs[appStateJG.currentSongIndex]); // Also calls updateDocumentTitleJG
                updateActiveListItemJG(); 
                
                const currentSongObject = appStateJG.songs[appStateJG.currentSongIndex];
                if (currentSongObject) { // Update currentQueueIndex if it drifted
                    if (appStateJG.playMode === 'queue') {
                        const songIdInQueue = appStateJG.queue[appStateJG.currentQueueIndex];
                        if (songIdInQueue !== currentSongObject.id) {
                            const newQueueIndex = appStateJG.queue.findIndex(id => id === currentSongObject.id);
                            if (newQueueIndex !== -1) appStateJG.currentQueueIndex = newQueueIndex;
                            else { appStateJG.playMode = 'library'; appStateJG.currentQueueIndex = -1; }
                        }
                    } else if (appStateJG.playMode === 'playlist' && appStateJG.currentPlayingPlaylistId) {
                        const playlist = appStateJG.userPlaylists.find(p => p.id === appStateJG.currentPlayingPlaylistId);
                        if (playlist) {
                            const songIdInPlaylist = playlist.songs[appStateJG.currentQueueIndex]; 
                            if (songIdInPlaylist !== currentSongObject.id) {
                                const newPlaylistSongIndex = playlist.songs.findIndex(id => id === currentSongObject.id);
                                if (newPlaylistSongIndex !== -1) appStateJG.currentQueueIndex = newPlaylistSongIndex;
                                else { appStateJG.playMode = 'library'; appStateJG.currentPlayingPlaylistId = null; appStateJG.currentQueueIndex = -1; }
                            }
                        } else { appStateJG.playMode = 'library'; appStateJG.currentPlayingPlaylistId = null; appStateJG.currentQueueIndex = -1; }
                    }
                }
            } else if (playerState === YT.PlayerState.PAUSED) { // 2
                appStateJG.isPlaying = false;
                clearInterval(appStateJG.progressInterval);
                updatePlayPauseButtonJG();
                updateDocumentTitleJG(); // NEW_CODE
            } else if (playerState === YT.PlayerState.ENDED) { // 0
                appStateJG.isPlaying = false;
                clearInterval(appStateJG.progressInterval);
                updatePlayPauseButtonJG();
                updateDocumentTitleJG(); // NEW_CODE
                if(elementsJG.progressSlider) elementsJG.progressSlider.value = 100; 
                if(elementsJG.currentTimeDisplay && elementsJG.totalTimeDisplay) { 
                    elementsJG.currentTimeDisplay.textContent = elementsJG.totalTimeDisplay.textContent;
                }
                handleSongEndJG();
            } else if (playerState === YT.PlayerState.BUFFERING) { // 3
                console.log("Player is buffering...");
            } else if (playerState === YT.PlayerState.CUED) { // 5
                console.log("Video cued:", appStateJG.songs[appStateJG.currentSongIndex]?.title);
                updateProgressJG(); 
                // Sometimes player doesn't auto-play after loadVideoById if autoplay is 0.
                // If not playing and a song is cued, try to play it.
                if (!appStateJG.isPlaying && appStateJG.currentSongIndex !== -1) {
                    console.log("onPlayerStateChangeJG (CUED): Song cued, attempting to play explicitly.");
                    appStateJG.player.playVideo();
                }
            } else if (playerState === -1) { // UNSTARTED
                 console.log("Player unstarted.");
                 updateDocumentTitleJG(); // NEW_CODE
            }
        }

        function onPlayerErrorJG(event) {
            console.error("onPlayerErrorJG - Error code:", event.data, "for song ID:", appStateJG.songs[appStateJG.currentSongIndex]?.id, "Song Title:", appStateJG.songs[appStateJG.currentSongIndex]?.title);
            let msg = `動画の再生エラー (コード: ${event.data})`;
            const currentSongTitle = appStateJG.songs[appStateJG.currentSongIndex]?.title || "この動画";
            switch(event.data) {
                case 2: msg = `「${escapeHTMLJG(currentSongTitle)}」の読み込みに失敗しました。動画IDが無効か、リクエストに問題がある可能性があります。`; break;
                case 5: msg = `「${escapeHTMLJG(currentSongTitle)}」の再生中にHTML5プレイヤーエラーが発生しました。`; break;
                case 100: msg = `「${escapeHTMLJG(currentSongTitle)}」が見つかりませんでした。非公開または削除された可能性があります。`; break;
                case 101: case 150: msg = `「${escapeHTMLJG(currentSongTitle)}」の埋め込み再生は、所有者によって許可されていません。`; break;
                default: msg = `「${escapeHTMLJG(currentSongTitle)}」の再生中に不明なエラーが発生しました (コード: ${event.data})。`;
            }
            showSnackbarJG(msg, "error", 7000); 
            appStateJG.isPlaying = false;
            updatePlayPauseButtonJG();
            updateDocumentTitleJG(); // NEW_CODE
        }

        // ==========================================================================
        // Log Action Buttons & Panel Specific Actions
        // ==========================================================================
        function updateLogActionButtonsJG(panelIdToUpdate) {
            const container = document.getElementById('log-actions-container-jg');
            if (!container) {
                console.error("Log actions container not found!");
                return;
            }
            container.innerHTML = ''; 

            const currentContextId = appStateJG.currentViewingPlaylistId && panelIdToUpdate === 'log-paths' 
                                   ? 'playlistSongs' 
                                   : panelIdToUpdate;

            const actionsToShow = appStateJG.buttonsForPanel[currentContextId] || appStateJG.buttonsForPanel['log-library']; 

            actionsToShow.forEach(actionId => {
                let button;
                switch (actionId) {
                    case 'btn-refresh-feed-jg':
                        button = document.createElement('button');
                        button.innerHTML = '<i class="fas fa-sync-alt"></i> Feedを更新';
                        button.addEventListener('click', () => {
                            showSnackbarJG("ジャングルの最新情報を取得中...", "info");
                            loadInitialSongsJG();
                        });
                        break;
                    case 'btn-create-playlist-jg':
                        button = document.createElement('button');
                        button.innerHTML = '<i class="fas fa-plus-circle"></i> 新しい道';
                        button.addEventListener('click', showCreatePlaylistModalJG);
                        break;
                    case 'btn-clear-queue-jg':
                        if (appStateJG.queue.length > 0) { 
                            button = document.createElement('button');
                            button.innerHTML = '<i class="fas fa-trash-alt"></i> キューを空に';
                            button.addEventListener('click', confirmClearQueueJG);
                        }
                        break;
                    case 'btn-clear-history-jg':
                         if (appStateJG.history.length > 0) {
                            button = document.createElement('button');
                            button.innerHTML = '<i class="fas fa-history"></i> <i class="fas fa-trash-alt"></i> 履歴をクリア';
                            button.addEventListener('click', confirmClearHistoryJG);
                        }
                        break;
                }
                if (button) {
                    container.appendChild(button);
                }
            });
        }

        function confirmClearQueueJG() {
            if (appStateJG.queue.length === 0) {
                showSnackbarJG("キューは既に空です。", "info");
                return;
            }
            if (confirm("本当にキューを空にしますか？")) {
                clearQueueJG();
            }
        }
        function clearQueueJG() {
            appStateJG.queue = [];
            appStateJG.currentQueueIndex = -1; 
            saveToLocalStorageJG(LS_KEYS_JG.QUEUE, appStateJG.queue);
            updateQueueCountBadgeJG();
            if (appStateJG.currentPanel === 'log-discoveries' && elementsJG.queuePanel) {
                renderSongListJG(elementsJG.queuePanel, [], 'queue'); 
            }
            showSnackbarJG("キューを空にしました。", "success");
            updateLogActionButtonsJG('log-discoveries'); 
        }

        function confirmClearHistoryJG() {
             if (appStateJG.history.length === 0) {
                showSnackbarJG("再生履歴は既に空です。", "info");
                return;
            }
            if (confirm("本当に再生履歴を全て削除しますか？")) {
                clearHistoryJG();
            }
        }
        function clearHistoryJG() {
            appStateJG.history = [];
            saveToLocalStorageJG(LS_KEYS_JG.HISTORY, appStateJG.history);
            if (appStateJG.currentPanel === 'log-history' && elementsJG.historyPanel) {
                renderHistoryListJG(); 
            }
            showSnackbarJG("再生履歴を削除しました。", "success");
            updateLogActionButtonsJG('log-history');
        }

        // ==========================================================================
        // Event Listeners Setup
        // ==========================================================================
        function setupEventListenersJG() {
            elementsJG.btnPlay?.addEventListener('click', togglePlayPauseJG);
            elementsJG.btnNext?.addEventListener('click', playNextJG);
            elementsJG.btnPrev?.addEventListener('click', playPrevJG);
            elementsJG.btnShuffle?.addEventListener('click', toggleShuffleJG);
            elementsJG.btnLoop?.addEventListener('click', toggleLoopJG);

            elementsJG.progressSlider?.addEventListener('input', (e) => {
                if (!appStateJG.player || !appStateJG.isPlayerReady || typeof appStateJG.player.getDuration !== 'function') return;
                const duration = appStateJG.player.getDuration();
                if (duration > 0) {
                    const seekTime = (parseFloat(e.target.value) / 100) * duration;
                    if (appStateJG.player.seekTo) appStateJG.player.seekTo(seekTime, true); // true: allow seek ahead
                    updateProgressJG(); // Visually update immediately
                }
            });

            elementsJG.volumeSlider?.addEventListener('input', (e) => {
                const newVolume = parseInt(e.target.value);
                setVolumeJG(newVolume); // This will update state, player, UI, and save
            });
             // NEW_CODE_START: Mute icon click listener
            elementsJG.volumeIconMute?.addEventListener('click', toggleMuteJG);
            elementsJG.volumeIconUp?.addEventListener('click', () => { // If unmuted by clicking speaker icon
                if (appStateJG.isMuted) toggleMuteJG();
            });
            // NEW_CODE_END

            elementsJG.themeToggle?.addEventListener('click', toggleThemeJG);

            elementsJG.logTabs.forEach(tab => {
                tab.addEventListener('click', () => switchLogPanelJG(tab.dataset.panel));
            });
            
            elementsJG.searchInput?.addEventListener('input', handleSearchJG);

            // NEW_CODE_START: Search clear button listener
            elementsJG.clearSearchButton?.addEventListener('click', () => {
                if (elementsJG.searchInput) {
                    elementsJG.searchInput.value = '';
                    elementsJG.searchInput.dispatchEvent(new Event('input')); // Trigger search handler
                    elementsJG.searchInput.focus();
                }
            });
            // NEW_CODE_END
            
            // NEW_CODE_START: Global Keydown Listener
            document.addEventListener('keydown', handleGlobalKeydownJG);
            // NEW_CODE_END
        }
        // ==========================================================================
        // UI & Control Logic Helpers
        // ==========================================================================
        function toggleThemeJG() {
            if (!elementsJG.body || !elementsJG.themeToggle) return;
            elementsJG.body.classList.toggle('light-mode-jg'); 
            appStateJG.currentTheme = elementsJG.body.classList.contains('light-mode-jg') ? 'light' : 'dark';
            elementsJG.themeToggle.innerHTML = `<i class="fas ${appStateJG.currentTheme === 'light' ? 'fa-moon' : 'fa-sun'}"></i>`;
            saveToLocalStorageJG(LS_KEYS_JG.THEME, appStateJG.currentTheme);
            showSnackbarJG(`天候が「${appStateJG.currentTheme === 'light' ? '昼のジャングル' : '夜のジャングル'}」に！`);
        }

        function switchLogPanelJG(panelId) {
            if (!panelId) return; 
            
            if (appStateJG.currentViewingPlaylistId && panelId !== 'log-paths') {
                 appStateJG.currentViewingPlaylistId = null; 
            }
            
            appStateJG.currentPanel = panelId;

            elementsJG.logTabs.forEach(t => t.classList.toggle('active', t.dataset.panel === panelId));
            elementsJG.logPanels.forEach(p => {
                if (p) p.classList.toggle('active', p.id === panelId);
            });

            // MODIFIED_CODE: Use findSongByIdJG for queue rendering
            switch (panelId) {
                case 'log-library':
                    if (elementsJG.libraryPanel) renderSongListJG(elementsJG.libraryPanel, appStateJG.filteredSongs, 'library');
                    break;
                case 'log-discoveries': 
                    if (elementsJG.queuePanel) renderSongListJG(elementsJG.queuePanel, appStateJG.queue.map(id => findSongByIdJG(id)).filter(s => s), 'queue');
                    break;
                case 'log-trophies': 
                    if (elementsJG.favoritesPanel) renderSongListJG(elementsJG.favoritesPanel, appStateJG.favorites, 'favorites');
                    break;
                case 'log-history':
                    if(elementsJG.historyPanel) renderHistoryListJG();
                    break;
                case 'log-paths': 
                    if(elementsJG.playlistsPanel) {
                        // If a playlist was being viewed, stay on it, otherwise show list of playlists
                        if (appStateJG.currentViewingPlaylistId) {
                             renderSongsInPlaylistJG(appStateJG.currentViewingPlaylistId);
                        } else {
                             renderPlaylistsJG(); 
                        }
                    }
                    break;
            }
            updateLogActionButtonsJG(panelId); 
        }

        function handleSearchJG() {
            if (!elementsJG.searchInput || !elementsJG.clearSearchButton) return; // MODIFIED_CODE
            const searchTerm = elementsJG.searchInput.value.toLowerCase().trim();

            // MODIFIED_CODE: Show/hide clear button
            elementsJG.clearSearchButton.style.display = searchTerm ? 'inline-block' : 'none';

            if (searchTerm === "") {
                appStateJG.filteredSongs = [...appStateJG.songs];
            } else {
                appStateJG.filteredSongs = appStateJG.songs.filter(song =>
                    (song.title && song.title.toLowerCase().includes(searchTerm)) ||
                    (song.artist && song.artist.toLowerCase().includes(searchTerm))
                );
            }

            if (appStateJG.currentPanel === 'log-library' && elementsJG.libraryPanel) {
                renderSongListJG(elementsJG.libraryPanel, appStateJG.filteredSongs, 'library');
            }
        }

        function toggleShuffleJG() {
            if (!elementsJG.btnShuffle) return;
            appStateJG.isShuffle = !appStateJG.isShuffle;
            elementsJG.btnShuffle.classList.toggle('active-control', appStateJG.isShuffle);
            showSnackbarJG(`シャッフル・ビート ${appStateJG.isShuffle ? 'ON' : 'OFF'}!`);
            // Note: Shuffle primarily affects 'library' playMode's next/prev.
            // Queue and Playlist playModes follow their defined order unless explicitly shuffled (not implemented).
        }

        function toggleLoopJG() {
            if (!elementsJG.btnLoop) return;
            if (appStateJG.loopMode === 'none') appStateJG.loopMode = 'all';
            else if (appStateJG.loopMode === 'all') appStateJG.loopMode = 'one';
            else appStateJG.loopMode = 'none';

            elementsJG.btnLoop.classList.toggle('active-control', appStateJG.loopMode !== 'none');
            let loopIndicator = elementsJG.btnLoop.querySelector('.loop-indicator-jg');

            if (appStateJG.loopMode === 'one') {
                if (!loopIndicator) {
                    loopIndicator = document.createElement('span');
                    loopIndicator.className = 'loop-indicator-jg';
                    elementsJG.btnLoop.appendChild(loopIndicator);
                }
                loopIndicator.textContent = '1';
            } else {
                if (loopIndicator) loopIndicator.remove();
            }

            let loopMsg = "リピート: ";
            if(appStateJG.loopMode === 'none') loopMsg += "OFF";
            if(appStateJG.loopMode === 'all') loopMsg += "ジャングル全体" + (appStateJG.playMode === 'queue' && appStateJG.queue.length > 0 ? " (キュー)" : "");
            if(appStateJG.loopMode === 'one') loopMsg += "この一本の木";
            showSnackbarJG(loopMsg);
        }

        // NEW_CODE_START: Volume and Mute controls
        function setVolumeJG(volume, save = true) {
            appStateJG.volume = Math.max(0, Math.min(100, volume)); // Clamp between 0 and 100
            appStateJG.isMuted = (appStateJG.volume === 0);

            if (elementsJG.volumeSlider) elementsJG.volumeSlider.value = appStateJG.volume;
            
            if (appStateJG.player && appStateJG.isPlayerReady && typeof appStateJG.player.setVolume === 'function') {
                appStateJG.player.setVolume(appStateJG.volume);
                if (appStateJG.isMuted && typeof appStateJG.player.mute === 'function') {
                    // Some players might not unmute automatically when volume > 0
                    // appStateJG.player.mute(); // Not strictly needed if setVolume(0) mutes
                } else if (!appStateJG.isMuted && typeof appStateJG.player.unMute === 'function' && appStateJG.player.isMuted()) {
                     appStateJG.player.unMute();
                }
            }
            updateVolumeIconsJG();
            if (save) saveToLocalStorageJG(LS_KEYS_JG.VOLUME, appStateJG.volume);
        }

        function toggleMuteJG() {
            if (appStateJG.isMuted) { // Unmute
                // Restore to previous volume or a default if previous was 0
                setVolumeJG(appStateJG.previousVolumeBeforeMute > 0 ? appStateJG.previousVolumeBeforeMute : 25);
            } else { // Mute
                appStateJG.previousVolumeBeforeMute = appStateJG.volume; // Save current volume
                setVolumeJG(0);
            }
        }

        function updateVolumeIconsJG() {
            if (elementsJG.volumeIconMute && elementsJG.volumeIconUp) {
                const isEffectivelyMuted = appStateJG.volume === 0 || appStateJG.isMuted;
                elementsJG.volumeIconMute.style.opacity = isEffectivelyMuted ? '1' : '0.5';
                elementsJG.volumeIconMute.classList.toggle('text-jg-accent-sunburst', isEffectivelyMuted); // Highlight if muted

                elementsJG.volumeIconUp.style.opacity = !isEffectivelyMuted ? '1' : '0.5';
                elementsJG.volumeIconUp.classList.remove('text-jg-accent-sunburst'); // Ensure up icon isn't highlighted when mute is active
            }
        }
        // NEW_CODE_END

        // ==========================================================================
        // History, Favorites, Queue
        // ==========================================================================
        function addToHistoryJG(song) {
            if (!song || !song.id) return;
            appStateJG.history = appStateJG.history.filter(s => s.id !== song.id); 
            appStateJG.history.unshift(song); 
            if (appStateJG.history.length > MAX_HISTORY_JG) appStateJG.history.pop(); 
            saveToLocalStorageJG(LS_KEYS_JG.HISTORY, appStateJG.history);
        }

        function renderHistoryListJG() {
            if (elementsJG.historyPanel) {
                 renderSongListJG(elementsJG.historyPanel, appStateJG.history, 'history');
            }
        }

        function toggleFavoriteJG(songId, iconElement, buttonElement) {
            const songIndexInFavorites = appStateJG.favorites.findIndex(s => s.id === songId);
            const song = findSongByIdJG(songId); 
            if (!song) {
                console.warn("Cannot favorite: song not found in main list with ID", songId);
                showSnackbarJG("お気に入り操作エラー: 曲が見つかりません。", "error");
                return;
            }

            let isNowFavorite = false;
            if (songIndexInFavorites > -1) { 
                appStateJG.favorites.splice(songIndexInFavorites, 1);
                showSnackbarJG(`「${escapeHTMLJG(song.title)}」をジャングルの秘宝から外した...`);
            } else { 
                appStateJG.favorites.push(song); 
                isNowFavorite = true;
                showSnackbarJG(`「${escapeHTMLJG(song.title)}」を秘宝として発見！`, "success");
            }
            
            saveToLocalStorageJG(LS_KEYS_JG.FAVORITES, appStateJG.favorites);

            // Update the clicked button immediately
            if (iconElement) iconElement.className = `fas ${isNowFavorite ? 'fa-heart text-jg-accent-sunburst' : 'fa-feather-alt'}`;
            if (buttonElement) buttonElement.setAttribute('aria-label', isNowFavorite ? 'お気に入りから削除' : 'お気に入りに追加');

            // Re-render if currently viewing favorites panel
            if (appStateJG.currentPanel === 'log-trophies' && elementsJG.favoritesPanel) {
                 renderSongListJG(elementsJG.favoritesPanel, appStateJG.favorites, 'favorites');
            }
            // Update all other instances of this song's favorite button in other lists
             document.querySelectorAll(`.log-entry-jg[data-id="${songId}"] .favorite-action-jg`).forEach(btn => {
                const i = btn.querySelector('i');
                if (i && i !== iconElement) { // Don't re-update the one we just changed
                    i.className = `fas ${isNowFavorite ? 'fa-heart text-jg-accent-sunburst' : 'fa-feather-alt'}`;
                }
                if (btn !== buttonElement) {
                    btn.setAttribute('aria-label', isNowFavorite ? 'お気に入りから削除' : 'お気に入りに追加');
                }
            });
        }
        
        function addToQueueJG(songId) {
            const song = findSongByIdJG(songId);
            if (!song) {
                showSnackbarJG("曲が見つかりません。", "error");
                return;
            }
            appStateJG.queue.push(songId); // Add ID to queue
            saveToLocalStorageJG(LS_KEYS_JG.QUEUE, appStateJG.queue);
            updateQueueCountBadgeJG();
            showSnackbarJG(`「${escapeHTMLJG(song.title)}」をキューに追加しました。`, "success");

            if (appStateJG.currentPanel === 'log-discoveries' && elementsJG.queuePanel) {
                // Re-render queue panel with full song objects
                renderSongListJG(elementsJG.queuePanel, appStateJG.queue.map(id => findSongByIdJG(id)).filter(s => s), 'queue');
            }
            updateLogActionButtonsJG('log-discoveries'); 
        }

        function updateQueueCountBadgeJG() {
            if (elementsJG.queueCountBadge) {
                elementsJG.queueCountBadge.textContent = appStateJG.queue.length;
                elementsJG.queueCountBadge.style.display = appStateJG.queue.length > 0 ? 'inline-block' : 'none';
            }
        }
        // ==========================================================================
        // Playlist Management Functions
        // ==========================================================================
        function generateUniqueIdJG() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }

        function showCreatePlaylistModalJG() {
            const modal = document.getElementById('createPlaylistModalJG');
            const input = document.getElementById('newPlaylistNameJG');
            if (!modal || !input) return;

            input.value = ''; 
            modal.style.display = 'flex';
            appStateJG.activeModalId = 'createPlaylistModalJG'; 
            input.focus();

            const confirmButton = document.getElementById('confirmCreatePlaylistJG');
            const cancelButton = document.getElementById('cancelCreatePlaylistJG');
            
            // Use named functions for event handlers to remove them properly
            const handleConfirm = () => {
                const playlistName = input.value.trim();
                if (playlistName) {
                    createPlaylistJG(playlistName);
                    hideCreatePlaylistModalJG(); // This will also cleanup listeners
                } else {
                    showSnackbarJG("プレイリスト名を入力してください。", "warning");
                    input.focus();
                }
            };

            const handleCancel = () => {
                hideCreatePlaylistModalJG(); // This will also cleanup listeners
            };
            
            const handleKeydown = (e) => {
                if (e.key === 'Enter') handleConfirm();
                else if (e.key === 'Escape') handleCancel();
            };
            
            const handleBackdropClick = (e) => {
                if (e.target === modal) handleCancel();
            };

            // Store handlers on elements to remove them in hide function
            confirmButton._handleConfirm = handleConfirm;
            cancelButton._handleCancel = handleCancel;
            input._handleKeydown = handleKeydown;
            modal._handleBackdropClick = handleBackdropClick;

            confirmButton.addEventListener('click', handleConfirm);
            cancelButton.addEventListener('click', handleCancel);
            input.addEventListener('keydown', handleKeydown); 
            modal.addEventListener('click', handleBackdropClick);
        }

        function hideCreatePlaylistModalJG() {
            const modal = document.getElementById('createPlaylistModalJG');
            if (!modal) return;
            modal.style.display = 'none';
            appStateJG.activeModalId = null;

            // Cleanup listeners
            const confirmButton = document.getElementById('confirmCreatePlaylistJG');
            const cancelButton = document.getElementById('cancelCreatePlaylistJG');
            const input = document.getElementById('newPlaylistNameJG');

            if (confirmButton && confirmButton._handleConfirm) confirmButton.removeEventListener('click', confirmButton._handleConfirm);
            if (cancelButton && cancelButton._handleCancel) cancelButton.removeEventListener('click', cancelButton._handleCancel);
            if (input && input._handleKeydown) input.removeEventListener('keydown', input._handleKeydown);
            if (modal._handleBackdropClick) modal.removeEventListener('click', modal._handleBackdropClick);
        }

        function createPlaylistJG(name) {
            const newPlaylist = {
                id: generateUniqueIdJG(),
                name: name,
                songs: [] // Array of song IDs
            };
            appStateJG.userPlaylists.push(newPlaylist);
            saveToLocalStorageJG(LS_KEYS_JG.PLAYLISTS, appStateJG.userPlaylists);
            showSnackbarJG(`プレイリスト「${escapeHTMLJG(name)}」を作成しました！`, "success");

            if (appStateJG.currentPanel === 'log-paths' && elementsJG.playlistsPanel) {
                renderPlaylistsJG();
            }
        }
        
        function renderPlaylistsJG() {
            if (!elementsJG.playlistsPanel) return;
            elementsJG.playlistsPanel.innerHTML = ''; 
            appStateJG.currentViewingPlaylistId = null; // Ensure we are viewing the list of playlists

            if (appStateJG.userPlaylists.length === 0) {
                showEmptyMessageInPanelJG(elementsJG.playlistsPanel, "まだ道は描かれていない", "「新しい道」ボタンからプレイリストを作成しましょう！");
                updateLogActionButtonsJG('log-paths'); 
                return;
            }

            const fragment = document.createDocumentFragment();
            appStateJG.userPlaylists.forEach(playlist => {
                const playlistEntry = document.createElement('div');
                playlistEntry.className = 'log-entry-jg playlist-item-jg'; // Keep styling consistent
                playlistEntry.dataset.playlistId = playlist.id;
                playlistEntry.innerHTML = `
                    <i class="fas fa-compact-disc fa-lg mr-3 text-jg-accent-waterfall" style="width: 40px; text-align: center; flex-shrink:0;"></i>
                    <div>
                        <span class="title">${escapeHTMLJG(playlist.name)}</span>
                        <span class="artist">${playlist.songs.length} 曲</span>
                    </div>
                    <div class="log-entry-actions-jg">
                        <button class="song-item-action-jg rename-playlist-action-jg" title="名前を変更" aria-label="名前を変更">
                            <i class="fas fa-pencil-alt"></i>
                        </button>
                        <button class="song-item-action-jg delete-playlist-action-jg" title="削除" aria-label="削除">
                            <i class="fas fa-trash-alt"></i>
                        </button>
                    </div>
                `;
                
                playlistEntry.addEventListener('click', (e) => {
                    if (e.target.closest('.song-item-action-jg')) return; 
                    // appStateJG.currentViewingPlaylistId = playlist.id; // Set when rendering songs
                    renderSongsInPlaylistJG(playlist.id);
                });

                const renameBtn = playlistEntry.querySelector('.rename-playlist-action-jg');
                renameBtn?.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    // TODO: Implement rename playlist functionality
                    const newName = prompt(`プレイリスト「${escapeHTMLJG(playlist.name)}」の新しい名前を入力してください:`, playlist.name);
                    if (newName && newName.trim() !== "" && newName.trim() !== playlist.name) {
                        renamePlaylistJG(playlist.id, newName.trim());
                    } else if (newName !== null) { // Not cancelled, but empty or same
                        showSnackbarJG("プレイリスト名は変更されませんでした。", "info");
                    }
                });
                
                const deleteBtn = playlistEntry.querySelector('.delete-playlist-action-jg');
                deleteBtn?.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    confirmDeletePlaylistJG(playlist.id, playlist.name);
                });

                fragment.appendChild(playlistEntry);
            });
            elementsJG.playlistsPanel.appendChild(fragment);
            updateLogActionButtonsJG('log-paths'); 
        }

        // NEW_CODE_START: Rename Playlist
        function renamePlaylistJG(playlistId, newName) {
            const playlist = appStateJG.userPlaylists.find(p => p.id === playlistId);
            if (playlist) {
                const oldName = playlist.name;
                playlist.name = newName;
                saveToLocalStorageJG(LS_KEYS_JG.PLAYLISTS, appStateJG.userPlaylists);
                showSnackbarJG(`プレイリスト「${escapeHTMLJG(oldName)}」を「${escapeHTMLJG(newName)}」に改名しました。`, "success");
                if (appStateJG.currentPanel === 'log-paths') {
                    if (appStateJG.currentViewingPlaylistId === playlistId) {
                        // If viewing this playlist, update its header
                        const headerTitle = elementsJG.playlistsPanel?.querySelector('h4.font-display-jg');
                        if (headerTitle) headerTitle.textContent = escapeHTMLJG(newName);
                    } else {
                        renderPlaylistsJG(); // Re-render list of playlists
                    }
                }
            } else {
                showSnackbarJG("プレイリストの改名に失敗しました。", "error");
            }
        }
        // NEW_CODE_END


        function confirmDeletePlaylistJG(playlistId, playlistName) {
            if (confirm(`プレイリスト「${escapeHTMLJG(playlistName)}」を本当に削除しますか？この操作は元に戻せません。`)) {
                deletePlaylistJG(playlistId);
            }
        }

        function deletePlaylistJG(playlistId) {
            appStateJG.userPlaylists = appStateJG.userPlaylists.filter(p => p.id !== playlistId);
            saveToLocalStorageJG(LS_KEYS_JG.PLAYLISTS, appStateJG.userPlaylists);
            showSnackbarJG("プレイリストを削除しました。", "info");
            // If the deleted playlist was being viewed or played, reset relevant state
            if (appStateJG.currentViewingPlaylistId === playlistId) {
                appStateJG.currentViewingPlaylistId = null;
            }
            if (appStateJG.currentPlayingPlaylistId === playlistId) {
                appStateJG.currentPlayingPlaylistId = null;
                appStateJG.playMode = 'library'; // Fallback
                appStateJG.currentQueueIndex = -1;
            }

            if (appStateJG.currentPanel === 'log-paths' && elementsJG.playlistsPanel) {
                renderPlaylistsJG(); 
            }
        }
        
        let currentSongIdForPlaylistAddition = null; 

        function showAddToPlaylistModalJG(songId) {
            const modal = document.getElementById('addToPlaylistModalJG');
            const playlistListDiv = document.getElementById('addToPlaylistListJG');
            const songTitleDisplay = document.getElementById('addToPlaylistSongTitleJG');
            if (!modal || !playlistListDiv || !songTitleDisplay) return;

            currentSongIdForPlaylistAddition = songId;
            const song = findSongByIdJG(songId);
            if (song) {
                songTitleDisplay.textContent = `曲: ${escapeHTMLJG(song.title)}`;
            } else {
                songTitleDisplay.textContent = '曲を選択中...';
            }

            playlistListDiv.innerHTML = ''; 

            if (appStateJG.userPlaylists.length === 0) {
                playlistListDiv.innerHTML = `<p class="p-4 text-center text-jg-text-shadow">作成済みのプレイリストがありません。「新しい道」ボタンから作成してください。</p>`;
            } else {
                const listFragment = document.createDocumentFragment();
                appStateJG.userPlaylists.forEach(playlist => {
                    const item = document.createElement('div');
                    item.className = 'playlist-select-item-jg';
                    item.textContent = escapeHTMLJG(playlist.name) + ` (${playlist.songs.length} 曲)`;
                    item.dataset.playlistId = playlist.id;
                    item.addEventListener('click', () => {
                        addSongToPlaylistJG(currentSongIdForPlaylistAddition, playlist.id);
                        hideAddToPlaylistModalJG();
                    });
                    listFragment.appendChild(item);
                });
                playlistListDiv.appendChild(listFragment);
            }

            modal.style.display = 'flex';
            appStateJG.activeModalId = 'addToPlaylistModalJG';

            const cancelButton = document.getElementById('cancelAddToPlaylistJG');
            
            const handleCancel = () => hideAddToPlaylistModalJG();
            const handleBackdropClick = (e) => { if (e.target === modal) handleCancel(); };
            
            modal._handleBackdropClick = handleBackdropClick;
            cancelButton._handleCancel = handleCancel;

            cancelButton.addEventListener('click', handleCancel);
            modal.addEventListener('click', handleBackdropClick); 
        }

        function hideAddToPlaylistModalJG() {
            const modal = document.getElementById('addToPlaylistModalJG');
            if (modal) {
                modal.style.display = 'none';
                const cancelButton = document.getElementById('cancelAddToPlaylistJG');
                if (cancelButton && cancelButton._handleCancel) {
                    cancelButton.removeEventListener('click', cancelButton._handleCancel);
                    delete cancelButton._handleCancel;
                }
                if (modal._handleBackdropClick) {
                    modal.removeEventListener('click', modal._handleBackdropClick);
                    delete modal._handleBackdropClick;
                }
            }
            appStateJG.activeModalId = null;
            currentSongIdForPlaylistAddition = null;
        }

        function addSongToPlaylistJG(songId, playlistId) {
            if (!songId || !playlistId) return;

            const playlist = appStateJG.userPlaylists.find(p => p.id === playlistId);
            const song = findSongByIdJG(songId); 

            if (!playlist || !song) {
                showSnackbarJG("プレイリストまたは曲が見つかりません。", "error");
                return;
            }

            if (playlist.songs.includes(songId)) {
                showSnackbarJG(`「${escapeHTMLJG(song.title)}」は既にプレイリスト「${escapeHTMLJG(playlist.name)}」にあります。`, "info");
                return;
            }

            playlist.songs.push(songId);
            saveToLocalStorageJG(LS_KEYS_JG.PLAYLISTS, appStateJG.userPlaylists);
            showSnackbarJG(`「${escapeHTMLJG(song.title)}」をプレイリスト「${escapeHTMLJG(playlist.name)}」に追加しました。`, "success");

            if (appStateJG.currentPanel === 'log-paths' && elementsJG.playlistsPanel) {
                if (appStateJG.currentViewingPlaylistId === playlistId) {
                    renderSongsInPlaylistJG(playlistId); 
                } else {
                    // If viewing the main playlist list, update the count on the specific playlist item
                    const playlistItem = elementsJG.playlistsPanel.querySelector(`.playlist-item-jg[data-playlist-id="${playlistId}"] .artist`);
                    if (playlistItem) playlistItem.textContent = `${playlist.songs.length} 曲`;
                }
            }
        }

        function confirmRemoveSongFromPlaylistJG(songId, playlistId, songTitle) {
            const playlist = appStateJG.userPlaylists.find(p => p.id === playlistId);
            if (!playlist) return;
            const escapedSongTitle = escapeHTMLJG(songTitle) || "この曲";
            const escapedPlaylistName = escapeHTMLJG(playlist.name) || "このプレイリスト";

            if (confirm(`曲「${escapedSongTitle}」をプレイリスト「${escapedPlaylistName}」から削除しますか？`)) {
                removeSongFromPlaylistJG(songId, playlistId);
            }
        }

        function removeSongFromPlaylistJG(songId, playlistId) {
            const playlist = appStateJG.userPlaylists.find(p => p.id === playlistId);
            if (!playlist) {
                showSnackbarJG("プレイリストが見つかりません。", "error");
                return;
            }
            const songIndexInPlaylist = playlist.songs.indexOf(songId);
            if (songIndexInPlaylist > -1) {
                playlist.songs.splice(songIndexInPlaylist, 1);
                saveToLocalStorageJG(LS_KEYS_JG.PLAYLISTS, appStateJG.userPlaylists);
                showSnackbarJG("曲をプレイリストから削除しました。", "success");

                if (appStateJG.currentPanel === 'log-paths' && appStateJG.currentViewingPlaylistId === playlistId) {
                    renderSongsInPlaylistJG(playlistId); 
                }
            } else {
                showSnackbarJG("曲がプレイリストに見つかりませんでした。", "info");
            }
        }
        
        function renderSongsInPlaylistJG(playlistId) {
            if (!elementsJG.playlistsPanel) return;
            appStateJG.currentViewingPlaylistId = playlistId; 

            const playlist = appStateJG.userPlaylists.find(p => p.id === playlistId);
            if (!playlist) {
                showEmptyMessageInPanelJG(elementsJG.playlistsPanel, "プレイリストが見つかりません", "エラーが発生しました。道の一覧に戻ってください。");
                 // Add a back button even if playlist not found, to allow navigation
                elementsJG.playlistsPanel.innerHTML = `
                    <div class="flex items-center justify-between mb-3 px-1">
                        <h4 class="font-display-jg text-xl text-jg-text-earth">プレイリストエラー</h4>
                        <button id="backToPlaylistsViewErrorJG" class="px-3 py-1 rounded bg-jg-surface-leaf hover:bg-jg-accent-canopy text-sm transition-colors">
                            <i class="fas fa-arrow-left mr-1"></i> 道の一覧へ
                        </button>
                    </div>
                    <div class="text-center p-4 text-jg-text-shadow">指定されたプレイリストが見つかりませんでした。</div>
                `;
                document.getElementById('backToPlaylistsViewErrorJG')?.addEventListener('click', () => {
                    appStateJG.currentViewingPlaylistId = null; 
                    renderPlaylistsJG(); 
                    updateLogActionButtonsJG('log-paths'); 
                });
                updateLogActionButtonsJG('log-paths');
                return;
            }

            elementsJG.playlistsPanel.innerHTML = ''; 

            const headerDiv = document.createElement('div');
            headerDiv.className = 'flex items-center justify-between mb-3 px-1';
            headerDiv.innerHTML = `
                <div>
                    <h4 class="font-display-jg text-xl text-jg-text-earth">${escapeHTMLJG(playlist.name)}</h4>
                    <p class="text-sm text-jg-text-shadow">${playlist.songs.length} 曲</p>
                </div>
                <button id="backToPlaylistsViewJG" class="px-3 py-1 rounded bg-jg-surface-leaf hover:bg-jg-accent-canopy text-sm transition-colors">
                    <i class="fas fa-arrow-left mr-1"></i> 道の一覧へ
                </button>
            `;
            elementsJG.playlistsPanel.appendChild(headerDiv);
            
            document.getElementById('backToPlaylistsViewJG').addEventListener('click', () => {
                appStateJG.currentViewingPlaylistId = null; 
                renderPlaylistsJG(); 
                // updateLogActionButtonsJG will be called by renderPlaylistsJG
            });

            const songListContainer = document.createElement('div');
            songListContainer.className = 'playlist-songs-container-jg'; 
            elementsJG.playlistsPanel.appendChild(songListContainer);

            const songsInPlaylist = playlist.songs.map(songId => findSongByIdJG(songId)).filter(s => s); 
            
            if (songsInPlaylist.length === 0) {
                 showEmptyMessageInPanelJG(songListContainer, "この道はまだ静かだ...", "曲を追加して、冒険のサウンドトラックを始めよう！");
            } else {
                renderSongListJG(songListContainer, songsInPlaylist, 'playlistSongs');
            }
            updateLogActionButtonsJG('log-paths'); // Context is 'playlistSongs' now
        }

        // NEW_CODE_START: Drag and Drop Handlers
        function handleDragStartJG(event, songId, originalListIndex, context) {
            if (!event.target.classList.contains('log-entry-jg')) return;

            draggedItemJG = event.target;
            draggedItemOriginalIndexJG = originalListIndex; // Index in the specific list (queue or playlist.songs)
            currentDragContextJG = context;

            event.dataTransfer.setData('text/plain', songId);
            event.dataTransfer.effectAllowed = 'move';
            draggedItemJG.classList.add('dragging-jg');
            draggedItemJG.style.cursor = 'grabbing';

            // Create placeholder immediately for better UX (optional)
            // if (!dragOverPlaceholderJG) {
            //     dragOverPlaceholderJG = document.createElement('div');
            //     dragOverPlaceholderJG.className = 'drag-over-placeholder-jg';
            // }
        }

        function handleDragOverJG(event) {
            event.preventDefault(); // Necessary to allow dropping
            event.dataTransfer.dropEffect = 'move';

            if (!draggedItemJG) return;

            const targetItem = event.target.closest('.log-entry-jg');
            const container = draggedItemJG.parentElement; // The list container

            if (!dragOverPlaceholderJG) {
                dragOverPlaceholderJG = document.createElement('div');
                dragOverPlaceholderJG.className = 'drag-over-placeholder-jg';
            }

            if (targetItem && targetItem !== draggedItemJG) {
                const rect = targetItem.getBoundingClientRect();
                const isAfter = event.clientY > rect.top + rect.height / 2;
                if (isAfter) {
                    container.insertBefore(dragOverPlaceholderJG, targetItem.nextSibling);
                } else {
                    container.insertBefore(dragOverPlaceholderJG, targetItem);
                }
            } else if (!targetItem && container.contains(draggedItemJG)) { // Dragging over empty space in container
                 // Check if dragging to the end of the list
                const lastChild = container.lastElementChild;
                if(lastChild && lastChild !== dragOverPlaceholderJG && lastChild !== draggedItemJG) {
                    // Heuristic: if near bottom of container, append placeholder
                     if (event.clientY > lastChild.getBoundingClientRect().bottom - 10) {
                        container.appendChild(dragOverPlaceholderJG);
                     }
                } else if (!lastChild || lastChild === draggedItemJG) { // Empty list or only dragging item present
                    container.appendChild(dragOverPlaceholderJG);
                }
            }
        }
        
        function handleDragLeaveJG(event) {
            // If leaving the container itself or a child that's not a valid drop target temporarily.
            // More robust placeholder removal is in dragend and drop.
            if (dragOverPlaceholderJG && dragOverPlaceholderJG.parentElement && !event.currentTarget.contains(event.relatedTarget)) {
                 // dragOverPlaceholderJG.remove(); // This can be flickering. Better to manage in drop/end.
            }
        }


        function handleDropJG(event, panelElement, context) {
            event.preventDefault();
            if (!draggedItemJG || currentDragContextJG !== context) {
                cleanupDragStateJG();
                return;
            }

            const draggedSongId = event.dataTransfer.getData('text/plain');
            let listToUpdate;
            
            if (context === 'queue') {
                listToUpdate = appStateJG.queue;
            } else if (context === 'playlistSongs' && appStateJG.currentViewingPlaylistId) {
                const playlist = appStateJG.userPlaylists.find(p => p.id === appStateJG.currentViewingPlaylistId);
                if (playlist) {
                    listToUpdate = playlist.songs;
                } else {
                    console.error("Playlist not found for drop:", appStateJG.currentViewingPlaylistId);
                    cleanupDragStateJG();
                    return;
                }
            } else {
                cleanupDragStateJG();
                return;
            }

            const oldIndex = listToUpdate.indexOf(draggedSongId);
            if (oldIndex === -1) { // Song was somehow not in the list (should not happen if drag started correctly)
                console.warn("Dragged song ID not found in list:", draggedSongId, listToUpdate);
                cleanupDragStateJG();
                return;
            }

            // Determine new index based on placeholder position
            let newIndex = -1;
            if (dragOverPlaceholderJG && dragOverPlaceholderJG.parentElement) {
                const children = Array.from(dragOverPlaceholderJG.parentElement.children);
                newIndex = children.indexOf(dragOverPlaceholderJG);
                 // Adjust if placeholder was after the dragged item originally
                if (newIndex > oldIndex && children.indexOf(draggedItemJG) < newIndex) {
                    // No adjustment needed if newIndex already accounts for removed item
                } else if (newIndex <= oldIndex && children.indexOf(draggedItemJG) > newIndex) {
                    // If placeholder is before, and item was after it, newIndex is fine.
                }
            } else { // Fallback: drop on item or end of list
                const droppedOnItem = event.target.closest('.log-entry-jg');
                if (droppedOnItem && droppedOnItem !== draggedItemJG) {
                    const droppedOnId = droppedOnItem.dataset.id;
                    newIndex = listToUpdate.indexOf(droppedOnId);
                    const rect = droppedOnItem.getBoundingClientRect();
                    if (event.clientY > rect.top + rect.height / 2) {
                        newIndex++; // Insert after
                    }
                } else { // Dropped in empty space, assume end of list
                    newIndex = listToUpdate.length;
                }
            }
            
            if (newIndex === -1) { // Could not determine drop position
                cleanupDragStateJG();
                return;
            }

            // Perform array update
            const [movedSongId] = listToUpdate.splice(oldIndex, 1);
            // If newIndex was calculated before splice and oldIndex was smaller, newIndex might need adjustment.
            // The placeholder logic above should be more robust.
            // For splice, if newIndex was after oldIndex, it needs to be decremented.
            if (newIndex > oldIndex) newIndex--; 
            listToUpdate.splice(Math.max(0, Math.min(newIndex, listToUpdate.length)), 0, movedSongId);


            // Save and re-render
            if (context === 'queue') {
                appStateJG.queue = listToUpdate;
                saveToLocalStorageJG(LS_KEYS_JG.QUEUE, appStateJG.queue);
                renderSongListJG(panelElement, appStateJG.queue.map(id => findSongByIdJG(id)).filter(s => s), 'queue');
                // If current playing song was in queue, update its currentQueueIndex
                if (appStateJG.playMode === 'queue' && appStateJG.currentSongIndex !== -1) {
                    const currentPlayingSongId = appStateJG.songs[appStateJG.currentSongIndex].id;
                    appStateJG.currentQueueIndex = appStateJG.queue.indexOf(currentPlayingSongId);
                }
            } else if (context === 'playlistSongs') {
                // Playlist songs already updated in listToUpdate
                saveToLocalStorageJG(LS_KEYS_JG.PLAYLISTS, appStateJG.userPlaylists);
                renderSongsInPlaylistJG(appStateJG.currentViewingPlaylistId);
                 // If current playing song was in this playlist, update its currentQueueIndex (list index)
                if (appStateJG.playMode === 'playlist' && appStateJG.currentPlayingPlaylistId === appStateJG.currentViewingPlaylistId && appStateJG.currentSongIndex !== -1) {
                    const currentPlayingSongId = appStateJG.songs[appStateJG.currentSongIndex].id;
                    const playlist = appStateJG.userPlaylists.find(p => p.id === appStateJG.currentPlayingPlaylistId);
                    if(playlist) appStateJG.currentQueueIndex = playlist.songs.indexOf(currentPlayingSongId);
                }
            }
            cleanupDragStateJG();
        }

        function handleDragEndJG(event) {
            if (draggedItemJG) {
                draggedItemJG.classList.remove('dragging-jg');
                draggedItemJG.style.cursor = 'grab'; // Reset cursor
            }
            cleanupDragStateJG();
        }

        function cleanupDragStateJG() {
            if (dragOverPlaceholderJG && dragOverPlaceholderJG.parentElement) {
                dragOverPlaceholderJG.remove();
            }
            dragOverPlaceholderJG = null;
            draggedItemJG = null;
            draggedItemOriginalIndexJG = -1;
            currentDragContextJG = null;
        }
        // NEW_CODE_END

        // ==========================================================================
        // Utility Functions
        // ==========================================================================
        function findSongByIdJG(songId) { 
            if (!songId || !appStateJG.songs) return null;
            return appStateJG.songs.find(s => s && s.id === songId);
        }

        function formatTimeJG(seconds) {
            if (isNaN(seconds) || seconds < 0) return '0:00';
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        function escapeHTMLJG(str) {
            if (typeof str !== 'string' || !str) return '';
            const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
            return str.replace(/[&<>"']/g, function(m) { return map[m]; });
        }

        function saveToLocalStorageJG(key, data) {
            try {
                localStorage.setItem(key, JSON.stringify(data));
            } catch (e) {
                console.error("Error saving to localStorage:", key, e);
                showSnackbarJG("設定の保存に失敗しました...", "error");
            }
        }

        function loadFromLocalStorageJG(key) {
            try {
                const data = localStorage.getItem(key);
                return data ? JSON.parse(data) : null;
            } catch (e) {
                console.error("Error loading from localStorage:", key, e);
                return null;
            }
        }

        function showSnackbarJG(message, type = 'info', duration = 3000) {
            const snackbarId = 'snackbar-jg-dynamic';
            let snackbar = document.getElementById(snackbarId);
            if (!snackbar) {
                snackbar = document.createElement('div');
                snackbar.id = snackbarId;
                Object.assign(snackbar.style, {
                    position: 'fixed', bottom: '20px', left: '50%',
                    transform: 'translateX(-50%) translateY(100px)', 
                    padding: '12px 25px', color: '#ecf0f1', borderRadius: '8px',
                    boxShadow: '0 4px 15px rgba(0,0,0,0.3)', zIndex: '10001', 
                    opacity: '0', transition: 'opacity 0.3s ease, transform 0.3s ease-out',
                    fontSize: '0.9rem', fontFamily: 'var(--font-body-jg, sans-serif)', 
                    textAlign: 'center', minWidth: '280px', maxWidth: '90%'
                });
                document.body.appendChild(snackbar);
            }

            snackbar.textContent = message;
            let bgColor = '#34495e'; 
            if (type === 'error') bgColor = '#c0392b'; 
            if (type === 'success') bgColor = '#27ae60'; 
            if (type === 'warning') bgColor = '#f39c12'; 
            snackbar.style.backgroundColor = bgColor;

            requestAnimationFrame(() => {
                snackbar.style.opacity = '1';
                snackbar.style.transform = 'translateX(-50%) translateY(0)';
            });

            if (appStateJG.snackbarTimeoutId) clearTimeout(appStateJG.snackbarTimeoutId);
            appStateJG.snackbarTimeoutId = setTimeout(() => {
                snackbar.style.opacity = '0';
                snackbar.style.transform = 'translateX(-50%) translateY(100px)';
            }, duration);
        }

        // NEW_CODE_START: Keyboard Shortcuts Handler
        function handleGlobalKeydownJG(event) {
            // Ignore if typing in an input, textarea, or contenteditable element
            const targetTagName = event.target.tagName.toLowerCase();
            if (targetTagName === 'input' || targetTagName === 'textarea' || event.target.isContentEditable) {
                // Allow specific keys even in inputs if needed (e.g. Escape for modals)
                if (event.key === 'Escape' && appStateJG.activeModalId) {
                    if (appStateJG.activeModalId === 'createPlaylistModalJG') hideCreatePlaylistModalJG();
                    else if (appStateJG.activeModalId === 'addToPlaylistModalJG') hideAddToPlaylistModalJG();
                }
                return;
            }
            
            let preventDefault = true; // Default to prevent browser's default action

            switch (event.key) {
                case ' ': // Spacebar
                    togglePlayPauseJG();
                    break;
                case 'm': // M key
                case 'M':
                    toggleMuteJG();
                    break;
                case 'ArrowRight':
                    if (appStateJG.player && appStateJG.isPlayerReady && appStateJG.player.getCurrentTime) {
                        appStateJG.player.seekTo(appStateJG.player.getCurrentTime() + SEEK_STEP_JG, true);
                        updateProgressJG();
                    }
                    break;
                case 'ArrowLeft':
                    if (appStateJG.player && appStateJG.isPlayerReady && appStateJG.player.getCurrentTime) {
                        appStateJG.player.seekTo(Math.max(0, appStateJG.player.getCurrentTime() - SEEK_STEP_JG), true);
                        updateProgressJG();
                    }
                    break;
                case 'ArrowUp':
                    setVolumeJG(appStateJG.volume + VOLUME_STEP_JG);
                    break;
                case 'ArrowDown':
                    setVolumeJG(appStateJG.volume - VOLUME_STEP_JG);
                    break;
                case 'n': // N key
                case 'N':
                    playNextJG();
                    break;
                case 'p': // P key (for Previous)
                case 'P':
                case 'b': // B key (for Back) - common alternative
                case 'B':
                    playPrevJG();
                    break;
                case 's': // S key
                case 'S':
                    toggleShuffleJG();
                    break;
                case 'l': // L key
                case 'L':
                    toggleLoopJG();
                    break;
                case 'Escape':
                    if (appStateJG.activeModalId) {
                        if (appStateJG.activeModalId === 'createPlaylistModalJG') hideCreatePlaylistModalJG();
                        else if (appStateJG.activeModalId === 'addToPlaylistModalJG') hideAddToPlaylistModalJG();
                    } else {
                        preventDefault = false; // Allow default escape behavior if no modal
                    }
                    break;
                default:
                    preventDefault = false; // Don't prevent default for other keys
                    break;
            }
            if (preventDefault) {
                event.preventDefault();
            }
        }
        // NEW_CODE_END

        // ==========================================================================
        // Initialization on DOM Load
        // ==========================================================================
        function loadInitialDataJG(isSongDataReload = false) {
            console.log("loadInitialDataJG - START: isSongDataReload:", isSongDataReload);
            
            // Load non-song-dependent data only once initially
            if (!isSongDataReload) {
                appStateJG.currentTheme = loadFromLocalStorageJG(LS_KEYS_JG.THEME) || 'dark';
                // NEW_CODE_START: Load volume from localStorage
                const storedVolume = loadFromLocalStorageJG(LS_KEYS_JG.VOLUME);
                if (storedVolume !== null) {
                    appStateJG.volume = parseInt(storedVolume, 10);
                    appStateJG.isMuted = (appStateJG.volume === 0);
                    // If muted, previousVolumeBeforeMute should ideally also be stored/retrieved
                    // For now, if loaded volume is 0, assume it was intentionally set to 0, not muted from a higher vol.
                    appStateJG.previousVolumeBeforeMute = appStateJG.volume > 0 ? appStateJG.volume : 75; 
                }
                // NEW_CODE_END

                // Apply theme (before elementsJG might be fully populated if called too early, ensure it's safe)
                if (elementsJG.body && elementsJG.themeToggle) {
                    if (appStateJG.currentTheme === 'light') {
                        elementsJG.body.classList.add('light-mode-jg');
                        elementsJG.themeToggle.innerHTML = `<i class="fas fa-moon"></i>`;
                    } else {
                        elementsJG.body.classList.remove('light-mode-jg'); 
                        elementsJG.themeToggle.innerHTML = `<i class="fas fa-sun"></i>`;
                    }
                }
                // Apply volume to UI
                if(elementsJG.volumeSlider) elementsJG.volumeSlider.value = appStateJG.volume;
                updateVolumeIconsJG(); // NEW_CODE
            }

            // Load song-dependent data (history, favorites, queue, playlists with songs)
            // This part might run on initial load (after songs potentially loaded) or if songs are reloaded
            appStateJG.history = (loadFromLocalStorageJG(LS_KEYS_JG.HISTORY) || []).map(histSong => findSongByIdJG(histSong.id) || histSong).filter(s => s.id);
            appStateJG.favorites = (loadFromLocalStorageJG(LS_KEYS_JG.FAVORITES) || []).map(favSong => findSongByIdJG(favSong.id) || favSong).filter(s => s.id);
            appStateJG.queue = (loadFromLocalStorageJG(LS_KEYS_JG.QUEUE) || []).filter(id => findSongByIdJG(id)); // Keep only valid song IDs
            appStateJG.userPlaylists = (loadFromLocalStorageJG(LS_KEYS_JG.PLAYLISTS) || []).map(p => ({
                ...p,
                songs: (p.songs || []).filter(id => findSongByIdJG(id)) // Filter songs within playlists too
            }));

            // Save back potentially cleaned lists
            saveToLocalStorageJG(LS_KEYS_JG.HISTORY, appStateJG.history);
            saveToLocalStorageJG(LS_KEYS_JG.FAVORITES, appStateJG.favorites);
            saveToLocalStorageJG(LS_KEYS_JG.QUEUE, appStateJG.queue);
            saveToLocalStorageJG(LS_KEYS_JG.PLAYLISTS, appStateJG.userPlaylists);

            // Re-render relevant panels if they are active or if it's a song data reload
            if (elementsJG.favoritesPanel && (appStateJG.currentPanel === 'log-trophies' || isSongDataReload)) {
                renderSongListJG(elementsJG.favoritesPanel, appStateJG.favorites, 'favorites');
            }
            if (elementsJG.historyPanel && (appStateJG.currentPanel === 'log-history' || isSongDataReload)) {
                renderHistoryListJG();
            }
            if (elementsJG.queuePanel && (appStateJG.currentPanel === 'log-discoveries' || isSongDataReload)) {
                renderSongListJG(elementsJG.queuePanel, appStateJG.queue.map(id => findSongByIdJG(id)).filter(s => s), 'queue');
            }
            if (elementsJG.playlistsPanel && (appStateJG.currentPanel === 'log-paths' || isSongDataReload)) {
                if (appStateJG.currentViewingPlaylistId) {
                    renderSongsInPlaylistJG(appStateJG.currentViewingPlaylistId);
                } else {
                    renderPlaylistsJG();
                }
            }
            
            updateQueueCountBadgeJG();
            console.log("loadInitialDataJG - END.");
        }


        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded - START. Initializing Jungle Groove...");
            initializeElementsJG();    
            loadInitialDataJG(false);  // Load theme, volume, and lists (will be filtered if songs not yet loaded)
            setupEventListenersJG();   
            
            updatePlayerUIGJ(null); // Initialize player UI (also calls updateDocumentTitleJG)
            if (elementsJG.btnShuffle) elementsJG.btnShuffle.classList.toggle('active-control', appStateJG.isShuffle);
            if (elementsJG.btnLoop) {
                elementsJG.btnLoop.classList.toggle('active-control', appStateJG.loopMode !== 'none');
                 let loopIndicator = elementsJG.btnLoop.querySelector('.loop-indicator-jg');
                 if (appStateJG.loopMode === 'one') {
                    if (!loopIndicator) {
                         loopIndicator = document.createElement('span');
                         loopIndicator.className = 'loop-indicator-jg';
                         elementsJG.btnLoop.appendChild(loopIndicator);
                    }
                    loopIndicator.textContent = '1';
                } else {
                     if (loopIndicator) loopIndicator.remove();
                }
            }

            // Initial state of search clear button
            if (elementsJG.searchInput && elementsJG.clearSearchButton) {
                elementsJG.clearSearchButton.style.display = elementsJG.searchInput.value ? 'inline-block' : 'none';
            }
            
            // Initial panel display and action buttons
            // switchLogPanelJG will render the content and update action buttons
            switchLogPanelJG(appStateJG.currentPanel || 'log-library'); 

            // If songs haven't loaded yet (e.g. API key issue or player not ready), library might be empty or show loading.
            // loadInitialSongsJG is called from onPlayerReadyJG.
            if (appStateJG.songs.length === 0 && appStateJG.currentPanel === 'log-library' && elementsJG.libraryPanel && !youtubeAPI_JG.apiKey) { 
                 // showLoadingInPanelJG(elementsJG.libraryPanel, true); // This will be handled by loadInitialSongs if API key is bad
            }

            console.log("DOMContentLoaded - END. UI initialized. Waiting for YouTube API to call onYouTubeIframeAPIReady to load songs and player.");
        });
    </script>
</body>
</html>
