<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" >
  <title>Rei Kikuchi Premium Music Player</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-color: #8e24aa;
      --secondary-color: #5e35b1;
      --accent-color: #d81b60;
      --text-color: #333;
      --background-color: #f5f5f5;
      --card-color: #fff;
      --border-color: #e0e0e0;
      --vh: 1vh; /* モバイルのビューポート高さ補正用 */
    }

    .dark {
      --primary-color: #bb86fc;
      --secondary-color: #7c4dff;
      --accent-color: #cf6679;
      --text-color: #e0e0e0;
      --background-color: #121212;
      --card-color: #1e1e1e;
      --border-color: #333;
    }

    /* オフラインモード用のスタイル */
    .offline-mode .online-only {
      opacity: 0.5;
      pointer-events: none;
    }

    #offline-status {
      z-index: 9999;
    }

    .offline-badge {
      position: absolute;
      top: 0;
      right: 0;
      background-color: var(--accent-color);
      color: white;
      font-size: 0.6rem;
      padding: 2px 4px;
      border-radius: 4px;
      transform: translate(50%, -50%);
    }

    body {
      font-family: 'Poppins', sans-serif;
      transition: background-color 0.3s ease, color 0.3s ease;
      background-color: var(--background-color);
      color: var(--text-color);
      display: flex; /* Flexboxでレイアウト */
      flex-direction: column;
      /* min-height: 100vh; -> height: 100% に変更 */
      height: calc(var(--vh, 1vh) * 100); /* モバイルでの高さ問題を修正 */
    }

    /* UI/UX改善用のスタイル追加 */
    .song-item {
      transition: transform 0.2s ease, background-color 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .song-item:hover {
      transform: translateY(-2px);
      background-color: rgba(142, 36, 170, 0.05);
    }

    .song-item::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 0;
      height: 2px;
      background-color: var(--primary-color);
      transition: width 0.3s ease;
    }

    .song-item:hover::after {
      width: 100%;
    }

    .song-item.active {
      background-color: rgba(142, 36, 170, 0.1);
      border-left: 3px solid var(--primary-color);
    }

    .btn-mode, .btn-control {
      transition: transform 0.2s ease, opacity 0.2s ease;
    }

    .btn-mode:hover, .btn-control:hover {
      transform: scale(1.1);
    }

    .btn-mode:active, .btn-control:active {
      transform: scale(0.95);
    }

    .tab-button {
      position: relative;
      overflow: hidden;
    }

    .tab-button::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      width: 0;
      height: 2px;
      background-color: var(--primary-color);
      transition: width 0.3s ease, left 0.3s ease;
    }

    .tab-button:hover::after {
      width: 100%;
      left: 0;
    }

    .tab-button.active::after {
      width: 100%;
      left: 0;
    }

    /* スマホ向け最適化 */
    @media (max-width: 640px) {
      .song-controls {
        flex-direction: column;
        gap: 0.5rem;
      }

      .player-controls {
        flex-wrap: wrap;
        justify-content: center;
      }

      .volume-control {
        width: 100%;
        margin-top: 0.5rem;
      }

      .song-item {
        padding: 0.75rem;
      }

      .song-title {
        font-size: 0.9rem;
      }

      .song-duration {
        font-size: 0.8rem;
      }

          /* === Interaction Enhancements === */

    /* --- General Button Transitions --- */
    .btn-mode, .btn-control, .tab-button,
    .focusable, /* Apply smooth focus outline */
    #create-playlist-btn, #save-playlist-btn,
    #login-btn, #show-register-btn, #register-btn, #show-login-btn,
    #sync-data-btn, #logout-btn,
    #share-btn, #open-youtube-btn, #youtube-sync-btn, /* Sync btn added by JS */
    .share-option, #copy-link-btn,
    #remove-from-playlist-btn, #share-playlist-btn,
    .playlist-edit-btn, .playlist-delete-btn,
    /* Add Now Playing Bar buttons */
    #btn-prev-bar, #btn-play-bar, #btn-next-bar
    {
      transition: all 0.2s ease-in-out; /* Smooth transitions for various properties */
    }

    /* --- Button Hover & Active States --- */
    .btn-mode:hover, .btn-control:hover,
    #create-playlist-btn:hover, #save-playlist-btn:hover,
    #login-btn:hover, #show-register-btn:hover, #register-btn:hover, #show-login-btn:hover,
    #sync-data-btn:hover, #logout-btn:hover,
    #share-btn:not(:disabled):hover, #open-youtube-btn:not(:disabled):hover, #youtube-sync-btn:hover,
    .share-option:hover, #copy-link-btn:hover,
    #remove-from-playlist-btn:hover, #share-playlist-btn:hover,
    .playlist-edit-btn:hover, .playlist-delete-btn:hover,
    #btn-prev-bar:hover, #btn-play-bar:hover, #btn-next-bar:hover
     {
      transform: scale(1.08); /* Slightly enlarge on hover */
      opacity: 0.9; /* Optional: slight transparency */
    }

    .btn-mode:active, .btn-control:active,
    #create-playlist-btn:active, #save-playlist-btn:active,
    #login-btn:active, #show-register-btn:active, #register-btn:active, #show-login-btn:active,
    #sync-data-btn:active, #logout-btn:active,
    #share-btn:not(:disabled):active, #open-youtube-btn:not(:disabled):active, #youtube-sync-btn:active,
    .share-option:active, #copy-link-btn:active,
    #remove-from-playlist-btn:active, #share-playlist-btn:active,
     .playlist-edit-btn:active, .playlist-delete-btn:active,
     #btn-prev-bar:active, #btn-play-bar:active, #btn-next-bar:active
     {
      transform: scale(0.95); /* Slightly shrink on active/click */
      opacity: 1;
    }

    /* --- List Item Transitions & Hover --- */
    .playlist-item, .history-item, .favorite-item, .user-playlist-item {
      transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out, border-color 0.2s ease-in-out;
      border-left-width: 3px; /* Ensure space for border */
      border-left-color: transparent; /* Start transparent */
    }

    .playlist-item:hover, .history-item:hover, .favorite-item:hover, .user-playlist-item:hover {
      background-color: rgba(142, 36, 170, 0.08); /* Slightly darker hover */
      transform: translateY(-2px); /* Lift effect */
      /* border-left-color: var(--primary-color); */ /* Optional: Show border on hover */
    }
     .dark .playlist-item:hover, .dark .history-item:hover, .dark .favorite-item:hover, .dark .user-playlist-item:hover {
       background-color: rgba(187, 134, 252, 0.1); /* Dark mode hover */
     }

    .playlist-item.active, .history-item.active, .favorite-item.active {
       border-left-color: var(--primary-color);
       background-color: rgba(142, 36, 170, 0.15); /* Slightly darker active */
       transform: translateY(0); /* Reset transform for active item */
    }
    .dark .playlist-item.active, .dark .history-item.active, .dark .favorite-item.active {
        background-color: rgba(187, 134, 252, 0.2); /* Dark mode active */
     }


    /* --- Tab Button Hover --- */
    .tab-button { /* Assuming tabs have .tab-button class or just use .tab */
      position: relative;
      transition: color 0.2s ease-in-out, border-color 0.2s ease-in-out;
      border-bottom: 2px solid transparent;
    }
     /* Add hover color change */
     .tab:hover:not(.active) { /* Apply hover effect only to non-active tabs */
        color: var(--primary-color);
        opacity: 0.8;
     }

    /* --- Favorite Button Animation --- */
    @keyframes favoritePulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }

    .favorite-btn.pulsing i {
      animation: favoritePulse 0.3s ease-in-out forwards;
    }
    /* Ensure the heart icon itself transitions color smoothly */
    .favorite-btn i {
        transition: color 0.2s ease-in-out;
    }

    /* === End Interaction Enhancements === */
      /* タッチ操作の最適化 */
      .btn-mode, .btn-control, .tab-button, .song-item, .heart-btn {
        min-height: 44px; /* タッチターゲットの最小サイズ */
      }

      /* スマホでのスクロールを滑らかに */
      .playlist-container {
        -webkit-overflow-scrolling: touch;
      }
    }

    /* アニメーション効果 */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .fade-in {
      animation: fadeIn 0.5s ease forwards;
    }

    .slide-up {
      animation: slideUp 0.5s ease forwards;
    }

    .pulse {
      animation: pulse 1s infinite;
    }

    /* プレイヤーコントロールの改善 */
    .player-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      margin: 1rem 0;
    }

    .progress-container {
      position: relative;
      height: 6px;
      background-color: var(--border-color);
      border-radius: 3px;
      cursor: pointer;
      overflow: hidden;
      /* トラックの高さを増やし、色を調整 */
      background-color: rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s ease;
      /* タップ領域を明確にするために上下パディングを追加 */
      padding: 8px 0;
      margin: -8px 0;
    }

    .progress-bar {
      height: 100%;
      background-color: var(--primary-color);
      border-radius: 3px;
      transition: width 0.1s linear;
      /* 再生済み部分の色を濃く・鮮やかに */
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
      width: 0%;
      position: relative;
    }

    .progress-thumb {
      position: absolute;
      top: 50%;
      width: 12px;
      height: 12px;
      background-color: var(--primary-color);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
      transition: transform 0.2s ease;
    }

    .progress-container:hover .progress-thumb {
      transform: translate(-50%, -50%) scale(1.2);
    }

    /* ローディングインジケーター */
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid rgba(142, 36, 170, 0.3);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* スナックバーの改善 */
    .snackbar {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: var(--card-color);
      color: var(--text-color);
      padding: 12px 24px;
      border-radius: 4px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
      z-index: 1001; /* Increased z-index */
      font-size: 0.9rem;
      opacity: 0;
      transition: opacity 0.3s ease-out, transform 0.3s ease-out, bottom 0.3s ease-out; /* Added bottom transition */
      border-left: 4px solid var(--primary-color);
      pointer-events: none; /* Prevents interaction when hidden */
      text-align: center;
      max-width: 90%;
      /* Ensure it's above mobile bottom controls */
      margin-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px); /* Adjust for safe area + margin */
    }

    .snackbar.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
      bottom: 20px; /* Base position */
      pointer-events: auto; /* Allow interaction when shown */
    }

    /* モーダルの改善 */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
      padding: 15px; /* Add padding for mobile view */
    }

    .modal.show {
      opacity: 1;
      display: flex;
    }

    .modal-content {
      background-color: var(--card-color);
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      max-width: 90%;
      max-height: 90%; /* Adjusted from 85vh to 90% for flexibility */
      overflow: auto; /* Changed from overflow-y to auto */
      transform: scale(0.9);
      transition: transform 0.3s ease, background-color 0.3s ease; /* Added background transition */
      width: 100%; /* Use padding on modal for spacing */
      padding: 20px; /* Standard padding */
      position: relative; /* Needed for absolute positioned close button */
      -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
    }

    .modal.show .modal-content {
      transform: scale(1);
    }

    /* スクロールバーのカスタマイズ */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--background-color);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--primary-color);
    }

    /* フォーカス状態の改善 */
    button:focus, input:focus, a:focus, [tabindex]:focus { /* Applied to more focusable elements */
      outline: 2px solid var(--primary-color);
      outline-offset: 2px;
      box-shadow: 0 0 0 3px rgba(142, 36, 170, 0.3); /* Added subtle shadow for better visibility */
    }

    /* キーボードナビゲーション用 (merged with button:focus style) */
    .focusable:focus { /* Use a class for explicit focusable items if needed */
        outline: 2px solid var(--primary-color);
        outline-offset: 2px;
        box-shadow: 0 0 0 3px rgba(142, 36, 170, 0.3);
    }


    /* アクセシビリティ改善 */
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .app-container {
      max-width: 1280px;
      margin: 0 auto;
      /* padding: 20px; -> スマホでは0に */
      width: 100%;
      flex-grow: 1; /* コンテンツエリアを伸ばす */
      display: flex;
      flex-direction: column;
    }

    .app-container > header {
        padding: 10px 15px; /* スマホ用のヘッダーパディング */
        flex-shrink: 0;
    }

    .music-player {
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      background-color: var(--card-color);
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
      flex-grow: 1; /* プレイヤー部分が残りの高さを取る */
      display: flex;
      flex-direction: column;
      padding: 0; /* スマホでは不要 */
    }
/* PCでのスタイルを維持 */
@media (min-width: 1024px) {
      .music-player {
         padding: 1.5rem; /* 24px */
      }
      .app-container > header {
          padding: 0 20px; /* PCでは元のpadding */
      }
    }


    /* Gridレイアウト (PC/Tablet) */
    .music-player-grid {
        display: grid;
        grid-template-columns: 1fr; /* Mobile default */
        gap: 1.5rem; /* 24px */
        flex-grow: 1;
        overflow: hidden; /* Prevent grid itself from scrolling */
    }

    @media (min-width: 1024px) { /* lg breakpoint */
        .music-player-grid {
            grid-template-columns: repeat(3, minmax(0, 1fr));
        }
        .player-main-column {
            grid-column: span 2 / span 2;
        }
        .playlist-column {
            grid-column: span 1 / span 1;
            display: flex;
            flex-direction: column;
        }
    }

    .playlist, .history-list, .favorites-list, .user-playlists-list, .playlist-detail-list {
      max-height: 400px; /* Default max height for desktop */
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--primary-color) var(--background-color);
      -webkit-overflow-scrolling: touch; /* iOSでのスムーズスクロール */
    }

    .playlist::-webkit-scrollbar,
    .history-list::-webkit-scrollbar,
    .favorites-list::-webkit-scrollbar,
    .user-playlists-list::-webkit-scrollbar,
    .playlist-detail-list::-webkit-scrollbar {
      width: 6px;
    }

    .playlist::-webkit-scrollbar-track,
    .history-list::-webkit-scrollbar-track,
    .favorites-list::-webkit-scrollbar-track,
    .user-playlists-list::-webkit-scrollbar-track,
    .playlist-detail-list::-webkit-scrollbar-track {
      background: var(--background-color);
    }

    .playlist::-webkit-scrollbar-thumb,
    .history-list::-webkit-scrollbar-thumb,
    .favorites-list::-webkit-scrollbar-thumb,
    .user-playlists-list::-webkit-scrollbar-thumb,
    .playlist-detail-list::-webkit-scrollbar-thumb {
      background-color: var(--primary-color);
      border-radius: 6px;
    }

    .playlist-item, .history-item, .favorite-item {
      transition: all 0.2s ease;
      border-left: 3px solid transparent;
    }

    .playlist-item:hover, .history-item:hover, .favorite-item:hover {
      background-color: rgba(142, 36, 170, 0.1);
    }

    .dark .playlist-item:hover, .dark .history-item:hover, .dark .favorite-item:hover {
       background-color: rgba(187, 134, 252, 0.1);
    }

    .playlist-item.active, .history-item.active, .favorite-item.active {
      border-left: 3px solid var(--primary-color);
      background-color: rgba(142, 36, 170, 0.2);
    }

     .dark .playlist-item.active, .dark .history-item.active, .dark .favorite-item.active {
       background-color: rgba(187, 134, 252, 0.2);
     }

    .player-controls button {
      transition: all 0.2s ease;
    }

    .player-controls button:hover {
      transform: scale(1.1);
    }

    /* Progress Bar Improved Styles */
    /* ホバー時のスタイル */
    .progress-container:hover {
        height: 8px; /* Slightly thicker on hover */
        background-color: rgba(0, 0, 0, 0.15);
    }
     /* つまみ */
     .progress-bar::after {
        content: '';
        position: absolute;
        right: 0;
        top: 50%;
        transform: translate(50%, -50%) scale(0); /* 初期状態は非表示 */
        width: 16px;
        height: 16px;
        background: white;
        border: 2px solid var(--primary-color);
        border-radius: 50%;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        transition: transform 0.2s ease;
        z-index: 2;
     }

     /* ホバー時やアクティブ時に表示 (PC) */
     .progress-container:hover .progress-bar::after,
     .progress-container:active .progress-bar::after {
        transform: translate(50%, -50%) scale(1);
     }

     /* Show thumb if progress is > 0 */
     .progress-bar:not([style*="width: 0%"])::after {
        transform: translate(50%, -50%) scale(1);
     }
     /* Fix for very small percentage values triggering the style rule */
     .progress-bar[style*="width: 0."]::after {
         transform: translate(50%, -50%) scale(1);
     }


     .dark .progress-container {
        background-color: rgba(255, 255, 255, 0.1);
     }

     .dark .progress-bar {
        box-shadow: 0 0 8px rgba(187, 134, 252, 0.3); /* Subtle glow in dark mode */
     }

     .dark .progress-bar::after {
        background: var(--background-color); /* Dark background for thumb */
        border-color: var(--primary-color);
     }

   /* 音量スライダーもタップしやすく */
   .volume-control input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 8px; /* 少し太く */
      background: var(--border-color);
      border-radius: 8px;
      outline: none;
      transition: background 0.3s ease;
      padding: 5px 0; /* 上下のタップ領域 */
      margin: -5px 0; /* パディング相殺 */
    }
     /* Style for the track */
    .volume-control input[type="range"]::-webkit-slider-runnable-track {
        height: 8px;
        background: var(--border-color);
        border-radius: 8px;
    }
    .volume-control input[type="range"]::-moz-range-track {
        height: 8px;
        background: var(--border-color);
        border-radius: 8px;
    }
     /* Style for the thumb */
    .volume-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px; /* 少し大きく */
      height: 18px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
      margin-top: -5px; /* Center thumb vertically */
       transition: background 0.3s ease;
    }
    .volume-control input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        background: var(--primary-color);
        border-radius: 50%;
        cursor: pointer;
        border: none;
         transition: background 0.3s ease;
    }


    .btn-mode {
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    .btn-active {
      color: white;
      background-color: var(--primary-color);
    }
     .dark .btn-active {
        color: var(--background-color); /* Ensure contrast in dark mode */
        background-color: var(--primary-color);
     }

    .btn-inactive {
      color: var(--text-color);
      background-color: var(--border-color);
    }

    .search-container {
      position: relative;
    }

    .search-input {
      padding-left: 40px;
      background-color: var(--card-color);
      border: 1px solid var(--border-color);
      color: var(--text-color);
       transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    .search-icon {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-color);
      transition: color 0.3s ease;
    }

    .tabs {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 16px;
      flex-wrap: wrap;
       transition: border-color 0.3s ease;
       flex-shrink: 0; /* タブ自体は縮まない */
    }

    .tab {
      padding: 10px 15px; /* 少し調整 */
      cursor: pointer;
      transition: all 0.3s ease;
      border-bottom: 2px solid transparent;
      text-align: center;
      flex-grow: 1; /* タブを均等配置 */
      font-size: 0.9rem;
    }
     @media (min-width: 640px) { /* PCでは元の設定に戻す */
         .tab {
             flex-grow: 0;
             padding: 10px 20px;
             font-size: 1rem;
         }
         .tabs {
             flex-wrap: nowrap;
         }
     }

     .tab.active {
      color: var(--primary-color);
      border-bottom: 2px solid var(--primary-color);
      font-weight: 600;
    }
    .tab-content {
       /* height: 100%; */ /* Will be handled by flex-grow on parent */
       overflow-y: auto;
       -webkit-overflow-scrolling: touch;
       flex-grow: 1; /* Make tab content take remaining space */
       /* Define a class for scrollable area *inside* tab content */
    }
    .scrollable-list-area {
        /* Default height for desktop/larger screens if needed */
        max-height: 400px;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
    }

    .visualizer-container {
      height: 60px; /* スマホでは少し小さく */
      background-color: rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      transition: background-color 0.3s ease;
    }
     @media (min-width: 1024px) {
         .visualizer-container {
            height: 100px; /* PCでは元の高さ */
         }
     }


    .dark .visualizer-container {
      background-color: rgba(255, 255, 255, 0.05);
    }

    canvas#visualizer { /* Specificity added */
      width: 100%;
      height: 100%;
      display: block; /* Remove potential extra space */
    }

    .youtube-container {
      position: relative;
      padding-bottom: 56.25%; /* 16:9 Aspect Ratio */
      height: 0;
      overflow: hidden;
      border-radius: 12px; /* Apply border radius */
      background-color: #000; /* Black background for loading */
      margin-bottom: 10px; /* Add some space below video */
    }

    .youtube-container iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .badge {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: var(--accent-color);
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.75rem;
      z-index: 10;
    }

    .modal-close-btn {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 1.8rem; /* Larger tap target */
      line-height: 1;
      background: none;
      border: none;
      cursor: pointer;
      color: var(--text-color);
      padding: 8px; /* Larger tap target */
      margin: -8px; /* Offset padding */
       transition: color 0.3s ease;
    }
     .modal-close-btn:hover {
         color: var(--accent-color);
     }

     /* Adjust snackbar position if bottom controls are visible */
     body.has-bottom-controls .snackbar {
        margin-bottom: calc(env(safe-area-inset-bottom, 0px) + 70px + 10px); /* Controls height + margin */
     }

    @media print {
      .scrollable-list-area {
        max-height: none;
        overflow: visible;
      }
    }


    /* Custom Playlist Styles */
    .user-playlist-item {
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background-color: rgba(142, 36, 170, 0.05);
      transition: background-color 0.2s ease;
    }

    .user-playlist-item:hover {
      background-color: rgba(142, 36, 170, 0.15);
    }
     .dark .user-playlist-item {
         background-color: rgba(187, 134, 252, 0.1);
     }
     .dark .user-playlist-item:hover {
         background-color: rgba(187, 134, 252, 0.2);
     }

    .user-playlist-actions {
      display: flex;
      gap: 10px;
    }
    .playlist-count {
      padding: 2px 8px;
      background-color: var(--primary-color);
      color: white;
      border-radius: 10px;
      font-size: 0.75rem;
      margin-left: 8px;
       transition: background-color 0.3s ease;
    }
     .dark .playlist-count {
         color: var(--background-color);
     }

     /* Dropdown Styling */
     .dropdown { /* Add styling to the dropdown container */
         position: relative;
         display: inline-block;
     }
     .dropdown-menu {
        background-color: var(--card-color);
        border: 1px solid var(--border-color);
        transition: background-color 0.3s ease, border-color 0.3s ease;
        position: absolute; /* Position relative to .dropdown */
        right: 0;
        margin-top: 0.5rem; /* 8px */
        width: 12rem; /* 192px */
        border-radius: 0.375rem; /* 6px */
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        z-index: 20; /* Ensure it's above list items */
        /* Add max-height and overflow for scrollable dropdown */
        max-height: 8rem; /* 128px or adjust as needed */
        overflow-y: auto;
    }
    .dropdown-menu a { /* Style links inside dropdown */
        display: block;
        padding: 0.5rem 1rem; /* 8px 16px */
        font-size: 0.875rem; /* 14px */
        white-space: nowrap; /* Prevent wrapping */
    }
    .dropdown-menu a:hover {
       background-color: rgba(142, 36, 170, 0.1);
    }
     .dark .dropdown-menu a:hover {
        background-color: rgba(187, 134, 252, 0.15);
     }


    /* --- Mobile Specific Adjustments --- */
    @media (max-width: 1023px) { /* Below lg breakpoint */
      .app-container {
         padding: 0;
      }
       .app-container > header {
           /* Mobile header layout */
           flex-direction: column;
           align-items: flex-start;
           gap: 10px;
       }
       .app-container > header .flex.items-center.gap-4 { /* Search + buttons */
           width: 100%;
           justify-content: space-between;
       }
       .app-container > header .search-container {
           flex-grow: 1;
           margin-right: 10px;
       }
       .app-container > header .search-input {
           width: 100%;
       }
       .app-container > header .text-2xl { /* Main title */
           font-size: 1.5rem; /* text-xl */
       }
        .app-container > header .text-sm { /* Subtitle */
            font-size: 0.8rem;
        }
        .app-container > header .fa-music {
             font-size: 2rem; /* text-3xl */
        }


       .music-player {
           border-radius: 0;
           box-shadow: none;
       }

       /* Hide desktop player controls section */
       .player-controls { display: none; }
       /* Also hide the desktop volume control if it's separate */
       #desktop-volume-control { display: none; }

        /* Ensure main column takes only necessary space */
       .player-main-column {
           padding: 10px 10px 0 10px; /* Padding around player elements */
           flex-shrink: 0; /* Prevent shrinking */
           display: flex;
           flex-direction: column;
       }
        /* Ensure playlist column takes remaining space and handles scrolling */
       .playlist-column {
           padding: 0 10px 0 10px; /* Horizontal padding */
           display: flex;
           flex-direction: column;
           flex-grow: 1; /* Take remaining vertical space */
           overflow: hidden; /* Prevent container itself from scrolling */
           /* Add padding at bottom for fixed controls */
           padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 70px + 10px); /* Controls height + safe area + margin */
       }

        .tabs {
            margin-bottom: 5px;
            flex-shrink: 0; /* Prevent tabs from shrinking */
        }
        /* Make tab content area scrollable */
        .tab-content {
            flex-grow: 1; /* Take available space within playlist-column */
            overflow-y: auto; /* Enable scrolling for the content */
             -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }
        /* Remove fixed max-height from lists on mobile, let flexbox handle height */
        .scrollable-list-area {
            max-height: none;
            height: auto; /* Allow content to determine height */
        }

       .scrollable-list-area::-webkit-scrollbar {
           display: none; /* Hide scrollbar on mobile WebKit */
       }
       .scrollable-list-area {
           scrollbar-width: none; /* Hide scrollbar on Firefox */
       }

       .playlist-item, .history-item, .favorite-item {
          padding: 10px 5px; /* Adjust padding */
       }
       .playlist-item h3, .history-item h3, .favorite-item h3 { font-size: 0.9rem; }
       .playlist-item p, .history-item p, .favorite-item p { font-size: 0.75rem; }
       .playlist-item .w-10, .history-item .w-10, .favorite-item .w-10 { width: 36px; height: 36px; }

       /* Progress bar touch */
       .progress-container {
           height: 8px; /* Taller track for easier touch */
           border-radius: 8px;
           padding-top: 12px; /* Larger touch area above */
           padding-bottom: 12px; /* Larger touch area below */
           margin-top: -12px; /* Offset padding */
           margin-bottom: 5px; /* Space below progress */
       }
       .progress-bar { border-radius: 8px; }
        /* Ensure thumb is always visible on mobile */
        .progress-bar::after {
            width: 18px;
            height: 18px;
            transform: translate(50%, -50%) scale(1); /* Always visible */
        }


       /* Time display */
       .time-display {
          display: flex;
          justify-content: space-between; /* This should place times at ends */
          margin-top: 8px; /* Space above time */
       }
        #current-time, #total-time {
            font-size: 0.85rem;
            font-family: 'Poppins', sans-serif; /* Ensure font consistency */
            font-weight: 500;
            color: var(--text-color);
            opacity: 0.8; /* Slightly faded */
        }


    } /* End mobile styles */


    /* Fixed Bottom Controls (Mobile Only) */
    #bottom-controls {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: var(--card-color);
        border-top: 1px solid var(--border-color);
        padding: 10px 15px;
        padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px); /* iOS Safe Area */
        display: flex; /* Changed from none to flex */
        align-items: center;
        justify-content: space-between;
        z-index: 500; /* Ensure above content, below modals */
        transition: background-color 0.3s ease, border-color 0.3s ease;
        height: calc(env(safe-area-inset-bottom, 0px) + 70px); /* Add safe area to height */
    }
    /* Adjust button sizes and touch targets */
    #bottom-controls button {
        padding: 5px;
        min-width: 44px; /* Ensure min touch target width */
        min-height: 44px; /* Ensure min touch target height */
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0; /* Prevent shrinking */
    }
    #bottom-controls #btn-play-mobile { width: 50px; height: 50px; font-size: 1.8rem; }
    #bottom-controls #btn-prev-mobile, #bottom-controls #btn-next-mobile { font-size: 1.6rem; }
    #bottom-controls #btn-shuffle-mobile, #bottom-controls #btn-loop-mobile { font-size: 1.2rem; width: 35px; height: 35px; }

    /* Control layout for mobile */
    #bottom-controls .controls-left { order: 1; display: flex; align-items: center; gap: 15px; }
    #bottom-controls .controls-center { order: 2; display: flex; align-items: center; gap: 25px; flex-grow: 1; justify-content: center; }
    #bottom-controls .controls-right { order: 3; /* Currently empty, could hold volume toggle */ }

    /* Hide bottom controls on larger screens */
    @media (min-width: 1024px) {
        #bottom-controls { display: none; }
    }

     /* --- Now Playing Bar Styles --- */
     #now-playing-bar {
      /* Add transition for smooth appearance */
      transition: transform 0.3s ease-out, background-color 0.3s ease, border-color 0.3s ease;
    }

    #now-playing-bar.active {
      /* Slide in from bottom when active */
      transform: translateY(0);
    }

    /* Adjust main content padding when bar is active to prevent overlap */
    body.has-now-playing-bar #app > footer {
        /* Adjust this value (e.g., 70px) based on the actual height of your now-playing-bar */
        padding-bottom: 70px;
    }
     /* Adjust mobile bottom controls position if now playing bar is also visible */
     /* Note: This scenario might need careful UX consideration */
     body.has-now-playing-bar.has-bottom-controls #bottom-controls {
         /* Adjust this value based on now-playing-bar height */
         bottom: 68px;
     }
     /* Adjust snackbar position when now playing bar is active */
      body.has-now-playing-bar .snackbar {
         /* Calculate position considering bar height and safe area */
         /* Adjust the '68px' if your bar height is different */
         bottom: calc(env(safe-area-inset-bottom, 0px) + 68px + 10px); /* Bar height + margin */
      }
      /* If mobile controls are *also* active, stack snackbar higher */
       body.has-now-playing-bar.has-bottom-controls .snackbar {
            /* Adjust '68px' (bar height) and '70px' (controls height) if needed */
           bottom: calc(env(safe-area-inset-bottom, 0px) + 68px + 70px + 10px); /* Bar height + Controls height + margin */
       }


    /* Custom styling for range input thumb (Tailwind JIT might handle this better now) */
    #volume-slider-bar::-webkit-slider-thumb {
        background: var(--primary-color);
    }
    #volume-slider-bar::-moz-range-thumb {
        background: var(--primary-color);
    }

    /* Make clickable area larger for info */
    #now-playing-bar-info {
        min-width: 0; /* Prevent flex item from overflowing */
    }

    /* === Skeleton Loading Styles === */
    .skeleton-item {
      background-color: var(--border-color); /* Use border color as base */
      border-radius: 4px;
      position: relative;
      overflow: hidden; /* Needed for pseudo-element animation */
      opacity: 0.7;
    }

    /* Shimmer Animation */
    .skeleton-item::after {
      content: '';
      position: absolute;
      top: 0;
      left: -150%; /* Start off-screen to the left */
      height: 100%;
      width: 150%; /* Wide gradient */
      background: linear-gradient(
        90deg,
        transparent,
        rgba(255, 255, 255, 0.2), /* Light shimmer for light mode */
        transparent
      );
       /* Adjust shimmer color for dark mode */
       .dark & {
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.1), /* Subtle shimmer for dark */
                transparent
            );
       }
      animation: shimmer 1.5s infinite linear;
    }

    @keyframes shimmer {
      0% {
        transform: translateX(0);
      }
      100% {
        transform: translateX(100%); /* Move across the element */
      }
    }

    /* Skeleton structure mirroring the playlist item */
    .skeleton-playlist-item {
      display: flex;
      align-items: center;
      padding: 0.75rem; /* Match playlist-item padding (p-3) */
      margin-bottom: 0.5rem; /* Space between items */
      background-color: var(--card-color); /* Match card background */
       border: 1px solid var(--border-color);
       border-radius: 6px;
    }

    .skeleton-thumb {
      width: 2.5rem;  /* Match w-10 */
      height: 2.5rem; /* Match h-10 */
      margin-right: 0.75rem; /* Match mr-3 */
      flex-shrink: 0;
    }

    .skeleton-text-container {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      gap: 0.5rem; /* Space between lines */
    }

    .skeleton-text {
      height: 0.75rem; /* Approx text height */
      width: 80%; /* Default width for text lines */
    }

    .skeleton-text-short {
      width: 50%; /* Shorter line */
    }
    /* === End Skeleton Loading Styles === */

    /* === Empty State Styles === */
    .empty-state-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 2rem 1rem; /* Add some padding */
      color: var(--text-color);
      opacity: 0.7; /* Slightly faded */
      height: 100%; /* Try to fill the container height */
      min-height: 200px; /* Ensure minimum height */
    }

    .empty-state-icon {
      font-size: 3rem; /* Larger icon */
      margin-bottom: 1rem;
      color: var(--primary-color); /* Use primary color for icon */
      opacity: 0.5;
    }

    .empty-state-title {
      font-weight: 600; /* Semi-bold title */
      margin-bottom: 0.5rem;
    }

    .empty-state-message {
      font-size: 0.9rem;
      margin-bottom: 1rem;
    }

    .empty-state-action button {
       /* Use existing button styles or define specific ones */
       /* Example: reusing primary button style */
       background-color: var(--primary-color);
       color: white;
       padding: 0.5rem 1rem;
       border-radius: 9999px; /* pill shape */
       transition: all 0.2s ease-in-out;
    }
     .empty-state-action button:hover {
         transform: scale(1.05);
         opacity: 0.9;
     }
    /* === End Empty State Styles === */

    /* === Context Menu Styles === */
    #context-menu {
      min-width: 180px; /* Minimum width */
      /* Add smooth transition for appearing/disappearing (optional) */
      /* transition: opacity 0.1s ease-out, transform 0.1s ease-out; */
      /* transform: scale(0.95); */
      /* opacity: 0; */
    }
    /* #context-menu.visible { */
      /* transform: scale(1); */
      /* opacity: 1; */
    /* } */

    .context-menu-item {
      display: flex; /* Use flex for icon alignment */
      align-items: center;
      white-space: nowrap; /* Prevent wrapping */
      color: var(--text-color);
      transition: background-color 0.15s ease-in-out;
    }
    .context-menu-item i {
      color: var(--primary-color); /* Or adjust color */
       opacity: 0.8;
       text-align: center; /* Ensure icon is centered in its space */
    }
     /* Style for separator */
     .context-menu-separator {
         border-top: 1px solid var(--border-color);
         margin: 4px 0; /* my-1 equivalent */
         height: 0;
     }

    /* === End Context Menu Styles === */
    /* === Queue List Styles === */
    .queue-item {
      /* Reuse playlist-item styles or create specific ones */
      /* Example: slightly different padding or background? */
      padding: 8px 10px; /* Adjust padding */
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      border-bottom: 1px solid var(--border-color); /* Separator */
      transition: background-color 0.2s ease-in-out;
    }
    .queue-item:last-child {
        border-bottom: none; /* No border for the last item */
    }

    .queue-item:hover {
      background-color: rgba(142, 36, 170, 0.08);
    }
    .dark .queue-item:hover {
      background-color: rgba(187, 134, 252, 0.1);
    }

    .queue-item.playing { /* Style for the currently playing item in the queue */
        background-color: rgba(142, 36, 170, 0.15);
        border-left: 3px solid var(--primary-color);
        padding-left: 7px; /* Adjust padding for border */
    }
    .dark .queue-item.playing {
         background-color: rgba(187, 134, 252, 0.2);
     }

    .queue-item-info {
        display: flex;
        align-items: center;
        overflow: hidden;
        flex-grow: 1;
        margin-right: 10px;
    }
    .queue-item-thumb {
        width: 32px; /* Smaller thumbnail */
        height: 32px;
        border-radius: 4px;
        margin-right: 10px;
        flex-shrink: 0;
        object-fit: cover;
    }
    .queue-item-title {
        font-size: 0.85rem;
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .queue-item-actions button {
        color: var(--text-color);
        opacity: 0.6;
        padding: 4px;
    }
     .queue-item-actions button:hover {
         opacity: 1;
         color: var(--primary-color);
     }

     /* Queue Count Badge */
     #queue-count-badge {
         display: inline-block; /* Ensure it shows when not hidden */
         vertical-align: middle;
         line-height: 1;
     }
    /* === End Queue List Styles === */
    /* === Queue List Styles === */
    .queue-list { /* Add this if you didn't have it */
       /* Inherits scrollable-list-area properties */
    }

    .queue-item {
      padding: 6px 10px; /* Slightly reduced padding */
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: grab; /* Indicate draggable */
      border-bottom: 1px solid var(--border-color); /* Separator */
      transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out, opacity 0.2s ease-in-out;
      user-select: none; /* Prevent text selection during drag */
      position: relative; /* For pseudo-elements */
    }
    .queue-item:last-child {
        border-bottom: none; /* No border for the last item */
    }

    .queue-item:hover {
      background-color: rgba(142, 36, 170, 0.08);
    }
    .dark .queue-item:hover {
      background-color: rgba(187, 134, 252, 0.1);
    }

    .queue-item.playing { /* Style for the currently playing item in the queue */
        background-color: rgba(142, 36, 170, 0.15);
        border-left: 3px solid var(--primary-color);
        padding-left: 7px; /* Adjust padding for border */
        font-weight: 600; /* Make playing item stand out */
    }
    .dark .queue-item.playing {
         background-color: rgba(187, 134, 252, 0.2);
     }

    .queue-item-info {
        display: flex;
        align-items: center;
        overflow: hidden;
        flex-grow: 1;
        margin-right: 10px;
        /* Make info area non-draggable trigger */
        cursor: default;
    }
    .queue-item-thumb {
        width: 32px; /* Smaller thumbnail */
        height: 32px;
        border-radius: 4px;
        margin-right: 10px;
        flex-shrink: 0;
        object-fit: cover;
        pointer-events: none; /* Prevent image dragging */
    }
    .queue-item-title {
        font-size: 0.85rem;
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        pointer-events: none; /* Prevent text dragging issues */
    }
    .queue-item-actions {
        display: flex;
        align-items: center;
        flex-shrink: 0;
    }
    .queue-item-actions button {
        color: var(--text-color);
        opacity: 0.6;
        padding: 4px;
        background: none;
        border: none;
        cursor: pointer;
        transition: opacity 0.2s, color 0.2s;
    }
     .queue-item-actions button:hover {
         opacity: 1;
         color: var(--primary-color);
     }
     /* Drag Handle (Optional but improves UX) */
     .queue-item-drag-handle {
        opacity: 0.4;
        margin-right: 8px;
        cursor: grab;
        touch-action: none; /* Prevent scrolling on touch drag */
     }
     .queue-item:hover .queue-item-drag-handle {
        opacity: 0.8;
     }

     /* Queue Count Badge */
     #queue-count-badge {
         display: inline-block; /* Ensure it shows when not hidden */
         vertical-align: middle;
         line-height: 1;
         font-weight: normal; /* Reset weight if tab text is bold */
     }
    /* === End Queue List Styles === */

    /* === Drag and Drop Styles === */
    .queue-item.dragging {
        opacity: 0.4;
        cursor: grabbing;
        background-color: rgba(142, 36, 170, 0.1);
    }
    .dark .queue-item.dragging {
        background-color: rgba(187, 134, 252, 0.15);
    }

    .queue-item.drag-over {
        /* Visual indicator where item will be dropped */
        border-top: 2px solid var(--primary-color);
        /* background-color: rgba(142, 36, 170, 0.05); */
    }
    /* === End Drag and Drop Styles === */

  </style>
</head>

<body class=""> <!-- Start with no 'has-bottom-controls' class -->
  <div class="app-container" id="app">
    <header class="flex flex-col md:flex-row justify-between items-center mb-6 gap-4">
      <div class="flex items-center">
        <i class="fas fa-music text-4xl mr-3" style="color: var(--primary-color)"></i>
        <h1 class="text-2xl md:text-3xl font-bold">Rei Kikuchi <span class="text-sm md:text-base font-normal">Premium Music Player</span></h1>
      </div>
      <div class="flex items-center gap-4 w-full md:w-auto"> <!-- Ensure buttons container adapts -->
        <div class="search-container flex-grow md:flex-grow-0"> <!-- Allow search to grow on mobile -->
          <i class="fas fa-search search-icon"></i>
          <input type="text" id="search-input" class="search-input px-4 py-2 rounded-full w-full md:w-64 focusable" placeholder="曲名を検索...">
        </div>
        <!-- Buttons Container -->
        <div class="flex items-center gap-2 flex-shrink-0"> <!-- Prevent buttons shrinking -->
            <button id="offline-menu-btn" class="btn-mode btn-inactive focusable hidden" aria-label="オフラインキャッシュ管理">
              <i class="fas fa-cloud-download-alt"></i>
            </button>
            <button id="theme-toggle" class="btn-mode btn-inactive focusable" aria-label="テーマ切り替え" aria-pressed="false">
              <i class="fas fa-moon"></i>
            </button>
            <button id="account-btn" class="btn-mode btn-inactive focusable" aria-label="アカウント">
              <i class="fas fa-user"></i>
            </button>
        </div>
      </div>
    </header>

    <!-- プロフィールセクション -->
    <div id="profile-section" class="bg-gradient-to-r from-purple-100 to-indigo-100 dark:from-purple-900 dark:to-indigo-900 rounded-lg p-4 mb-6 shadow-md transition-all duration-300 ease-in-out mx-2 md:mx-0"> <!-- Add horizontal margin for mobile -->
      <div class="flex flex-col md:flex-row items-center justify-between">
        <div class="flex items-center mb-4 md:mb-0">
          <div class="w-16 h-16 md:w-20 md:h-20 rounded-full overflow-hidden border-4 border-white dark:border-gray-800 shadow-lg mr-4 flex-shrink-0">
            <img src="rei_kikuchi_profile.jpg" alt="Rei Kikuchi" class="w-full h-full object-cover">
          </div>
          <div>
            <h2 class="text-xl md:text-2xl font-bold">Rei Kikuchi</h2>
            <p class="text-sm md:text-base opacity-75">音楽クリエイター / Riffusion アーティスト</p>
          </div>
        </div>
        <div class="flex flex-wrap gap-3 justify-center md:justify-end">
          <a href="https://www.youtube.com/channel/UCYAuSEKhuk3v4ZKzm5Lqb1Q" target="_blank" rel="noopener noreferrer" class="flex items-center px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-full transition-colors duration-200 shadow-md focusable">
            <i class="fab fa-youtube mr-2 text-lg"></i>
            <span>YouTube</span>
          </a>
          <a href="https://www.instagram.com/youtube_rei_kikuchi/" target="_blank" rel="noopener noreferrer" class="flex items-center px-4 py-2 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white rounded-full transition-colors duration-200 shadow-md focusable">
            <i class="fab fa-instagram mr-2 text-lg"></i>
            <span>Instagram</span>
          </a>
          <a href="https://www.riffusion.com/u/REI_KIKUCHI" target="_blank" rel="noopener noreferrer" class="flex items-center px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-full transition-colors duration-200 shadow-md focusable">
            <i class="fas fa-music mr-2 text-lg"></i>
            <span>Riffusion</span>
          </a>
        </div>
      </div>
    </div>

    <!-- Main Player Structure -->
    <div class="music-player flex-grow flex flex-col"> <!-- Use flex-grow and flex-col -->
        <div class="music-player-grid flex-grow"> <!-- Grid takes remaining space -->
            <!-- Player Section (Main Column) -->
            <div class="player-main-column flex flex-col"> <!-- Column layout for player parts -->
                <div class="youtube-container mb-4 flex-shrink-0"> <!-- Video player area -->
                    <div id="youtube-player"></div>
                    <span id="now-playing-badge" class="badge hidden">NOW PLAYING</span>
                </div>
                <div class="flex justify-end mb-2 gap-2 flex-shrink-0"> <!-- Buttons below video -->
                     <!-- youtube-sync-btn will be added by JS -->
                    <button id="share-btn" class="px-3 py-1 rounded-md text-sm disabled:opacity-50 focusable" style="background-color: var(--border-color);" disabled>
                        <i class="fas fa-share-alt mr-1"></i> 共有
                    </button>
                    <button id="open-youtube-btn" class="px-3 py-1 rounded-md text-sm disabled:opacity-50 focusable" style="background-color: var(--border-color);" disabled>
                        <i class="fab fa-youtube mr-1"></i> YouTubeで開く
                    </button>
                </div>
                <div class="visualizer-container mb-4 flex-shrink-0"> <!-- Visualizer -->
                    <canvas id="visualizer"></canvas>
                </div>
                <div class="player-info mb-4 flex-shrink-0"> <!-- Song Info -->
                    <h2 id="current-song-title" class="text-xl font-bold truncate">選択された曲はありません</h2>
                    <p id="current-song-duration" class="text-sm opacity-75">--:--</p>
                </div>
                <div class="progress-container mb-2 flex-shrink-0"> <!-- Progress Bar -->
                    <div class="progress-bar" id="progress-bar"></div>
                </div>
                <!-- Time Display (Correctly styled for space-between) -->
                <div class="time-display mb-4 flex-shrink-0">
                    <span id="current-time">00:00</span>
                    <span id="total-time">00:00</span>
                </div>
                <!-- Desktop Controls (Hidden on Mobile) -->
                <div class="player-controls flex items-center justify-between mb-6 flex-shrink-0">
                    <div class="flex items-center gap-4">
                    <button id="btn-shuffle" class="text-xl btn-inactive rounded-full w-10 h-10 flex items-center justify-center focusable" aria-label="シャッフル" aria-pressed="false">
                        <i class="fas fa-random"></i>
                    </button>
                    <button id="btn-loop" class="text-xl btn-inactive rounded-full w-10 h-10 flex items-center justify-center focusable" aria-label="リピート: オフ">
                        <i class="fas fa-repeat"></i>
                    </button>
                    </div>
                    <div class="flex items-center gap-4">
                    <button id="btn-prev" class="text-2xl focusable" aria-label="前の曲">
                        <i class="fas fa-step-backward"></i>
                    </button>
                    <button id="btn-play" class="text-4xl btn-active rounded-full w-16 h-16 flex items-center justify-center focusable" aria-label="再生">
                        <i class="fas fa-play"></i>
                    </button>
                    <button id="btn-next" class="text-2xl focusable" aria-label="次の曲">
                        <i class="fas fa-step-forward"></i>
                    </button>
                    </div>
                    <div id="desktop-volume-control" class="flex items-center gap-2">
                        <i class="fas fa-volume-up text-sm" aria-hidden="true"></i>
                        <div class="volume-control">
                            <input type="range" id="volume-slider" min="0" max="100" value="100" aria-label="音量調整" class="focusable">
                        </div>
                    </div>
                </div>
            </div>

                      
                       <!-- ========== Playlist Section (Sidebar Column) ========== -->
<div class="playlist-column flex flex-col"> <!-- Column layout for tabs and lists -->
  <div class="tabs flex-shrink-0">
      <div class="tab active focusable" data-tab="playlist" role="tab" aria-selected="true" tabindex="0">プレイリスト</div>
      <div class="tab focusable" data-tab="history" role="tab" aria-selected="false" tabindex="0">再生履歴</div>
      <div class="tab focusable" data-tab="favorites" role="tab" aria-selected="false" tabindex="0">お気に入り</div>
      <div class="tab focusable" data-tab="user-playlists" role="tab" aria-selected="false" tabindex="0">マイプレイリスト</div>
      <!-- ↓ Queue Tab: Add id to badge span -->
      <div class="tab focusable" data-tab="queue" role="tab" aria-selected="false" tabindex="0">
          再生キュー <span id="queue-count-badge" class="ml-1 px-1.5 py-0.5 rounded-full text-xs bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-200 hidden">0</span>
      </div>
  </div>

  <div id="playlist-tab" class="tab-content flex-grow" role="tabpanel">
      <div class="playlist scrollable-list-area" id="playlist">
          <!-- Playlist content -->
      </div>
  </div>

  <div id="history-tab" class="tab-content hidden flex-grow" role="tabpanel">
      <div class="history-list scrollable-list-area" id="history-list">
          <!-- History content -->
      </div>
  </div>

  <div id="favorites-tab" class="tab-content hidden flex-grow" role="tabpanel">
      <div class="favorites-list scrollable-list-area" id="favorites-list">
          <!-- Favorites content -->
      </div>
  </div>

  <div id="user-playlists-tab" class="tab-content hidden flex-grow" role="tabpanel">
    <!-- ↓↓↓ ここにプレイリストリストのコンテナを追加 ↓↓↓ -->
    <div class="user-playlists-list scrollable-list-area" id="user-playlists-list">
        <!-- JavaScriptがここにプレイリスト項目をレンダリングします -->
        <!-- または、初期状態としてローディング表示などを入れても良いです -->
        <p class="p-4 text-center text-gray-500">マイプレイリストを読み込み中...</p>
    </div>
    <!-- ↑↑↑ ここまでプレイリストリストのコンテナ ↑↑↑ -->
    <!-- (空状態メッセージはJavaScriptによってこの中に追加/削除されます) -->
</div>

  <!-- ↓↓↓ Queue Tab Content: Updated structure ↓↓↓ -->
  <div id="queue-tab" class="tab-content hidden flex-grow" role="tabpanel">
      <div class="flex justify-between items-center mb-3 px-1 pt-1">
           <h3 class="text-sm font-semibold">再生キュー</h3>
           <button id="clear-queue-btn" class="text-xs text-red-500 hover:text-red-700 dark:hover:text-red-400 focusable disabled:opacity-50 disabled:cursor-not-allowed" disabled>
               <i class="fas fa-trash mr-1"></i>すべてクリア
           </button>
      </div>
      <div class="queue-list scrollable-list-area" id="queue-list">
          <!-- Queue items will be rendered here by JS -->
           <div class="empty-state-container text-center py-8 text-gray-500 dark:text-gray-400">
               <i class="fas fa-list-ol empty-state-icon"></i>
               <h4 class="empty-state-title">キューは空です</h4>
               <p class="empty-state-message">曲を右クリックして「キューに追加」を選択するか、<br>曲を再生すると自動的にキューに追加されることがあります。</p>
           </div>
      </div>
  </div>
   <!-- ↑↑↑ End Queue Tab Content ↑↑↑ -->

</div> <!-- End playlist-column -->

    <div id="share-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="share-modal-title">
      <div class="modal-content">
        <div class="flex justify-between items-center mb-4">
          <h3 id="share-modal-title" class="text-lg font-bold">共有</h3>
          <button class="modal-close-btn close-modal-btn focusable" data-modal-id="share" aria-label="閉じる">×</button>
        </div>
        <p id="share-object-title" class="mb-4"></p>
        <div class="flex gap-4 mb-4">
          <button class="share-option flex-1 px-3 py-2 rounded text-white focusable" style="background-color: #1DA1F2;">
            <i class="fab fa-twitter mr-2"></i> Twitter
          </button>
          <button class="share-option flex-1 px-3 py-2 rounded text-white focusable" style="background-color: #4267B2;">
            <i class="fab fa-facebook-f mr-2"></i> Facebook
          </button>
        </div>
        <div class="mb-4">
          <label for="share-link-input" class="block text-sm mb-2">共有リンク</label>
          <div class="flex">
            <input type="text" id="share-link-input" class="flex-1 px-3 py-2 border rounded-l focusable" style="border-color: var(--border-color); background-color: var(--card-color);" readonly>
            <button id="copy-link-btn" class="px-3 py-2 rounded-r text-white focusable" style="background-color: var(--primary-color);">コピー</button>
          </div>
        </div>
      </div>
    </div>

  <!-- アカウントモーダル（アップグレード版） -->
    <div id="account-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="account-modal-title">
        <div class="modal-content">
            <!-- ヘッダー -->
            <div class="flex justify-between items-center mb-4">
                <h3 id="account-modal-title" class="text-lg font-bold text-gray-800 dark:text-gray-200">アカウント設定</h3>
                <button class="modal-close-btn close-modal-btn focusable" data-modal-id="account" aria-label="閉じる">×</button>
            </div>

            <!-- ログインセクション -->
            <div id="login-section">
                <div class="mb-4">
                    <label for="login-email" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">メールアドレス</label>
                    <input type="email" id="login-email" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
                </div>
                <div class="mb-4">
                    <label for="login-password" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">パスワード</label>
                    <input type="password" id="login-password" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
                </div>
                <div class="mb-4 flex space-x-2">
                    <button id="login-btn" class="px-4 py-2 rounded text-white focusable" style="background-color: var(--primary-color);">ログイン</button>
                    <button id="show-register-btn" class="px-4 py-2 rounded focusable" style="background-color: var(--border-color);">新規登録</button>
                </div>
            </div>

            <!-- 登録セクション -->
            <div id="register-section" class="hidden">
                <div class="mb-4">
                    <label for="register-name" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">ユーザー名</label>
                    <input type="text" id="register-name" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
                </div>
                <div class="mb-4">
                    <label for="register-email" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">メールアドレス</label>
                    <input type="email" id="register-email" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
                </div>
                <div class="mb-4">
                    <label for="register-password" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">パスワード</label>
                    <input type="password" id="register-password" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
                </div>
                <div class="mb-4 flex space-x-2">
                    <button id="register-btn" class="px-4 py-2 rounded text-white focusable" style="background-color: var(--primary-color);">登録</button>
                    <button id="show-login-btn" class="px-4 py-2 rounded focusable" style="background-color: var(--border-color);">ログインに戻る</button>
                </div>
            </div>

            <!-- アカウント情報セクション -->
            <div id="account-info-section" class="hidden">
                <div class="mb-4 text-center">
                    <div class="w-16 h-16 rounded-full bg-gray-300 dark:bg-gray-600 flex items-center justify-center mx-auto mb-2">
                    <i class="fas fa-user text-3xl text-gray-700 dark:text-gray-200"></i>
                    </div>
                    <h4 id="user-name" class="font-bold text-gray-800 dark:text-gray-200"></h4>
                    <p id="user-email" class="text-sm opacity-75 text-gray-700 dark:text-gray-300"></p>
                </div>
                <div class="mb-4 space-y-2">
                    <button id="sync-data-btn" class="w-full px-4 py-2 rounded focusable" style="background-color: var(--border-color);">
                    <i class="fas fa-sync mr-2"></i> データを同期
                    </button>
                    <button id="logout-btn" class="w-full px-4 py-2 rounded text-white focusable" style="background-color: var(--accent-color);">
                    <i class="fas fa-sign-out-alt mr-2"></i> ログアウト
                    </button>
                </div>
            </div>
        </div>
    </div>

<!-- ========== プレイリスト作成モーダル ========== -->
<div id="create-playlist-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="create-playlist-modal-title">
  <div class="modal-content">
    <div class="flex justify-between items-center mb-4">
      <h3 id="create-playlist-modal-title" class="text-lg font-bold">新しいプレイリストを作成</h3>
      <button class="modal-close-btn close-modal-btn focusable" data-modal-id="createPlaylist" aria-label="閉じる">×</button>
    </div>
    <div class="mb-4">
      <label for="playlist-name-input" class="block text-sm mb-2">プレイリスト名</label>
      <!-- ↓↓↓ 名前入力欄 (IDを確認) ↓↓↓ -->
      <input type="text" id="playlist-name-input" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);" placeholder="例: お気に入りチルソング">
    </div>
    <div class="flex justify-end">
      <!-- ↓↓↓ 保存ボタン (IDを確認) ↓↓↓ -->
      <button id="save-playlist-btn" class="px-4 py-2 rounded text-white focusable" style="background-color: var(--primary-color);">
        作成して保存
      </button>
    </div>
  </div>
</div>
<!-- ========== ここまでプレイリスト作成モーダル ========== -->

    <div id="playlist-detail-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="playlist-detail-modal-title">
       <div class="modal-content"> <!-- Removed max-h here, handled by list inside -->
         <div class="flex justify-between items-center mb-4">
           <h3 id="playlist-detail-title" class="text-lg font-bold">プレイリスト</h3>
           <button class="modal-close-btn close-modal-btn focusable" data-modal-id="playlistDetail" aria-label="閉じる">×</button>
         </div>
         <!-- Make the list scrollable, not the whole modal content -->
         <div id="playlist-detail-content" class="playlist-detail-list scrollable-list-area max-h-[60vh]"> <!-- Added scrollable class and max-height -->
           <p class="text-center py-8 text-gray-500">プレイリストを読み込み中...</p>
         </div>
         <div class="flex gap-2 mt-4">
           <button id="remove-from-playlist-btn" class="px-3 py-1 rounded text-sm hidden focusable" style="background-color: var(--accent-color); color: white;">
             <i class="fas fa-minus mr-1"></i> 選択を削除
           </button>
           <button id="share-playlist-btn" class="px-3 py-1 rounded text-sm ml-auto focusable" style="background-color: var(--primary-color); color: white;">
             <i class="fas fa-share-alt mr-1"></i> 共有
           </button>
         </div>
       </div>
     </div>

     <!-- Offline Modal (Dynamically created in JS, but placeholder structure) -->
     <div id="offline-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="offline-modal-title">
        <!-- Content added by JS in offlinePlayback.addOfflineUI -->
        <div class="modal-content">
            <!-- JS will populate this -->
        </div>
     </div>


    <div id="snackbar" class="snackbar"></div>

    <footer class="mt-8 text-center text-sm opacity-75 pb-4 md:pb-0"> <!-- Add padding bottom on mobile -->
      <p>© 2025 Rei Kikuchi Music Player | このプレイヤーはRei Kikuchiによって作られました</p>
    </footer>
  </div> <!-- End #app -->
 <!-- =========== Now Playing Bar (Mini Player) =========== -->
 <div id="now-playing-bar" class="fixed bottom-0 left-0 right-0 bg-white dark:bg-gray-800 shadow-lg border-t border-gray-200 dark:border-gray-700 z-[450] transition-transform duration-300 ease-out translate-y-full">
    <div class="max-w-screen-xl mx-auto px-4 py-2 flex items-center gap-4">
      <!-- Song Info -->
      <div class="flex items-center gap-3 flex-grow overflow-hidden cursor-pointer" id="now-playing-bar-info">
        <img id="now-playing-bar-thumb" src="" alt="Album Art" class="w-10 h-10 rounded object-cover bg-gray-300 dark:bg-gray-600 flex-shrink-0">
        <div class="overflow-hidden">
          <div id="now-playing-bar-title" class="text-sm font-medium truncate text-gray-900 dark:text-gray-100">曲が選択されていません</div>
          <div id="now-playing-bar-artist" class="text-xs text-gray-500 dark:text-gray-400 truncate">Rei Kikuchi</div>
        </div>
      </div>

      <!-- Desktop/Tablet Controls -->
      <div class="hidden md:flex items-center gap-4 flex-shrink-0">
         <button id="btn-prev-bar" class="text-gray-700 dark:text-gray-300 hover:text-primary-color dark:hover:text-primary-color focusable transition-colors" aria-label="前の曲">
           <i class="fas fa-step-backward text-lg"></i>
         </button>
         <button id="btn-play-bar" class="text-gray-700 dark:text-gray-300 hover:text-primary-color dark:hover:text-primary-color w-10 h-10 flex items-center justify-center rounded-full bg-gray-100 dark:bg-gray-700 focusable transition-colors" aria-label="再生">
           <i class="fas fa-play text-xl"></i>
         </button>
         <button id="btn-next-bar" class="text-gray-700 dark:text-gray-300 hover:text-primary-color dark:hover:text-primary-color focusable transition-colors" aria-label="次の曲">
           <i class="fas fa-step-forward text-lg"></i>
         </button>
      </div>

        <!-- Progress (Optional but nice) -->
       <div class="hidden lg:block w-40 flex-shrink-0 relative pt-1">
            <div id="now-playing-bar-progress-container" class="h-1 bg-gray-300 dark:bg-gray-600 rounded-full overflow-hidden cursor-pointer">
                <div id="now-playing-bar-progress" class="h-full bg-primary-color rounded-full" style="width: 0%;"></div>
            </div>
       </div>

       <!-- Volume (Optional, Desktop only maybe) -->
       <div class="hidden lg:flex items-center gap-2 flex-shrink-0">
            <i id="now-playing-bar-volume-icon" class="fas fa-volume-up text-sm text-gray-500 dark:text-gray-400" aria-hidden="true"></i>
            <input type="range" id="volume-slider-bar" min="0" max="100" value="100" aria-label="音量調整" class="w-20 h-1 bg-gray-300 dark:bg-gray-600 rounded-full appearance-none cursor-pointer focusable [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:h-3 [&::-webkit-slider-thumb]:w-3 [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:bg-primary-color">
        </div>

       <!-- Expand/Queue Button (Future) -->
       <!-- <button class="text-gray-600 dark:text-gray-400"><i class="fas fa-chevron-up"></i></button> -->
    </div>
  </div>
  <!-- =========== End Now Playing Bar =========== -->
  <!-- Fixed Bottom Controls (Mobile Only) -->
  <div id="bottom-controls" class="hidden"> <!-- Start hidden, shown by JS if needed -->
      <div class="controls-left">
          <button id="btn-shuffle-mobile" class="btn-inactive rounded-full focusable" aria-label="シャッフル" aria-pressed="false">
              <i class="fas fa-random"></i>
          </button>
          <button id="btn-loop-mobile" class="btn-inactive rounded-full focusable" aria-label="リピート: オフ">
              <i class="fas fa-repeat"></i>
          </button>
      </div>
      <div class="controls-center">
          <button id="btn-prev-mobile" class="focusable" aria-label="前の曲">
              <i class="fas fa-step-backward"></i>
          </button>
          <button id="btn-play-mobile" class="btn-active rounded-full focusable" aria-label="再生">
              <i class="fas fa-play"></i>
          </button>
          <button id="btn-next-mobile" class="focusable" aria-label="次の曲">
              <i class="fas fa-step-forward"></i>
          </button>
      </div>
      <div class="controls-right">
          <!-- Placeholder for potential volume toggle or other controls -->
      </div>
  </div>
 <!-- =========== Context Menu =========== -->
 <div id="context-menu" class="fixed hidden bg-white dark:bg-gray-800 shadow-xl rounded-md border border-gray-200 dark:border-gray-700 z-[600] py-1 text-sm">
    <!-- Menu items will be populated by JavaScript -->
    <!-- Example structure (generated by JS):
    <a href="#" class="block px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 context-menu-item" data-action="play">
      <i class="fas fa-play w-4 mr-2 text-center"></i> 再生
    </a>
    <a href="#" class="block px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 context-menu-item" data-action="toggleFavorite">
      <i class="fas fa-heart w-4 mr-2 text-center"></i> お気に入りに追加/削除
    </a>
    <div class="border-t border-gray-200 dark:border-gray-600 my-1"></div> // Separator
    <a href="#" class="block px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700 context-menu-item" data-action="share">
       <i class="fas fa-share-alt w-4 mr-2 text-center"></i> 共有
     </a>
     -->
  </div>
      <!-- Profile Modal -->
      <div id="profileModalJG" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50" style="display: none;">
        <div class="bg-jg-surface-bark p-6 rounded-lg shadow-xl w-full max-w-md text-jg-text-light modal-dialog-jg">
            <h3 class="font-display-jg text-2xl mb-4 text-jg-accent-sunburst">Ranger Profile</h3>
            <div id="profileLinksContainerJG" class="space-y-3 mb-6">
                <a href="https://youtube.com/@reikikuchi?si=N7ea0a6H6eyFb4Qk" target="_blank" rel="noopener noreferrer" class="profile-link-jg">
                    <i class="fab fa-youtube text-red-500 fa-lg"></i>
                    <span>YouTube Channel</span>
                </a>
                <a href="https://www.instagram.com/youtube_rei_kikuchi/?igsh=MTFheTR4cjFrdmN2cw%3D%3D&utm_source=qr" target="_blank" rel="noopener noreferrer" class="profile-link-jg">
                    <i class="fab fa-instagram text-pink-500 fa-lg"></i>
                    <span>Instagram</span>
                </a>
            </div>
            <div class="mt-6 flex justify-end gap-3">
                <button id="closeProfileModalJG" class="px-4 py-2 rounded bg-jg-text-shadow hover:bg-opacity-80 transition-colors">閉じる</button>
            </div>
        </div>
    </div>
  <!-- =========== End Context Menu =========== -->
  <!-- YouTube API -->
  <script src="https://www.youtube.com/iframe_api"></script>
  <script>
    
    // ==========================================================================
    // Constants
    // ==========================================================================
    const MAX_HISTORY = 20;
    const VOLUME_STEP = 5; // For keyboard control
    const SEEK_STEP = 5; // For keyboard control (seconds)
    const LS_KEYS = {
        HISTORY: 'reiKikuchiPlayerHistory',
        FAVORITES: 'reiKikuchiPlayerFavorites',
        PLAYLISTS: 'reiKikuchiPlayerPlaylists',
        USER: 'reiKikuchiPlayerUser',
        THEME: 'reiKikuchiPlayerTheme',
        QUEUE: 'reiKikuchiPlayerQueue' // <-- New Key
      };
    // ==========================================================================
    // Data and State Management
    // ==========================================================================
        // ==========================================================================
    // Data and State Management
    // ==========================================================================
    const appState = {
      player: null,
      songs: [],
      filteredSongs: [], // Currently displayed songs in the main playlist tab
      currentSongIndex: -1, // Index within the original `songs` array
      isPlaying: false,
      isShuffle: false,
      loopMode: 'none', // 'none', 'one', 'all'
      currentTab: 'playlist',
      volume: 100,
      progressInterval: null,
      history: [],
      favorites: [],
      userPlaylists: [],
      currentSelectedPlaylistId: null, // Renamed for clarity
      loggedInUser: null,
      snackbarTimeoutId: null, // For managing snackbar display
      activeModalId: null, // Track the currently open modal
      isPlayerReady: false,
      isBarVisible: false, // Track if the Now Playing Bar should be visible
      // --- ↓↓↓ QUEUE STATE ADDED ↓↓↓ ---
      queue: [], // 曲IDの配列 (再生待ちリスト)
      currentQueueIndex: -1, // キュー内での現在の再生位置 (-1 はキュー再生中でない)
      playMode: 'playlist', // 'playlist' または 'queue'
      // --- ↑↑↑ QUEUE STATE ADDED ↑↑↑ ---
      visualizer: {
          context: null,
          analyser: null,
          animationFrameId: null,
          bufferLength: 0,
          dataArray: null,
          canvas: null,
          canvasCtx: null,
      },
      contextMenu: {
        visible: false,
        x: 0,
        y: 0,
        targetSongId: null,
        longPressTimer: null,
        isLongPress: false
      }
    }; // appState end

    // ==========================================================================
    // Elements (Will be initialized in onPlayerReady)
    // ==========================================================================
    let elements = {}; // Declare elements object, initialize later

    function initializeElements() {
    elements = {
        app: document.getElementById('app'),
        body: document.body,
        playlist: document.getElementById('playlist'),
        historyList: document.getElementById('history-list'),
        favoritesList: document.getElementById('favorites-list'),
        userPlaylistsList: document.getElementById('user-playlists-list'), // <<< 確認: ユーザープレイリストのコンテナ
        currentSongTitle: document.getElementById('current-song-title'),
        currentSongDuration: document.getElementById('current-song-duration'),
        progressBar: document.getElementById('progress-bar'),
        progressContainer: document.querySelector('.progress-container'),
        currentTime: document.getElementById('current-time'),
        totalTime: document.getElementById('total-time'),
        // Desktop Controls
        btnPlay: document.getElementById('btn-play'),
        btnPrev: document.getElementById('btn-prev'),
        btnNext: document.getElementById('btn-next'),
        btnShuffle: document.getElementById('btn-shuffle'),
        btnLoop: document.getElementById('btn-loop'),
        volumeSlider: document.getElementById('volume-slider'),
        // --- General UI ---
        themeToggle: document.getElementById('theme-toggle'),
        searchInput: document.getElementById('search-input'),
        tabs: document.querySelectorAll('.tab'),
        tabContents: document.querySelectorAll('.tab-content'),
        visualizerCanvas: document.getElementById('visualizer'),
        nowPlayingBadge: document.getElementById('now-playing-badge'),
        openYouTubeBtn: document.getElementById('open-youtube-btn'),
        shareBtn: document.getElementById('share-btn'),
        // createPlaylistBtn: document.getElementById('create-playlist-btn'), // <<< 削除またはコメントアウト (HTMLにないため)
        offlineMenuBtn: document.getElementById('offline-menu-btn'),
        // --- Modals ---
        modals: {
            createPlaylist: document.getElementById('create-playlist-modal'), // <<< 確認
            playlistDetail: document.getElementById('playlist-detail-modal'),
            share: document.getElementById('share-modal'),
            account: document.getElementById('account-modal'),
            offline: document.getElementById('offline-modal')
        },
        // --- Modal Close Buttons ---
        modalCloseBtns: document.querySelectorAll('.close-modal-btn'),
        // --- Modal Specific Buttons ---
        modalButtons: {
            savePlaylist: document.getElementById('save-playlist-btn'), // <<< 確認
            removeFromPlaylist: document.getElementById('remove-from-playlist-btn'),
            sharePlaylist: document.getElementById('share-playlist-btn'),
            copyLink: document.getElementById('copy-link-btn'),
            login: document.getElementById('login-btn'),
            showRegister: document.getElementById('show-register-btn'),
            register: document.getElementById('register-btn'),
            showLogin: document.getElementById('show-login-btn'),
            syncData: document.getElementById('sync-data-btn'),
            logout: document.getElementById('logout-btn'),
            account: document.getElementById('account-btn')
        },
        // --- Account Sections and Fields ---
        accountSections: {
            login: document.getElementById('login-section'),
            register: document.getElementById('register-section'),
            accountInfo: document.getElementById('account-info-section')
        },
        accountFields: {
            loginEmail: document.getElementById('login-email'),
            loginPassword: document.getElementById('login-password'),
            registerName: document.getElementById('register-name'),
            registerEmail: document.getElementById('register-email'),
            registerPassword: document.getElementById('register-password'),
            userName: document.getElementById('user-name'),
            userEmail: document.getElementById('user-email')
        },
        // --- Playlist Related Elements ---
        playlistElements: {
            nameInput: document.getElementById('playlist-name-input'), // <<< 確認
            detailTitle: document.getElementById('playlist-detail-title'),
            detailContent: document.getElementById('playlist-detail-content'),
            shareObjectTitle: document.getElementById('share-object-title'),
            shareLinkInput: document.getElementById('share-link-input')
        },
        snackbar: document.getElementById('snackbar'),
        // --- Mobile Bottom Controls ---
        bottomControls: document.getElementById('bottom-controls'),
        btnPlayMobile: document.getElementById('btn-play-mobile'),
        btnPrevMobile: document.getElementById('btn-prev-mobile'),
        btnNextMobile: document.getElementById('btn-next-mobile'),
        btnShuffleMobile: document.getElementById('btn-shuffle-mobile'),
        btnLoopMobile: document.getElementById('btn-loop-mobile'),
        // --- Now Playing Bar Elements ---
        nowPlayingBar: document.getElementById('now-playing-bar'),
        nowPlayingBarInfo: document.getElementById('now-playing-bar-info'),
        nowPlayingBarThumb: document.getElementById('now-playing-bar-thumb'),
        nowPlayingBarTitle: document.getElementById('now-playing-bar-title'),
        nowPlayingBarArtist: document.getElementById('now-playing-bar-artist'),
        btnPlayBar: document.getElementById('btn-play-bar'),
        btnPrevBar: document.getElementById('btn-prev-bar'),
        btnNextBar: document.getElementById('btn-next-bar'),
        nowPlayingBarProgress: document.getElementById('now-playing-bar-progress'),
        nowPlayingBarProgressContainer: document.getElementById('now-playing-bar-progress-container'),
        volumeSliderBar: document.getElementById('volume-slider-bar'),
        volumeIconBar: document.getElementById('now-playing-bar-volume-icon'),
        // --- Context Menu Element ---
        contextMenu: document.getElementById('context-menu'),
        // --- Queue UI Elements ---
        queueList: document.getElementById('queue-list'),
        queueTabContent: document.getElementById('queue-tab'),
        queueEmptyState: document.querySelector('#queue-tab .empty-state-container'),
        queueClearBtn: document.getElementById('clear-queue-btn'),
        queueCountBadge: document.getElementById('queue-count-badge'),
    };

    // --- エラーチェック ---
    // Optional: Add checks here to ensure critical elements were found
    if (!elements.playlist) console.error("ERROR: Playlist container not found!");
    if (!elements.userPlaylistsList) console.error("ERROR: User Playlists List container not found!");
    if (!elements.modals.createPlaylist) console.error("ERROR: Create Playlist Modal (#create-playlist-modal) not found!");
    if (!elements.modalButtons.savePlaylist) console.error("ERROR: Save Playlist Button (#save-playlist-btn) not found!");
    if (!elements.playlistElements.nameInput) console.error("ERROR: Playlist Name Input (#playlist-name-input) not found!");
    if (!elements.queueList) console.error("ERROR: Queue List container (#queue-list) not found!");
    if (!elements.queueEmptyState) console.error("ERROR: Queue Empty State container (#queue-tab .empty-state-container) not found!");
    // ... other checks ...
}

    // ==========================================================================
    // Context Menu Functions
    // ==========================================================================

    function openContextMenu(event, songId) {
        event.preventDefault(); // Prevent default browser context menu
        event.stopPropagation(); // Stop event bubbling

        const song = findSongById(songId);
        if (!song || !elements.contextMenu) return;

        // Close any other open menus/dropdowns
        closeAllPlaylistDropdowns();
        hideContextMenu(); // Close if already open for another item

        appState.contextMenu.targetSongId = songId;

        // Determine position
        appState.contextMenu.x = event.clientX;
        appState.contextMenu.y = event.clientY;

        // Generate menu items based on song state
        elements.contextMenu.innerHTML = generateContextMenuItems(song);

        // Position and show the menu
        elements.contextMenu.classList.remove('hidden'); // Show before positioning to get dimensions
        appState.contextMenu.visible = true; // Set visible early for position calculation
        positionContextMenu(); // Position based on visibility and dimensions

        // Add listener to close menu when clicking outside
        setTimeout(() => {
             document.addEventListener('click', handleClickOutsideContextMenu, { capture: true, once: true });
             document.addEventListener('contextmenu', handleClickOutsideContextMenu, { capture: true, once: true });
             document.addEventListener('keydown', handleContextMenuKeyDown, { capture: true }); // Use regular listener, remove on hide
        }, 0);
    }

    function hideContextMenu() {
        if (appState.contextMenu.visible && elements.contextMenu) {
            elements.contextMenu.classList.add('hidden');
            appState.contextMenu.visible = false;
            appState.contextMenu.targetSongId = null;
            // Remove potential listeners immediately
            document.removeEventListener('click', handleClickOutsideContextMenu, { capture: true });
            document.removeEventListener('contextmenu', handleClickOutsideContextMenu, { capture: true });
            document.removeEventListener('keydown', handleContextMenuKeyDown, { capture: true }); // Remove keydown listener
             // Clear any potential long press timer
             if(appState.contextMenu.longPressTimer) clearTimeout(appState.contextMenu.longPressTimer);
             appState.contextMenu.longPressTimer = null; // Reset timer ID
             appState.contextMenu.isLongPress = false; // Reset flag
        }
    }

    // Close menu if click is outside
    function handleClickOutsideContextMenu(event) {
        // Check visibility again in case it was closed by other means (e.g., Escape key)
        if (!appState.contextMenu.visible) return;

        if (elements.contextMenu && !elements.contextMenu.contains(event.target)) {
            // Only hide if the click wasn't on an element that might open *another* context menu
            if (!event.target.closest('.playlist-item, .history-item, .favorite-item')) {
                 hideContextMenu();
            } else {
                 // If click was on another list item, let its contextmenu handler manage opening/closing
                 // We still need to re-attach listener as 'once' removes it
                 document.addEventListener('click', handleClickOutsideContextMenu, { capture: true, once: true });
                 document.addEventListener('contextmenu', handleClickOutsideContextMenu, { capture: true, once: true });
            }
        } else {
            // Click was inside the menu or on the triggering element, re-attach listener
             document.addEventListener('click', handleClickOutsideContextMenu, { capture: true, once: true });
             document.addEventListener('contextmenu', handleClickOutsideContextMenu, { capture: true, once: true });
        }
    }

     // Close menu on Escape key
     function handleContextMenuKeyDown(event) {
         if (event.key === 'Escape') {
             hideContextMenu();
         }
     }

    function positionContextMenu() {
        // Ensure menu is visible and exists before trying to get dimensions
        if (!elements.contextMenu || !appState.contextMenu.visible) return;

        const menu = elements.contextMenu;
        const { x, y } = appState.contextMenu;

        // Temporarily make fully visible to calculate dimensions correctly if using opacity/transform transitions
        // menu.style.opacity = '1';
        // menu.style.transform = 'scale(1)';

        const menuWidth = menu.offsetWidth;
        const menuHeight = menu.offsetHeight;
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        // Restore potential transition styles if needed
        // menu.style.opacity = '';
        // menu.style.transform = '';

        // Adjust position if menu goes off-screen
        let finalX = x;
        let finalY = y;

        if (x + menuWidth > windowWidth - 10) { // Add small margin
            finalX = windowWidth - menuWidth - 10;
        }
        if (y + menuHeight > windowHeight - 10) {
            finalY = windowHeight - menuHeight - 10;
        }
         // Ensure not negative coordinates
         finalX = Math.max(10, finalX);
         finalY = Math.max(10, finalY);

        menu.style.left = `${finalX}px`;
        menu.style.top = `${finalY}px`;
    }

    function generateContextMenuItems(song) {
        if (!song) return '';

        const isFavorite = appState.favorites.some(fav => fav && fav.id === song.id);
        const canAddToPlaylist = appState.loggedInUser && appState.userPlaylists.length > 0;
        const isInQueue = appState.queue.includes(song.id); // Check if already in queue

        let itemsHTML = `
            <a href="#" class="context-menu-item focusable" data-action="play">
              <i class="fas fa-play w-4 mr-2 text-center"></i> 再生
            </a>
            <a href="#" class="context-menu-item focusable" data-action="playNext">
              <i class="fas fa-level-up-alt fa-rotate-90 w-4 mr-2 text-center"></i> 次に再生
            </a>
            <a href="#" class="context-menu-item focusable" data-action="addToQueue">
              <i class="fas ${isInQueue ? 'fa-check' : 'fa-plus'} w-4 mr-2 text-center"></i> ${isInQueue ? 'キューに追加済み' : 'キューに追加'}
            </a>
            <div class="context-menu-separator"></div>
            <a href="#" class="context-menu-item focusable" data-action="toggleFavorite">
              <i class="fas fa-heart w-4 mr-2 text-center ${isFavorite ? 'text-red-500' : 'text-gray-400'}"></i> ${isFavorite ? 'お気に入り解除' : 'お気に入り登録'}
            </a>
        `;

        // Add "Add to Playlist" section if possible
        if (appState.loggedInUser) {
            itemsHTML += `<div class="context-menu-separator"></div>`; // Separator
             if (canAddToPlaylist) {
                  itemsHTML += `<div class="context-menu-item px-4 py-2 text-xs text-gray-500 dark:text-gray-400">プレイリストに追加:</div>`;
                  appState.userPlaylists.forEach(playlist => {
                       const alreadyExists = playlist.songs?.includes(song.id);
                       itemsHTML += `
                       <a href="#" class="context-menu-item focusable ${alreadyExists ? 'opacity-50 italic' : ''}" data-action="addToPlaylist" data-playlist-id="${playlist.id}">
                         <i class="fas ${alreadyExists ? 'fa-check' : 'fa-plus'} w-4 mr-2 text-center"></i> ${escapeHTML(playlist.name)} ${alreadyExists ? '(追加済)' : ''}
                       </a>`;
                  });
             } else {
                  itemsHTML += `<a href="#" class="context-menu-item focusable" data-action="createPlaylist"><i class="fas fa-plus w-4 mr-2 text-center"></i> 新しいプレイリストを作成...</a>`;
             }
        }

        // Add Share action
        itemsHTML += `<div class="context-menu-separator"></div>`;
        itemsHTML += `
            <a href="#" class="context-menu-item focusable" data-action="share">
              <i class="fas fa-share-alt w-4 mr-2 text-center"></i> 共有...
            </a>`;
         // Add Open on YouTube action
         itemsHTML += `
             <a href="#" class="context-menu-item focusable" data-action="openYouTube">
               <i class="fab fa-youtube w-4 mr-2 text-center"></i> YouTubeで開く
             </a>`;


        return itemsHTML;
    }

        // ==========================================================================
    // Queue Functions
    // ==========================================================================
    function addToQueue(songId, playNext = false) {
    if (!songId) return;
    const song = findSongById(songId);
    if (!song) {
        showSnackbar("曲が見つかりません。");
        return;
    }

    // --- Prevent Duplicates (Optional: Uncomment if needed) ---
    const existingIndex = appState.queue.indexOf(songId);
    if (existingIndex !== -1) {
        if (playNext) {
            if (appState.queue.length > 1) { // Only move if there are other items
                appState.queue.splice(existingIndex, 1); // Remove from old position
                let insertIndex;
                if (appState.playMode === 'queue' && appState.currentQueueIndex !== -1) {
                    insertIndex = appState.currentQueueIndex + 1;
                } else {
                     insertIndex = 0;
                     if (appState.isPlaying && appState.playMode !== 'queue') {
                         insertIndex = 0;
                     }
                }
                appState.queue.splice(insertIndex, 0, songId);
                showSnackbar(`「${escapeHTML(song.title)}」を次に再生するよう移動しました`);
            } else {
                showSnackbar(`「${escapeHTML(song.title)}」は既にキューの唯一の曲です`);
            }
        } else {
            showSnackbar(`「${escapeHTML(song.title)}」は既にキューにあります。`);
        }
        renderQueueList(); // Update UI even if only moved or notified
         if (appState.contextMenu.visible && appState.contextMenu.targetSongId === songId && elements.contextMenu) {
             elements.contextMenu.innerHTML = generateContextMenuItems(song);
         }
        return; // Stop here after handling duplicate
    }
    // --- End Prevent Duplicates ---

    // --- Add New Item ---
    if (playNext) {
        let insertIndex;
        if (appState.playMode === 'queue' && appState.currentQueueIndex !== -1) {
            insertIndex = appState.currentQueueIndex + 1;
        } else {
             insertIndex = 0;
             if (appState.isPlaying && appState.playMode !== 'queue') {
                 insertIndex = 0;
             }
        }
        appState.queue.splice(insertIndex, 0, songId);
        showSnackbar(`「${escapeHTML(song.title)}」を次に再生します`);
    } else {
        appState.queue.push(songId);
        showSnackbar(`「${escapeHTML(song.title)}」をキューに追加しました`);
    }

    console.log("Queue updated:", appState.queue);
    renderQueueList(); // <<<====== [FIX] Render queue after adding/moving
    if (appState.contextMenu.visible && appState.contextMenu.targetSongId === songId && elements.contextMenu) {
         elements.contextMenu.innerHTML = generateContextMenuItems(song);
    }
}

function clearQueue() {
    appState.queue = [];
    appState.currentQueueIndex = -1;
    if (appState.playMode === 'queue') {
        appState.playMode = 'playlist'; // 再生モードを戻す
    }
    console.log("Queue cleared.");
    showSnackbar("キューをクリアしました");
    renderQueueList(); // <<<====== [FIX] Render queue after clearing
}
function removeFromQueue(songId) {
    const indexToRemove = appState.queue.indexOf(songId);
    if (indexToRemove === -1) return;

    const song = findSongById(songId);
    appState.queue.splice(indexToRemove, 1);
    showSnackbar(`「${escapeHTML(song?.title || '曲')}」をキューから削除しました`);

    // Adjust currentQueueIndex if the removed item was before or at the current position
    if (indexToRemove < appState.currentQueueIndex) {
        appState.currentQueueIndex--;
    } else if (indexToRemove === appState.currentQueueIndex) {
        // If the currently playing item was removed, stop marking any item as playing in queue
        // The player will continue playing the song until it ends or is changed.
        // handleSongEnd or playNextSong will figure out what to play next.
        appState.currentQueueIndex = -1; // Indicate we are no longer tracking a specific queue index *during* this song
         // But remain in queue mode if queue still has items.
         if (appState.queue.length === 0) {
             appState.playMode = 'playlist';
         }
    }
     // Ensure index is valid after removal
     if (appState.currentQueueIndex >= appState.queue.length) {
          appState.currentQueueIndex = -1;
     }

    renderQueueList(); // <<<====== [FIX] Render queue after removing
}
function playFromQueue(queueIndex) {
    // Find the actual index in the current DOM, in case filtering/sorting happens later
    const queueItems = document.querySelectorAll('#queue-list .queue-item');
    if (queueIndex < 0 || queueIndex >= queueItems.length) {
         console.error("Invalid queue DOM index:", queueIndex);
         return;
    }
    const targetItem = queueItems[queueIndex];
    const songId = targetItem?.dataset?.songId;
    const actualQueueIndex = appState.queue.indexOf(songId); // Find index in the underlying data array

    if (!songId || actualQueueIndex === -1) {
        console.error("Could not find songId or song in appState.queue for DOM index:", queueIndex, songId);
        showSnackbar("キュー内の曲を再生できませんでした。");
        return;
    }

    const originalIndex = findSongIndexById(songId);

    if (originalIndex !== -1) {
        appState.playMode = 'queue';
        appState.currentQueueIndex = actualQueueIndex; // Use the index from the data array
        playSong(originalIndex, true); // Play the song, keeping queue mode context
        // renderQueueList() is called inside playSong, which will update highlighting
    } else {
        showSnackbar("キュー内の曲がメインリストに見つかりませんでした。");
        // Optionally remove the invalid song ID from the queue here
        // removeFromQueue(songId);
    }
}
// ==========================================================================
// Queue UI Rendering Function (NEW / REVISED)
// ==========================================================================
function renderQueueList() {
    // Use elements object instead of querying the DOM every time
    const container = elements.queueList;
    const emptyStateContainer = elements.queueEmptyState;
    const clearQueueBtn = elements.queueClearBtn;
    const queueCountBadge = elements.queueCountBadge;

    // Check if elements were found during initialization
    if (!container || !emptyStateContainer || !clearQueueBtn || !queueCountBadge) {
        // Log error only once if elements are missing from initialization
        if (!renderQueueList.warned) { // Use a flag on the function itself
            console.error("Queue list UI elements missing (check initialization and HTML IDs/structure). Cannot render queue.");
            renderQueueList.warned = true; // Set flag to prevent repeated warnings
        }
        return; // Stop execution if elements are missing
    }
    renderQueueList.warned = false; // Reset warning if elements are found this time

    // Update badge and clear button state
    const queueLength = appState.queue.length;
    if (queueLength > 0) {
        queueCountBadge.textContent = queueLength;
        queueCountBadge.classList.remove('hidden');
        clearQueueBtn.disabled = false;
    } else {
        queueCountBadge.textContent = '0';
        queueCountBadge.classList.add('hidden');
        clearQueueBtn.disabled = true;
    }

    // Toggle empty state visibility
    emptyStateContainer.classList.toggle('hidden', queueLength > 0);
    // Ensure container is visible when not empty, hidden when empty
    container.classList.toggle('hidden', queueLength === 0);

    if (queueLength === 0) {
        container.innerHTML = ''; // Clear the list content if empty
        return;
    }

    const fragment = document.createDocumentFragment();
    const currentlyPlayingSongId = currentSongId();

    appState.queue.forEach((songId, index) => {
        const song = findSongById(songId);
        const div = document.createElement('div');

        if (!song) {
            console.warn(`Song ID ${songId} from queue not found in main song list.`);
            div.className = `queue-item opacity-50 italic`;
            div.dataset.songId = songId;
            div.dataset.queueIndex = index;
            div.innerHTML = `
                 <div class="queue-item-info">
                    <i class="fas fa-grip-vertical queue-item-drag-handle mr-2" aria-hidden="true"></i>
                    <span class="queue-item-title">[不明な曲 ID: ${songId}]</span>
                 </div>
                 <div class="queue-item-actions">
                     <button class="queue-item-remove-btn focusable" aria-label="キューから不明な曲を削除" data-song-id="${songId}">
                         <i class="fas fa-times"></i>
                     </button>
                 </div>`;
             const removeBtn = div.querySelector('.queue-item-remove-btn');
             removeBtn?.addEventListener('click', (e) => {
                 e.stopPropagation();
                 removeFromQueue(songId);
             });
            fragment.appendChild(div);
            return;
        }

        const isCurrentQueueItem = appState.playMode === 'queue' && appState.currentQueueIndex === index;
        const isSongPlaying = appState.isPlaying && currentlyPlayingSongId === song.id;

        div.className = `queue-item focusable ${isCurrentQueueItem ? 'playing' : ''}`;
        div.dataset.songId = song.id;
        div.dataset.queueIndex = index;
        div.tabIndex = 0;
        div.draggable = true;

        // --- Event Listeners ---
        div.addEventListener('click', (e) => {
             if (!e.target.closest('.queue-item-remove-btn') && !e.target.closest('.queue-item-drag-handle')) {
                 // Pass the DOM index (position in the currently rendered list)
                 const domIndex = Array.from(container.children).indexOf(div);
                 if (domIndex !== -1) { // Check if index was found
                    playFromQueue(domIndex);
                 } else {
                     console.warn("Could not determine DOM index for clicked queue item.");
                 }
             }
        });
        div.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                 const domIndex = Array.from(container.children).indexOf(div);
                 if (domIndex !== -1) {
                    playFromQueue(domIndex);
                 } else {
                     console.warn("Could not determine DOM index for keydown on queue item.");
                 }
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                 e.preventDefault();
                 removeFromQueue(song.id);
            }
        });
        div.addEventListener('dragstart', handleDragStart);
        div.addEventListener('dragover', handleDragOver);
        div.addEventListener('dragleave', handleDragLeave);
        div.addEventListener('drop', handleDrop);
        div.addEventListener('dragend', handleDragEnd);

        // --- Inner HTML ---
        div.innerHTML = `
            <div class="queue-item-info">
               <i class="fas fa-grip-vertical queue-item-drag-handle mr-2 text-gray-400 dark:text-gray-500" aria-hidden="true"></i>
                <img src="${song.thumbnail || ''}" alt="${escapeHTML(song.title)}" class="queue-item-thumb" loading="lazy">
                <span class="queue-item-title">${escapeHTML(song.title)}</span>
                ${isSongPlaying ? '<i class="fas fa-volume-up text-primary-color ml-2 text-xs animate-pulse"></i>' : ''}
            </div>
            <div class="queue-item-actions">
                <button class="queue-item-remove-btn focusable text-gray-500 hover:text-red-500 dark:text-gray-400 dark:hover:text-red-400" aria-label="キューから「${escapeHTML(song.title)}」を削除" data-song-id="${song.id}">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        `;

        // --- Remove Button Listener ---
        const removeBtn = div.querySelector('.queue-item-remove-btn');
        removeBtn?.addEventListener('click', (e) => {
            e.stopPropagation();
            removeFromQueue(song.id);
        });

        fragment.appendChild(div);
    });

    container.innerHTML = ''; // Clear previous content
    container.appendChild(fragment);
}
// ==========================================================================
// Drag and Drop Functions for Queue (NEW / REVISED)
// ==========================================================================
let draggedItem = null; // The DOM element being dragged
let draggedItemIndex = -1; // The original index in appState.queue
let dragOverItem = null; // The DOM element being dragged over

function handleDragStart(e) {
    draggedItem = e.target.closest('.queue-item');
    if (!draggedItem) return;

    const songId = draggedItem.dataset.songId;
    draggedItemIndex = appState.queue.indexOf(songId); // Get index from data array

    if (draggedItemIndex === -1) {
        console.error("Could not find dragged song in appState.queue:", songId);
        e.preventDefault(); // Cancel drag
        return;
    }

    // Use a minimal data transfer (needed for Firefox)
    e.dataTransfer.effectAllowed = 'move';
    try {
        e.dataTransfer.setData('text/plain', songId);
        e.dataTransfer.setData('application/x-player-queue-index', draggedItemIndex.toString());
    } catch (err) {
        console.warn("Setting dataTransfer failed (IE/Edge?):", err);
         e.dataTransfer.setData('Text', songId); // Fallback for IE
    }


    // Add dragging style after a short delay to allow the browser to render the drag image
    setTimeout(() => {
        draggedItem?.classList.add('dragging');
    }, 0);
}

function handleDragOver(e) {
    e.preventDefault(); // Necessary to allow dropping
    e.dataTransfer.dropEffect = 'move';

    const targetItem = e.target.closest('.queue-item');
    if (!targetItem || targetItem === draggedItem || targetItem === dragOverItem) {
         // If dragging over self or empty space, remove indicator from previous target
         if (dragOverItem && targetItem !== dragOverItem) {
             dragOverItem.classList.remove('drag-over');
             dragOverItem = null;
         }
        return;
    }

    // Remove previous drag-over class
    if (dragOverItem) {
        dragOverItem.classList.remove('drag-over');
    }

    // Add drag-over class to the new target
    dragOverItem = targetItem;
    dragOverItem.classList.add('drag-over');
}

function handleDragLeave(e) {
     // Check if the mouse is leaving the queue-list container entirely or entering a non-item area
     const queueList = document.getElementById('queue-list');
     if (!queueList || !e.relatedTarget || !queueList.contains(e.relatedTarget)) {
         if (dragOverItem) {
             dragOverItem.classList.remove('drag-over');
             dragOverItem = null;
         }
     } else {
        // If moving between items, dragOver will handle removing the class from the previous item
        const currentTarget = e.target.closest('.queue-item');
         if (currentTarget && currentTarget === dragOverItem && e.relatedTarget.closest('.queue-item') !== dragOverItem) {
             currentTarget.classList.remove('drag-over');
             dragOverItem = null;
         }
     }
}

function handleDrop(e) {
    e.preventDefault();
    e.stopPropagation(); // Prevent bubbling

    const dropTargetItem = e.target.closest('.queue-item');

    if (dragOverItem) {
         dragOverItem.classList.remove('drag-over'); // Clean up visual cue immediately
    }

    if (!draggedItem || !dropTargetItem || draggedItem === dropTargetItem || draggedItemIndex === -1) {
        console.log("Drop cancelled: Invalid target, same item, or missing drag data.");
        // No need to call handleDragEnd here, it will be called automatically
        return;
    }

    // --- Reorder Logic ---
    const dropTargetSongId = dropTargetItem.dataset.songId;
    const dropIndex = appState.queue.indexOf(dropTargetSongId); // Get target index from data array

    if (dropIndex === -1) {
        console.error("Could not find drop target song in appState.queue:", dropTargetSongId);
        return;
    }

    // Move item in the appState.queue array
    const [movedItem] = appState.queue.splice(draggedItemIndex, 1);
    // Calculate the correct insertion index after removal
    const insertIndex = (draggedItemIndex < dropIndex) ? dropIndex - 1 : dropIndex;
    appState.queue.splice(insertIndex, 0, movedItem);


    console.log("Queue reordered:", appState.queue);

    // --- Adjust currentQueueIndex ---
    const originalCurrentIndex = appState.currentQueueIndex;
    let newCurrentIndex = originalCurrentIndex;

    if (originalCurrentIndex === -1) {
         // If nothing was playing in queue context, no index adjustment needed
    } else if (draggedItemIndex === originalCurrentIndex) {
        // Moved the currently playing item: update its index
        newCurrentIndex = insertIndex;
    } else if (draggedItemIndex < originalCurrentIndex && insertIndex >= originalCurrentIndex) {
        // Moved an item from *before* current to *at or after* current: current shifts up
        newCurrentIndex--;
    } else if (draggedItemIndex > originalCurrentIndex && insertIndex <= originalCurrentIndex) {
        // Moved an item from *after* current to *at or before* current: current shifts down
        newCurrentIndex++;
    }
    // Ensure index stays within bounds
    appState.currentQueueIndex = Math.max(-1, Math.min(newCurrentIndex, appState.queue.length - 1));

    renderQueueList(); // Re-render the list with the new order
    // handleDragEnd will clean up the draggedItem styles
}


function handleDragEnd(e) {
    // Remove dragging class and reset styles from the originally dragged item
    if (draggedItem) {
        draggedItem.classList.remove('dragging');
    }
    // Ensure any lingering drag-over styles are removed
    if (dragOverItem) {
        dragOverItem.classList.remove('drag-over');
    }
    // Reset state variables
    draggedItem = null;
    draggedItemIndex = -1;
    dragOverItem = null;
}
    // (removeFromQueue, playFromQueueなどの関数はフェーズ3で追加)

    // ==========================================================================
    // Context Menu Action Handler (Modified)
    // ==========================================================================
    function handleContextMenuAction(event) {
        event.preventDefault();
        event.stopPropagation();

        const target = event.target.closest('.context-menu-item');
        if (!target || !appState.contextMenu.targetSongId) {
            hideContextMenu();
            return;
        }

        const action = target.dataset.action;
        const songId = appState.contextMenu.targetSongId;
        const playlistId = target.dataset.playlistId;
        let shouldHideMenu = true; // Default to hiding

        console.log(`Context menu action: ${action}, Song ID: ${songId}, Playlist ID: ${playlistId}`);

        switch (action) {
            case 'play':
                const originalIndex = findSongIndexById(songId);
                if (originalIndex !== -1) {
                    // Playing a song directly should probably reset the queue context
                    // appState.playMode = 'playlist'; // Or decide based on UX preference
                    // appState.currentQueueIndex = -1;
                    playSong(originalIndex);
                }
                break;
            case 'playNext': // New action
                addToQueue(songId, true);
                break;
            case 'addToQueue': // New action
                addToQueue(songId, false);
                // Don't hide menu immediately after adding to queue? Optional
                shouldHideMenu = false;
                 // Update menu item state immediately
                 const song = findSongById(songId);
                 if (song && elements.contextMenu) {
                      elements.contextMenu.innerHTML = generateContextMenuItems(song);
                      // Need to re-position slightly if content height changed? Less likely.
                 }
                break;
            case 'toggleFavorite':
                toggleFavorite(songId);
                // Keep menu open to see change?
                shouldHideMenu = false;
                break;
            case 'addToPlaylist':
                 if (playlistId) {
                     const playlist = appState.userPlaylists.find(p => p.id === playlistId);
                     if (!playlist?.songs?.includes(songId)) {
                         addSongToPlaylist(songId, playlistId);
                     } else {
                         showSnackbar("この曲は既に追加されています。");
                         shouldHideMenu = false; // Keep menu open
                     }
                 }
                break;
             case 'createPlaylist':
                 showCreatePlaylistModal();
                 break;
            case 'share':
                 const songToShare = findSongById(songId);
                 if (songToShare) {
                     const tempIndex = appState.currentSongIndex;
                     appState.currentSongIndex = findSongIndexById(songId);
                     showShareModal();
                     appState.currentSongIndex = tempIndex;
                 }
                 break;
            case 'openYouTube':
                 const songToOpen = findSongById(songId);
                 if (songToOpen) {
                     const youtubeUrl = `https://www.youtube.com/watch?v=${songToOpen.id}`;
                     window.open(youtubeUrl, '_blank');
                 }
                 break;
            default:
                console.warn("Unknown context menu action:", action);
                shouldHideMenu = false; // Don't hide for unknown actions
        }

        if(shouldHideMenu) {
            hideContextMenu(); // Close menu after action
        }
    }
    // ==========================================================================
    // YouTube Player Initialization
    // ==========================================================================
    function onYouTubeIframeAPIReady() {
      console.log("onYouTubeIframeAPIReady called");
      try {
        appState.player = new YT.Player('youtube-player', {
          height: '100%',
          width: '100%',
          videoId: '', // Start empty
          playerVars: {
            'autoplay': 0, 'controls': 0, 'rel': 0, 'showinfo': 0,
            'modestbranding': 1, 'fs': 0, 'playsinline': 1
          },
          events: {
            'onReady': onPlayerReady,
            'onStateChange': onPlayerStateChange,
            'onError': onPlayerError
          }
        });
      } catch (error) {
          console.error("Error initializing YouTube Player:", error);
          showSnackbar("プレイヤーの初期化に失敗しました。");
      }
    }

    function onPlayerReady(event) {
    console.log("Player Ready");
    initializeElements();
    appState.isPlayerReady = true;
    if(elements.volumeSlider) elements.volumeSlider.value = appState.volume;
    if(elements.volumeSliderBar) elements.volumeSliderBar.value = appState.volume;
    if(event.target && typeof event.target.setVolume === 'function') {
        try { event.target.setVolume(appState.volume); } catch (e) { console.warn("Failed to set initial volume", e)}
    }
    loadSongsFromYouTube(); // Load songs first
    loadUserData(); // Load history, favs, playlists, queue etc.
    renderQueueList(); // <<<====== [ADD] Render initial queue state after loading data
    initAudioAnalyser();
    setupEventListeners(); // Setup UI interactions *after* elements are initialized
    handleUrlParams();
    checkBottomControlsVisibility();
    setupYouTubeSync();
    // offlinePlayback.init();
    console.log("Player initialization sequence complete.");
}


    function onPlayerStateChange(event) {
      console.log("Player State Changed:", event.data);
      const playerState = event.data;
      const isPlaying = playerState === YT.PlayerState.PLAYING;
      const isPaused = playerState === YT.PlayerState.PAUSED;
      const isEnded = playerState === YT.PlayerState.ENDED;
      const isCued = playerState === YT.PlayerState.CUED;
      const isBuffering = playerState === YT.PlayerState.BUFFERING;

      const previousIsPlaying = appState.isPlaying;
      appState.isPlaying = isPlaying;

      elements.nowPlayingBadge?.classList.toggle('hidden', !isPlaying);
      elements.shareBtn?.toggleAttribute('disabled', !isPlaying);
      elements.openYouTubeBtn?.toggleAttribute('disabled', !currentSongData()?.id);

      const playIcon = '<i class="fas fa-play"></i>';
      const pauseIcon = '<i class="fas fa-pause"></i>';
      const playLabel = '再生';
      const pauseLabel = '一時停止';

      if (elements.btnPlay) {
          elements.btnPlay.innerHTML = isPlaying ? pauseIcon : playIcon;
          elements.btnPlay.setAttribute('aria-label', isPlaying ? pauseLabel : playLabel);
      }
      if (elements.btnPlayMobile) {
          elements.btnPlayMobile.innerHTML = isPlaying ? pauseIcon : playIcon;
          elements.btnPlayMobile.setAttribute('aria-label', isPlaying ? pauseLabel : playLabel);
      }
      updateNowPlayingBar();

      if (isPlaying) {
          console.log("[DEBUG] Player is PLAYING, starting progress update.");
          startProgressUpdate();
          const song = currentSongData();
          if (song) {
              addToHistory(song);
              renderHistoryList();
          }
          if (appState.visualizer.animationFrameId === null) {
              console.log("[DEBUG] Starting visualizer loop...");
              drawVisualizer();
          } else {
              console.log("[DEBUG] Visualizer loop already running. ID:", appState.visualizer.animationFrameId);
          }
      } else if (isPaused || isCued || isEnded || isBuffering) {
          console.log("[DEBUG] Player is NOT PLAYING (or buffering), stopping progress update. State:", playerState);
          stopProgressUpdate();
          if (isCued || isEnded) {
              updateProgress();
          }
          updateNowPlayingBar();
      }

      if (isEnded) {
          handleSongEnd();
      }
    }
     function onPlayerError(event) {
         console.error("YouTube Player Error:", event.data);
         let errorMessage = "動画の再生中にエラーが発生しました。";
         switch (event.data) {
             case 2: errorMessage = "再生リクエストが無効です。"; break;
             case 5: errorMessage = "プレイヤー内部のエラーが発生しました。"; break;
             case 100: errorMessage = "動画が見つからないか、削除されました。"; break;
             case 101: case 150: errorMessage = "この動画は埋め込み再生が許可されていません。"; break;
             default: errorMessage = `不明なエラーが発生しました (コード: ${event.data})。`;
         }
         showSnackbar(errorMessage);
         const playIcon = '<i class="fas fa-play"></i>';
         const playLabel = '再生';
         if (elements.btnPlay) {
            elements.btnPlay.innerHTML = playIcon;
            elements.btnPlay.setAttribute('aria-label', playLabel);
         }
         if (elements.btnPlayMobile) {
             elements.btnPlayMobile.innerHTML = playIcon;
             elements.btnPlayMobile.setAttribute('aria-label', playLabel);
         }
         appState.isPlaying = false;
         elements.nowPlayingBadge?.classList.add('hidden');
         stopProgressUpdate();
         if (appState.visualizer.animationFrameId !== null) {
            cancelAnimationFrame(appState.visualizer.animationFrameId);
            appState.visualizer.animationFrameId = null;
            if (appState.visualizer.canvasCtx && appState.visualizer.canvas) {
                 appState.visualizer.canvasCtx.clearRect(0, 0, appState.visualizer.canvas.width, appState.visualizer.canvas.height);
            }
         }
         resetPlayerInfo();
         updateNowPlayingBar();
     }

    // ==========================================================================
    // App Initialization Functions
    // ==========================================================================
    async function loadSongsFromYouTube() {
      showSkeletonLoader(elements.playlist, 5);
      try {
        const videos = await youtubeAPI.getLatestVideos(15);
        if (!videos || videos.length === 0) {
          showSnackbar("新しい動画は見つかりませんでした");
          showEmptyMessage(elements.playlist, "利用可能な楽曲はありません", "YouTubeチャンネルから新しい曲が追加されるのをお待ちください。", "fas fa-compact-disc");
          appState.songs = [];
          appState.filteredSongs = [];
          return;
        }
        const videoIds = videos.map(video => video.id.trim());
        const videoDetails = await youtubeAPI.getVideoDetails(videoIds);
        appState.songs = videos.map(video => {
          const details = videoDetails.find(detail => detail.id === video.id) || {};
          return {
            id: video.id.trim(),
            title: video.title,
            duration: details.duration || '--:--',
            thumbnail: video.thumbnail
          };
        });
        appState.filteredSongs = [...appState.songs];
        renderPlaylist();
      } catch (error) {
        console.error("動画データの取得または処理に失敗しました", error);
        showSnackbar("動画データの取得に失敗しました");
        showEmptyMessage(elements.playlist, "読み込みエラー", "曲の読み込み中にエラーが発生しました。時間をおいて再試行してください。", "fas fa-exclamation-triangle");
        appState.songs = [];
        appState.filteredSongs = [];
      }
    }


        // --- Skeleton Loading Functions ---
        function showSkeletonLoader(container, count = 5) {
        if (!container) return;
        let skeletonHTML = '';
        for (let i = 0; i < count; i++) {
            skeletonHTML += `
                <div class="skeleton-playlist-item" aria-hidden="true">
                  <div class="skeleton-item skeleton-thumb"></div>
                  <div class="skeleton-text-container">
                    <div class="skeleton-item skeleton-text"></div>
                    <div class="skeleton-item skeleton-text skeleton-text-short"></div>
                  </div>
                </div>
            `;
        }
        container.innerHTML = skeletonHTML;
    }

    function showEmptyMessage(container, title, message, iconClass = null, actionHTML = null) {
        if (!container) return;
        container.innerHTML = `
            <div class="empty-state-container">
                ${iconClass ? `<i class="empty-state-icon ${iconClass}"></i>` : ''}
                <h4 class="empty-state-title">${escapeHTML(title)}</h4>
                <p class="empty-state-message">${message}</p> <!-- Allow HTML in message for icons -->
                ${actionHTML ? `<div class="empty-state-action">${actionHTML}</div>` : ''}
            </div>
        `;
        if (actionHTML) {
            const actionButton = container.querySelector('.empty-state-action button');
            if (actionButton && actionButton.id === 'empty-state-create-playlist') {
                actionButton.addEventListener('click', showCreatePlaylistModal);
            }
            const loginLink = container.querySelector('#empty-state-login-link');
            loginLink?.addEventListener('click', (e) => {
                e.preventDefault();
                showAccountModal();
            });
        }
    }


    function loadUserData() {
    console.log("Loading user data from localStorage...");
    try {
        const storedHistory = localStorage.getItem(LS_KEYS.HISTORY);
        const storedFavorites = localStorage.getItem(LS_KEYS.FAVORITES);
        const storedPlaylists = localStorage.getItem(LS_KEYS.PLAYLISTS);
        const storedUser = localStorage.getItem(LS_KEYS.USER);
        const savedTheme = localStorage.getItem(LS_KEYS.THEME);
        const storedQueue = localStorage.getItem(LS_KEYS.QUEUE); // <<<====== [ADD] Load queue

        appState.history = storedHistory ? JSON.parse(storedHistory) : [];
        appState.favorites = storedFavorites ? JSON.parse(storedFavorites) : [];
        appState.userPlaylists = storedPlaylists ? JSON.parse(storedPlaylists) : [];
        appState.loggedInUser = storedUser ? JSON.parse(storedUser) : null;
        appState.queue = storedQueue ? JSON.parse(storedQueue) : []; // <<<====== [ADD] Initialize queue state

        // Note: Filtering invalid queue items might be better done after songs are loaded
        // or handled gracefully within renderQueueList.

        const isDark = savedTheme === 'dark';
        if(elements.body) elements.body.classList.toggle('dark', isDark);
        if(elements.themeToggle) {
            elements.themeToggle.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
            elements.themeToggle.classList.toggle('btn-active', isDark);
            elements.themeToggle.classList.toggle('btn-inactive', !isDark);
            elements.themeToggle.setAttribute('aria-pressed', isDark);
        }

        renderHistoryList();
        renderFavoritesList();
        renderUserPlaylists();
        // renderQueueList(); // <<<====== Moved to onPlayerReady after data is loaded

        updateAccountUI(!!appState.loggedInUser);
        console.log("User data loaded.");
    } catch(error) {
        console.error("Error loading user data:", error);
        showSnackbar("ユーザーデータの読み込みに失敗しました。");
        // Reset states on error
        appState.history = [];
        appState.favorites = [];
        appState.userPlaylists = [];
        appState.loggedInUser = null;
        appState.queue = []; // Reset queue on error
    }
}

    function initAudioAnalyser() {
      console.log("Initializing visualizer...");
      try {
        appState.visualizer.canvas = elements.visualizerCanvas;
        if (!appState.visualizer.canvas) {
            console.error("Visualizer canvas element not found.");
            return;
        }
        appState.visualizer.canvasCtx = appState.visualizer.canvas.getContext('2d');
        if (!appState.visualizer.canvasCtx) {
            console.error("Failed to get 2D context for visualizer canvas.");
            return;
        }
        appState.visualizer.bufferLength = 64;
        appState.visualizer.dataArray = new Uint8Array(appState.visualizer.bufferLength);
        console.log("Visualizer canvas and context obtained.");

        requestAnimationFrame(() => {
            try {
                 resizeCanvas();
                 console.log("Initial resizeCanvas called via requestAnimationFrame.");
            } catch(resizeError) {
                 console.error("Error during initial resizeCanvas call:", resizeError);
                 if(elements.visualizerCanvas) elements.visualizerCanvas.style.display = 'none';
            }
        });
      } catch (error) {
        console.error('Visualizer setup failed during init:', error);
        if(elements.visualizerCanvas) elements.visualizerCanvas.style.display = 'none';
      }
    }

    // ==========================================================================
    // Event Listener Setup
    // ==========================================================================
    function setupEventListeners() {
    console.log("Setting up event listeners...");

    // Player Controls (Desktop)
    elements.btnPlay?.addEventListener('click', togglePlayPause);
    elements.btnNext?.addEventListener('click', () => playNextSong()); // Pass () if playNextSong returns value
    elements.btnPrev?.addEventListener('click', playPreviousSong);
    elements.btnShuffle?.addEventListener('click', toggleShuffle);
    elements.btnLoop?.addEventListener('click', toggleLoopMode);
    elements.volumeSlider?.addEventListener('input', handleVolumeChange);
    elements.progressContainer?.addEventListener('click', seekToPosition);

    // Player Controls (Mobile)
    elements.btnPlayMobile?.addEventListener('click', togglePlayPause);
    elements.btnNextMobile?.addEventListener('click', () => playNextSong()); // Pass () if playNextSong returns value
    elements.btnPrevMobile?.addEventListener('click', playPreviousSong);
    elements.btnShuffleMobile?.addEventListener('click', toggleShuffle);
    elements.btnLoopMobile?.addEventListener('click', toggleLoopMode);

    // Header Controls
    elements.themeToggle?.addEventListener('click', toggleTheme);
    elements.searchInput?.addEventListener('input', handleSearch);
    elements.modalButtons.account?.addEventListener('click', showAccountModal);
    // elements.offlineMenuBtn?.addEventListener('click', () => offlinePlayback.showOfflineModal());

    // Action Buttons
    elements.shareBtn?.addEventListener('click', showShareModal);
    elements.openYouTubeBtn?.addEventListener('click', handleOpenYouTube);

    // Tab switching
    elements.tabs?.forEach(tab => {
        tab.addEventListener('click', () => switchTab(tab.dataset.tab));
        tab.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                switchTab(tab.dataset.tab);
            }
        });
    });

    // ---- Event Delegation for Lists (Includes Context Menu Listeners) ----
    setupListEventListeners(elements.playlist, handlePlaylistClick);
    setupListEventListeners(elements.historyList, handleHistoryClick);
    setupListEventListeners(elements.favoritesList, handleFavoritesClick);
    // setupListEventListeners(elements.userPlaylistsList, handleUserPlaylistsClick); // ← 委譲に統合するので削除
    setupListEventListeners(elements.playlistElements?.detailContent, handlePlaylistDetailClick);

    // === ↓↓↓ イベント委譲リスナーを追加 (User Playlists Tab) ↓↓↓ ===
    if (elements.userPlaylistsList) {
        elements.userPlaylistsList.addEventListener('click', (event) => {
            const target = event.target;
            const playlistItem = target.closest('.user-playlist-item');
            const playBtn = target.closest('.playlist-play-btn');
            const editBtn = target.closest('.playlist-edit-btn');
            const deleteBtn = target.closest('.playlist-delete-btn');
            const emptyCreateBtn = target.closest('#empty-state-create-playlist'); // 空状態の作成ボタンを探す

            if (playlistItem) { // 既存プレイリストアイテム内の操作
                const playlistId = playlistItem.dataset.id;
                if (playBtn) {
                    event.stopPropagation();
                    console.log("Play playlist button clicked (not implemented yet)");
                } else if (editBtn) {
                    event.stopPropagation();
                    viewPlaylist(playlistId);
                } else if (deleteBtn) {
                    event.stopPropagation();
                    deletePlaylist(playlistId);
                } else {
                    viewPlaylist(playlistId);
                }
            } else if (emptyCreateBtn) { // 空状態の作成ボタンがクリックされた場合
                event.preventDefault();
                showCreatePlaylistModal(); // モーダル表示関数を呼び出す
            }
        });

        // キーボード操作用のリスナーも委譲で追加
        elements.userPlaylistsList.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
                const target = event.target;
                const playlistItem = target.closest('.user-playlist-item');
                const emptyCreateBtn = target.closest('#empty-state-create-playlist');

                if (playlistItem) {
                     event.preventDefault();
                     viewPlaylist(playlistItem.dataset.id);
                } else if (emptyCreateBtn) {
                     event.preventDefault();
                     showCreatePlaylistModal();
                }
            }
        });
    } else {
        console.warn("User Playlists List element not found for event delegation.");
    }
    // === ↑↑↑ イベント委譲リスナーを追加 (User Playlists Tab) ↑↑↑ ===


    // --- Modal Close Buttons ---
    elements.modalCloseBtns?.forEach(btn => {
        btn.addEventListener('click', () => {
            const modalId = btn.dataset.modalId;
            if (modalId) hideModal(modalId);
            else console.error("Close button clicked, but data-modal-id is missing:", btn);
        });
    });

    // --- Modal Specific Action Buttons ---
    elements.modalButtons.savePlaylist?.addEventListener('click', saveNewPlaylist); // ← 保存ボタンのリスナーはここ
    elements.modalButtons.removeFromPlaylist?.addEventListener('click', removeSongFromPlaylist);
    elements.modalButtons.sharePlaylist?.addEventListener('click', sharePlaylist);
    elements.modalButtons.copyLink?.addEventListener('click', copyShareLink);

    // --- Account Modal Action Buttons ---
    elements.modalButtons.showRegister?.addEventListener('click', () => switchAuthSection('register'));
    elements.modalButtons.showLogin?.addEventListener('click', () => switchAuthSection('login'));
    elements.modalButtons.login?.addEventListener('click', handleLogin);
    elements.modalButtons.register?.addEventListener('click', handleRegister);
    elements.modalButtons.logout?.addEventListener('click', handleLogout);
    elements.modalButtons.syncData?.addEventListener('click', syncUserData);

    // --- Now Playing Bar Controls ---
    elements.btnPlayBar?.addEventListener('click', togglePlayPause);
    elements.btnPrevBar?.addEventListener('click', playPreviousSong);
    elements.btnNextBar?.addEventListener('click', () => playNextSong()); // Pass () if playNextSong returns value
    elements.volumeSliderBar?.addEventListener('input', handleVolumeChangeBar);
    elements.nowPlayingBarProgressContainer?.addEventListener('click', seekToPositionBar);

    // --- Context Menu Click Handler (Attached once globally) ---
    elements.contextMenu?.addEventListener('click', handleContextMenuAction);

    // --- Close Modals on Backdrop Click ---
    if (elements.modals) {
        Object.entries(elements.modals).forEach(([modalId, modal]) => {
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) hideModal(modalId);
                });
            }
        });
    }

    // --- Global Keydowns ---
    document.addEventListener('keydown', handleGlobalKeyDown);

    // --- Window Resize ---
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('resize', checkBottomControlsVisibility);

    console.log("Event listeners setup complete.");
}

    // Helper for setting up delegated event listeners on lists (Corrected)
    function setupListEventListeners(listElement, clickHandler) {
        if (!listElement) return;

        // --- Existing Click Handler ---
        listElement.addEventListener('click', clickHandler);

        // --- Context Menu (Right Click) ---
        listElement.addEventListener('contextmenu', (event) => {
            const listItem = event.target.closest('.playlist-item, .history-item, .favorite-item');
            if (listItem && listItem.dataset.id) {
                openContextMenu(event, listItem.dataset.id);
            } else {
                hideContextMenu();
            }
        });

        // --- Long Press (Touch Devices) ---
        listElement.addEventListener('touchstart', (event) => {
             if (event.touches.length !== 1) return;
             const listItem = event.target.closest('.playlist-item, .history-item, .favorite-item');
             if (listItem && listItem.dataset.id) {
                 if (appState.contextMenu.longPressTimer) clearTimeout(appState.contextMenu.longPressTimer);
                 appState.contextMenu.isLongPress = false;
                 appState.contextMenu.longPressTimer = setTimeout(() => {
                     appState.contextMenu.isLongPress = true;
                     if (navigator.vibrate) navigator.vibrate(50);
                      const touch = event.touches[0];
                      const pseudoEvent = {
                           clientX: touch.clientX,
                           clientY: touch.clientY,
                           preventDefault: () => {},
                           stopPropagation: () => {}
                      };
                     openContextMenu(pseudoEvent, listItem.dataset.id);
                 }, 700);
             }
        });

        const cancelLongPress = () => {
             if (appState.contextMenu.longPressTimer) {
                 clearTimeout(appState.contextMenu.longPressTimer);
                 appState.contextMenu.longPressTimer = null;
             }
        };
        listElement.addEventListener('touchmove', cancelLongPress);
        listElement.addEventListener('touchend', cancelLongPress);
        listElement.addEventListener('touchcancel', cancelLongPress);

        // Prevent default context menu on long press release if our menu was shown
        listElement.addEventListener('touchend', (event) => {
             if (appState.contextMenu.isLongPress) {
                 event.preventDefault();
                 appState.contextMenu.isLongPress = false;
             }
        });

        // NOTE: Listener for clicks on context menu items is now attached globally in setupEventListeners
    }


    // --- New Handlers for Bar Controls ---
    function handleVolumeChangeBar() {
        if(!elements.volumeSliderBar) return;
        const volume = parseInt(elements.volumeSliderBar.value);
        setVolume(volume);
        updateVolumeIcon(elements.volumeIconBar, volume);
    }

    function seekToPositionBar(event) {
        if (!appState.isPlayerReady || !currentSongId() || !elements.nowPlayingBarProgressContainer || !appState.player) return;
        const rect = elements.nowPlayingBarProgressContainer.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const clampedX = Math.max(0, Math.min(clickX, rect.width));
        if (rect.width <= 0) return;
        const percent = clampedX / rect.width;
        try {
            const duration = appState.player.getDuration();
            if (duration > 0) {
                const seekTime = duration * percent;
                appState.player.seekTo(seekTime, true);
                updateProgress();
            }
        } catch (error) {
            console.error("Error seeking on bar:", error);
            showSnackbar("シーク中にエラーが発生しました。");
         }
    }

     // Helper to update volume icon
     function updateVolumeIcon(iconElement, volume) {
         if (!iconElement) return;
         let iconClass = 'fa-volume-up'; // Default
         if (volume === 0) {
             iconClass = 'fa-volume-mute';
         } else if (volume < 50) {
             iconClass = 'fa-volume-down';
         }
         // Use regex to replace only the volume part of the class
         iconElement.className = iconElement.className.replace(/fa-volume-[\w-]+/, iconClass);
     }

    // ==========================================================================
    // Event Handlers for Delegated List Clicks (Keep existing handlers)
    // ==========================================================================
    function handlePlaylistClick(event) {
        // Don't handle right-clicks or long presses here
        if (event.button === 2 || appState.contextMenu.isLongPress) return;
        // ... rest of the existing handlePlaylistClick logic ...
        const target = event.target;
        const playlistItem = target.closest('.playlist-item');
        const favoriteBtn = target.closest('.favorite-btn');
        const addToPlaylistBtn = target.closest('.add-to-playlist-btn');
        const selectPlaylistLink = target.closest('.select-playlist');

        if (!playlistItem) {
            closeAllPlaylistDropdowns();
            return;
        }
        const songId = playlistItem.dataset.id;
        if (favoriteBtn) {
            event.stopPropagation();
            toggleFavorite(songId);
        } else if (addToPlaylistBtn) {
            event.stopPropagation();
            togglePlaylistDropdown(addToPlaylistBtn);
        } else if (selectPlaylistLink) {
            event.preventDefault();
            event.stopPropagation();
            const playlistId = selectPlaylistLink.dataset.playlistid;
            addSongToPlaylist(songId, playlistId);
            closeAllPlaylistDropdowns();
        } else {
            const originalIndex = findSongIndexById(songId);
            if (originalIndex !== -1) {
                playSong(originalIndex);
                closeAllPlaylistDropdowns();
            } else {
                console.warn("Song ID not found in appState.songs:", songId);
                showSnackbar("曲が見つかりませんでした。");
            }
        }
    }
    function handleHistoryClick(event) {
        if (event.button === 2 || appState.contextMenu.isLongPress) return;
        // ... rest of the existing handleHistoryClick logic ...
        const target = event.target;
        const historyItem = target.closest('.history-item');
        if (!historyItem) {
            closeAllPlaylistDropdowns();
            return;
        }
        const songId = historyItem.dataset.id;
        const favoriteBtn = target.closest('.favorite-btn');
        const addToPlaylistBtn = target.closest('.add-to-playlist-btn');
        const selectPlaylistLink = target.closest('.select-playlist');

        if (favoriteBtn) {
            event.stopPropagation();
            toggleFavorite(songId);
        } else if (addToPlaylistBtn) {
            event.stopPropagation();
            togglePlaylistDropdown(addToPlaylistBtn);
        } else if (selectPlaylistLink) {
            event.preventDefault();
            event.stopPropagation();
            addSongToPlaylist(songId, selectPlaylistLink.dataset.playlistid);
            closeAllPlaylistDropdowns();
        } else {
            const originalIndex = findSongIndexById(songId);
            if (originalIndex !== -1) playSong(originalIndex);
            else showSnackbar("曲が見つかりませんでした。");
            closeAllPlaylistDropdowns();
        }
    }
    function handleFavoritesClick(event) {
        if (event.button === 2 || appState.contextMenu.isLongPress) return;
        // ... rest of the existing handleFavoritesClick logic ...
         const target = event.target;
        const favoriteItem = target.closest('.favorite-item');
         if (!favoriteItem) {
            closeAllPlaylistDropdowns();
            return;
        }
        const songId = favoriteItem.dataset.id;
        const favoriteBtn = target.closest('.favorite-btn');
        const addToPlaylistBtn = target.closest('.add-to-playlist-btn');
        const selectPlaylistLink = target.closest('.select-playlist');

        if (favoriteBtn) {
            event.stopPropagation();
            toggleFavorite(songId);
        } else if (addToPlaylistBtn) {
            event.stopPropagation();
            togglePlaylistDropdown(addToPlaylistBtn);
        } else if (selectPlaylistLink) {
            event.preventDefault();
            event.stopPropagation();
            addSongToPlaylist(songId, selectPlaylistLink.dataset.playlistid);
            closeAllPlaylistDropdowns();
        } else {
            const originalIndex = findSongIndexById(songId);
            if (originalIndex !== -1) playSong(originalIndex);
            else showSnackbar("曲が見つかりませんでした。");
            closeAllPlaylistDropdowns();
        }
    }
    function handleUserPlaylistsClick(event) { // No context menu for this list currently
        // ... existing handleUserPlaylistsClick logic ...
         const target = event.target;
     const playlistItem = target.closest('.user-playlist-item');
     if (!playlistItem) {
         return;
     }
     const playlistId = playlistItem.dataset.id;
     const playBtn = target.closest('.playlist-play-btn');
     const editBtn = target.closest('.playlist-edit-btn');
     const deleteBtn = target.closest('.playlist-delete-btn');

     if (playBtn) {
         event.stopPropagation();
         // playPlaylist(playlistId);
     } else if (editBtn) {
         event.stopPropagation();
         viewPlaylist(playlistId);
     } else if (deleteBtn) {
         event.stopPropagation();
         deletePlaylist(playlistId);
     } else {
         viewPlaylist(playlistId);
     }
    }
    function handlePlaylistDetailClick(event) { // No context menu for this list currently
        if (event.button === 2) return; // Ignore right-click for now
        // ... existing handlePlaylistDetailClick logic ...
        const target = event.target;
          const playlistItem = target.closest('.playlist-item');
          if (!playlistItem) return;

          const songId = playlistItem.dataset.id;
          const favoriteBtn = target.closest('.favorite-btn');
          const checkbox = target.closest('.song-select');

          if (favoriteBtn) {
              event.stopPropagation();
              toggleFavorite(songId);
          } else if (checkbox) {
              event.stopPropagation();
          } else {
              const originalIndex = findSongIndexById(songId);
              if (originalIndex !== -1) {
                  playSong(originalIndex);
                  hideModal('playlistDetail');
              } else {
                  showSnackbar("曲が見つかりませんでした。");
              }
          }
    }

    // Helper to toggle playlist dropdown visibility
    function togglePlaylistDropdown(buttonElement) {
        if(!buttonElement) return;
        const dropdownContainer = buttonElement.closest('.dropdown');
        if (!dropdownContainer) return;
        const dropdownMenu = dropdownContainer.querySelector('.dropdown-menu');
        if (!dropdownMenu) return;
        const isHidden = dropdownMenu.classList.contains('hidden');
        closeAllPlaylistDropdowns();
        if (isHidden) {
            dropdownMenu.classList.remove('hidden');
             const firstLink = dropdownMenu.querySelector('a');
             firstLink?.focus();
        }
    }

    // Helper to close all open playlist dropdowns
    function closeAllPlaylistDropdowns(exceptButton = null) {
        document.querySelectorAll('.dropdown-menu').forEach(d => {
             const parentDropdown = d.closest('.dropdown');
             const triggerButton = parentDropdown?.querySelector('.add-to-playlist-btn');
             if (triggerButton !== exceptButton) {
                 d.classList.add('hidden');
             }
        });
    }

    // Global click listener to close dropdowns AND context menu
    document.addEventListener('click', (e) => {
        // Close dropdown if click is outside any element with class 'dropdown'
        if (!e.target.closest('.dropdown')) {
            closeAllPlaylistDropdowns();
        }
        // Close context menu handled by handleClickOutsideContextMenu
    }, true); // Use capture phase


    // ==========================================================================
    // Render UI Functions (renderList, renderPlaylist, etc. kept as before, using new showEmptyMessage)
    // ==========================================================================
    function renderPlaylist() {
      const items = appState.filteredSongs;
      const container = elements.playlist;
      if (!container) return;

      if (!items || items.length === 0) {
        if (elements.searchInput?.value) {
            showEmptyMessage(container,
                "検索結果なし",
                `「${escapeHTML(elements.searchInput.value)}」に一致する曲は見つかりませんでした。`,
                "fas fa-search"
            );
        } else {
             showEmptyMessage(container,
                 "楽曲がありません",
                 "YouTubeチャンネルから曲が読み込まれるのを待つか、同期ボタンを押してください。",
                 "fas fa-music"
             );
        }
        return;
    }
    renderList(
        container,
        items,
        'playlist-item',
        (song) => `data-id="${song.id}"`,
        true
    );
    updateActiveListItem();
}

function renderHistoryList() {
    const container = elements.historyList;
    if (!container) return;
    const itemsToRender = [...appState.history].reverse();

    if (itemsToRender.length === 0) {
        showEmptyMessage(container,
            "再生履歴なし",
            "まだ曲を再生していません。お好きな曲を再生してみてください！",
            "fas fa-history"
        );
        return;
    }
    renderList(
        container,
        itemsToRender,
        'history-item',
        (song) => `data-id="${song.id}"`,
        true
    );
    updateActiveListItem();
}

function renderFavoritesList() {
    const container = elements.favoritesList;
    if (!container) return;

    if (appState.favorites.length === 0) {
         showEmptyMessage(container,
             "お気に入りなし",
             "曲の隣にある <i class='fas fa-heart text-gray-400'></i> をクリックしてお気に入りを追加しましょう。", // Use icon in message
             "far fa-heart"
         );
         return;
    }
    renderList(
        container,
        appState.favorites,
        'favorite-item',
        (song) => `data-id="${song.id}"`,
        true
    );
    updateActiveListItem();
}

function renderList(container, items, itemClass, dataAttributeFn, showActions) {
    if (!container) return;

    const fragment = document.createDocumentFragment();
    const currentSongId = appState.currentSongIndex !== -1 && appState.songs[appState.currentSongIndex]
                          ? appState.songs[appState.currentSongIndex].id
                          : null;

    items.forEach((song, index) => {
        if (!song || !song.id) {
            console.warn("Invalid song data in list:", song);
            return;
        }
        const isActive = song.id === currentSongId;
        const isFavorite = appState.favorites.some(fav => fav && fav.id === song.id);
        // Hide action buttons if context menu is the primary interaction method? (Optional)
        // const shouldShowInlineActions = false; // Or keep them as fallback

        const div = document.createElement('div');
        div.className = `${itemClass} p-3 flex items-center justify-between cursor-pointer ${isActive ? 'active' : ''} focusable`;
        div.tabIndex = 0;
        const attr = dataAttributeFn(song, index);
        if (typeof attr === 'string' && attr.includes('=')) {
            const [key, value] = attr.split('=');
            div.dataset[key.replace('data-', '')] = value.replace(/"/g, '');
        } else {
            console.warn("Invalid data attribute format from dataAttributeFn");
        }

         div.addEventListener('keydown', (e) => {
             if (e.key === 'Enter' || e.key === ' ') {
                 e.preventDefault();
                 const songId = div.dataset.id;
                 const originalIndex = findSongIndexById(songId);
                 if (originalIndex !== -1) playSong(originalIndex);
             }
             // Add Shift+F10 or Menu key for context menu accessibility? (Advanced)
             // if (e.key === 'ContextMenu' || (e.key === 'F10' && e.shiftKey)) {
             //     e.preventDefault();
             //     openContextMenu(e, song.id); // Needs adjustment for keyboard event position
             // }
         });

        let playlistActionsHTML = '';
        if (showActions) { // Keep showing actions for now as fallback/alternative
            playlistActionsHTML = `
                <button class="favorite-btn text-lg mr-2 focusable" data-id="${song.id}" aria-label="${isFavorite ? 'お気に入り解除' : 'お気に入り登録'}">
                    <i class="fas fa-heart ${isFavorite ? 'text-red-500' : 'text-gray-400'}"></i>
                </button>
                ${appState.loggedInUser ? `
                <div class="dropdown relative inline-block">
                    <button class="add-to-playlist-btn text-lg mr-2 focusable ${appState.userPlaylists.length > 0 ? '' : 'opacity-50 cursor-not-allowed'}" data-id="${song.id}" ${appState.userPlaylists.length > 0 ? '' : 'disabled aria-disabled="true"'} aria-label="プレイリストに追加">
                        <i class="fas fa-plus"></i>
                    </button>
                    ${appState.userPlaylists.length > 0 ? `
                    <div class="dropdown-menu absolute right-0 mt-2 w-48 rounded-md shadow-lg hidden z-20" style="background-color: var(--card-color); border: 1px solid var(--border-color);">
                        <div class="py-1 max-h-32 overflow-y-auto">
                            ${appState.userPlaylists.map(playlist => `
                                <a href="#" class="block px-4 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 select-playlist focusable" data-id="${song.id}" data-playlistid="${playlist.id}">
                                    ${escapeHTML(playlist.name)} <span class="playlist-count">${playlist.songs?.length ?? 0}</span>
                                </a>
                            `).join('')}
                        </div>
                    </div>
                    ` : ''}
                </div>
                ` : ''}
            `;
        }

        div.innerHTML = `
            <div class="flex items-center overflow-hidden mr-2 flex-grow min-w-0">
                <div class="w-10 h-10 rounded overflow-hidden mr-3 flex-shrink-0">
                    <img src="${song.thumbnail || ''}" alt="${escapeHTML(song.title)}" class="w-full h-full object-cover" loading="lazy">
                </div>
                <div class="flex-grow overflow-hidden min-w-0">
                    <h3 class="text-sm font-medium truncate">${escapeHTML(song.title)}</h3>
                </div>
            </div>
            ${showActions ? `<div class="flex items-center flex-shrink-0 ml-2">${playlistActionsHTML}</div>` : ''}
        `;
        fragment.appendChild(div);
    });

    container.innerHTML = '';
    container.appendChild(fragment);
}


function renderUserPlaylists() {
    const container = elements.userPlaylistsList;
    if (!container) {
        console.error("User playlists container element not found.");
        return;
    }

    if (appState.userPlaylists.length === 0) {
        // ログイン状態に応じてボタンまたはログインリンクを表示
        const actionButtonHTML = appState.loggedInUser
            // ↓↓↓ ボタンに正しいIDとスタイルを設定 ↓↓↓
            ? `<button id="empty-state-create-playlist" class="focusable bg-primary-color text-white px-4 py-2 rounded-full hover:opacity-90 transition-opacity"><i class="fas fa-plus mr-1"></i> 新しいプレイリストを作成</button>`
            : '<p class="text-sm">プレイリストの作成には<a href="#" id="empty-state-login-link" class="text-primary-color hover:underline focusable">ログイン</a>が必要です。</p>';

        showEmptyMessage(container,
            "マイプレイリストなし",
            "自分だけのプレイリストを作成して、お気に入りの曲をまとめましょう。",
            "fas fa-list-ul",
            actionButtonHTML
        );
        // ログインリンクへのリスナー設定
        const loginLink = container.querySelector('#empty-state-login-link');
        loginLink?.addEventListener('click', (e) => {
            e.preventDefault();
            showAccountModal();
        });
        // !!! ボタンへのリスナーは委譲で処理するので、ここでは設定しない !!!
        return;
    }

    // --- 既存プレイリストのレンダリングロジック ---
    const fragment = document.createDocumentFragment();
    appState.userPlaylists.forEach(playlist => {
        const div = document.createElement('div');
        div.className = 'user-playlist-item p-3 flex items-center justify-between cursor-pointer focusable';
        div.dataset.id = playlist.id;
        div.tabIndex = 0;
        // キーボード操作用の個別のリスナーは削除 (委譲で対応)
        // div.addEventListener('keydown', ...);

        div.innerHTML = `
          <div class="flex-grow overflow-hidden mr-2 min-w-0"> <!-- Added min-w-0 -->
            <span class="font-medium truncate">${escapeHTML(playlist.name)}</span>
            <span class="playlist-count ml-1 md:ml-2 flex-shrink-0">${playlist.songs?.length ?? 0}</span> <!-- Adjusted margin -->
          </div>
          <div class="user-playlist-actions flex-shrink-0 flex items-center gap-2 md:gap-3"> <!-- Adjusted gap -->
             <button class="playlist-edit-btn text-lg text-gray-600 hover:text-primary-color dark:text-gray-400 dark:hover:text-primary-color focusable p-1" data-id="${playlist.id}" aria-label="${escapeHTML(playlist.name)} を表示/編集"><i class="fas fa-eye"></i></button> <!-- Added padding -->
             <button class="playlist-delete-btn text-lg text-red-500 hover:text-red-700 dark:hover:text-red-400 focusable p-1" data-id="${playlist.id}" aria-label="${escapeHTML(playlist.name)} を削除">
                 <i class="fas fa-trash"></i>
             </button> <!-- Added padding -->
          </div>
        `;
        fragment.appendChild(div);
    });

    container.innerHTML = '';
    container.appendChild(fragment);
}

    function renderPlaylistDetail(playlist) {
        if (!appState.songs || appState.songs.length === 0) {
            showSnackbar("楽曲リストの読み込みが完了していません。");
            const container = elements.playlistElements.detailContent;
            if (container) showEmptyMessage(container, "読み込み中...", "楽曲リストを読み込み中です...", "fas fa-spinner fa-spin");
            return;
        }

        const container = elements.playlistElements.detailContent;
        const titleEl = elements.playlistElements.detailTitle;
        const removeBtn = elements.modalButtons.removeFromPlaylist;
        if (!container || !titleEl || !removeBtn) {
            console.error("Playlist detail modal elements not found.");
            return;
        }
        if (!playlist || !playlist.id) {
            console.error("Invalid playlist object passed to renderPlaylistDetail:", playlist);
             showEmptyMessage(container, "エラー", "プレイリスト情報の取得に失敗しました。", "fas fa-exclamation-triangle");
             if(titleEl) titleEl.textContent = "プレイリストエラー";
             removeBtn.classList.add('hidden');
             return;
        }

        titleEl.textContent = escapeHTML(playlist.name);
        const currentlyPlayingSongId = currentSongId();
        const songsInPlaylist = (playlist.songs || [])
                                .map(songId => findSongById(songId))
                                .filter(song => song);

        if (songsInPlaylist.length === 0) {
            showEmptyMessage(container, "空のプレイリスト", "このプレイリストには曲が追加されていません。", "fas fa-folder-open");
            removeBtn.classList.add('hidden');
            return;
        }

        const fragment = document.createDocumentFragment();
        songsInPlaylist.forEach(song => {
            const isFavorite = appState.favorites.some(fav => fav && fav.id === song.id);
            const isActive = song.id === currentlyPlayingSongId;
            const div = document.createElement('div');
            div.className = `playlist-item p-3 flex items-center justify-between cursor-pointer ${isActive ? 'active' : ''} focusable`;
            div.dataset.id = song.id;
            div.tabIndex = 0;

            div.addEventListener('keydown', (e) => {
                 if (e.key === 'Enter' || e.key === ' ') {
                    if (!e.target.classList.contains('song-select')) {
                        e.preventDefault();
                        const songId = div.dataset.id;
                        const originalIndex = findSongIndexById(songId);
                        if (originalIndex !== -1) {
                             playSong(originalIndex);
                             hideModal('playlistDetail');
                        } else {
                             showSnackbar("曲が見つかりませんでした。");
                        }
                    }
                 }
             });

            div.innerHTML = `
                <div class="flex items-center overflow-hidden mr-2 flex-grow min-w-0">
                    <input type="checkbox" class="song-select mr-3 flex-shrink-0 focusable" data-id="${song.id}" aria-label="${escapeHTML(song.title)}を選択">
                    <div class="w-10 h-10 rounded overflow-hidden mr-3 flex-shrink-0">
                        <img src="${song.thumbnail || ''}" alt="${escapeHTML(song.title)}" class="w-full h-full object-cover" loading="lazy">
                    </div>
                    <div class="flex-grow overflow-hidden min-w-0">
                        <h3 class="text-sm font-medium truncate">${escapeHTML(song.title)}</h3>
                    </div>
                </div>
                <div class="flex items-center flex-shrink-0 ml-2">
                    <button class="favorite-btn text-lg mr-2 focusable" data-id="${song.id}" aria-label="${isFavorite ? 'お気に入り解除' : 'お気に入り登録'}">
                        <i class="fas fa-heart ${isFavorite ? 'text-red-500' : 'text-gray-400'}"></i>
                    </button>
                </div>
            `;
            fragment.appendChild(div);
        });

        container.innerHTML = '';
        container.appendChild(fragment);
        removeBtn.classList.remove('hidden');
    }

    // ==========================================================================
    // Player Control Functions (Keep existing functions)
    // ==========================================================================
    function playSong(originalIndex, keepQueueMode = false) { // Add optional parameter
    // Add a check for elements existence, though should be fine if called after onPlayerReady
    if (!elements.currentSongTitle || !elements.currentSongDuration) {
        console.error("Cannot play song: Title or Duration element not found.");
        return;
    }
    if (!appState.isPlayerReady) {
      showSnackbar("プレイヤーの準備ができていません。");
      return;
    }

    // --- Queue Mode Logic ---
    const songToPlay = appState.songs[originalIndex];
    if (!songToPlay) {
        console.error("Invalid originalIndex for playSong:", originalIndex);
        return;
    }

    if (!keepQueueMode) {
        // If not explicitly keeping queue mode, check if the song played matches the *next logical* queue item
        const isNextInQueue = appState.playMode === 'queue' &&
                              appState.currentQueueIndex >= -1 && // Allow -1 (meaning queue was playing, now first item)
                              (appState.currentQueueIndex + 1 < appState.queue.length) &&
                              appState.queue[appState.currentQueueIndex + 1] === songToPlay.id;

        if (!isNextInQueue) {
             // If playing a song explicitly from a list (not the next in queue sequence)
             console.log("Explicit play action, resetting queue mode (unless keepQueueMode is true).");
             appState.playMode = 'playlist';
             appState.currentQueueIndex = -1;
        } else {
             // If it *is* the next in queue, update the index
              appState.currentQueueIndex++;
              console.log("Playing next song in queue sequence, updated index to:", appState.currentQueueIndex);
        }
    } else {
        // keepQueueMode is true, we are likely playing *from* the queue click/action
        // Ensure currentQueueIndex matches the played song if keepQueueMode is true
         const indexInQueue = appState.queue.findIndex(id => id === songToPlay.id);
         if (indexInQueue !== -1) {
             // Use the index from the data array, which playFromQueue should have set
             // If playFromQueue didn't set it correctly, this ensures it aligns.
             appState.currentQueueIndex = indexInQueue;
         } else {
             // Song played with keepQueueMode=true is not in queue? Revert to playlist mode.
             console.warn("keepQueueMode was true, but played song not found in queue. Reverting to playlist mode.");
             appState.playMode = 'playlist';
             appState.currentQueueIndex = -1;
         }
         console.log("Keeping queue mode. Current index:", appState.currentQueueIndex);
    }
    // --- End Queue Mode Logic ---


    if (originalIndex >= 0 && originalIndex < appState.songs.length) {
      appState.currentSongIndex = originalIndex; // Update the main song index
      const cleanVideoId = songToPlay.id.trim();
      elements.currentSongTitle.textContent = songToPlay.title;
      elements.currentSongDuration.textContent = songToPlay.duration || '--:--';
      try {
        if (appState.player && typeof appState.player.loadVideoById === 'function') {
          console.log(`Loading video: ${cleanVideoId} (${songToPlay.title})`);
          appState.player.loadVideoById(cleanVideoId);
        } else { throw new Error("Player or loadVideoById not available."); }
      } catch (error) {
        console.error("Error loading video:", error);
        showSnackbar("動画の読み込みに失敗しました。");
        resetPlayerInfo();
        return;
      }
      updateActiveListItem(); // Highlight in main lists
      updateNowPlayingBar();
      renderQueueList(); // <<<====== [ADD/CONFIRM] Update queue highlighting when song changes
      if(elements.shareBtn) elements.shareBtn.disabled = true; // Disable initially, enable on play
      if(elements.openYouTubeBtn) elements.openYouTubeBtn.disabled = false; // Enable immediately if song ID is known
    } else {
      console.warn("Invalid song index requested:", originalIndex);
    }
}
    function togglePlayPause() {
        if (!appState.isPlayerReady || !appState.player) {
            showSnackbar("プレイヤーが利用できません。");
            return;
        }
        const currentId = currentSongId();
        if (!currentId) {
            if(appState.songs.length > 0) playSong(0);
            else showSnackbar("再生する曲がありません。");
            return;
        }
        try {
            const playerState = appState.player.getPlayerState();
            if (playerState === YT.PlayerState.PLAYING) appState.player.pauseVideo();
            else appState.player.playVideo();
        } catch (error) {
            console.error("Error toggling play/pause:", error);
            showSnackbar("再生/一時停止中にエラーが発生しました。");
        }
    }
    function playNextSong() {
    if (appState.songs.length === 0 && appState.queue.length === 0) return false; // Nothing to play

    let nextSongId = null;
    let nextOriginalIndex = -1; // Keep track of the index too

    // --- Queue Logic ---
    if (appState.playMode === 'queue' && appState.queue.length > 0) {
        console.log("Queue mode: Playing next from queue.");
        const nextQueueIndex = appState.currentQueueIndex + 1;
        if (nextQueueIndex < appState.queue.length) {
            // Play next song in the queue
            appState.currentQueueIndex = nextQueueIndex;
            nextSongId = appState.queue[appState.currentQueueIndex];
        } else {
            // Reached end of the queue
            console.log("Reached end of queue.");
            showSnackbar("キューの再生が終了しました");
            appState.playMode = 'playlist';
            appState.currentQueueIndex = -1;
            // --- Decide what to do after queue ends ---
            // Option 1: Stop playback
            // return false; // Stop here

            // Option 2: Continue with playlist/shuffle (if loopMode === 'all')
            if (appState.loopMode === 'all') {
                 // Fallback to playing next from the original playlist context
                 const lastPlayedQueueSongId = appState.queue[appState.queue.length - 1];
                 const lastPlayedOriginalIndex = findSongIndexById(lastPlayedQueueSongId);
                 const baseIndex = (lastPlayedOriginalIndex !== -1) ? lastPlayedOriginalIndex : appState.currentSongIndex;

                 if (appState.isShuffle) { /* ... shuffle logic ... */
                     if (appState.songs.length <= 1) { nextOriginalIndex = 0; }
                     else { do { nextOriginalIndex = Math.floor(Math.random() * appState.songs.length); } while (nextOriginalIndex === baseIndex && appState.songs.length > 1); }
                     nextSongId = appState.songs[nextOriginalIndex]?.id;
                 } else { /* ... playlist logic ... */
                     nextOriginalIndex = (baseIndex + 1) % appState.songs.length;
                     nextSongId = appState.songs[nextOriginalIndex]?.id;
                 }
                 console.log("Queue ended, looping all, falling back to playlist/shuffle. Next ID:", nextSongId);
            } else {
                 // loopMode is 'none', stop after queue ends
                 return false; // Indicate playback stopped
            }
        }
    // --- Playlist/Shuffle Logic (also handles first play from queue if needed) ---
    } else if (appState.playMode === 'playlist' && appState.queue.length > 0 && appState.currentQueueIndex === -1) {
         // Playlist mode, but queue has items and queue wasn't actively playing -> Start Queue
         console.log("Playlist mode, but queue exists. Starting queue playback.");
         appState.playMode = 'queue';
         appState.currentQueueIndex = 0;
         nextSongId = appState.queue[appState.currentQueueIndex];
    } else {
         // Playlist/Shuffle mode (no queue involved or queue finished)
         console.log("Playlist/Shuffle mode: Playing next.");
         const currentIndex = appState.currentSongIndex;
         if (currentIndex === -1) { /* ... logic for nothing playing ... */
             nextOriginalIndex = 0; // Play first song
             nextSongId = appState.filteredSongs[nextOriginalIndex]?.id || appState.songs[nextOriginalIndex]?.id;
         } else if (appState.isShuffle) { /* ... shuffle logic ... */
             if (appState.songs.length <= 1) { nextOriginalIndex = 0; }
             else { do { nextOriginalIndex = Math.floor(Math.random() * appState.songs.length); } while (nextOriginalIndex === currentIndex && appState.songs.length > 1); }
             nextSongId = appState.songs[nextOriginalIndex]?.id;
         } else { /* ... playlist logic (using filteredSongs) ... */
             const currentFilteredIndex = appState.filteredSongs.findIndex(s => s.id === appState.songs[currentIndex]?.id);
             let nextFilteredIndex = -1;
             if (currentFilteredIndex !== -1) { nextFilteredIndex = (currentFilteredIndex + 1); }
             else { nextFilteredIndex = (currentIndex + 1); } // Fallback to original index

             // Check if looping is off and we reached the end
              const isEndOfContext = (appState.loopMode === 'none') && (
                  (currentFilteredIndex !== -1 && nextFilteredIndex >= appState.filteredSongs.length) ||
                  (currentFilteredIndex === -1 && nextFilteredIndex >= appState.songs.length)
              );

             if (isEndOfContext) {
                 console.log("Reached end of playlist/filtered list (loop none). Stopping.");
                 resetPlayerInfo(); // Reset UI immediately
                 return false; // Indicate playback stopped
             }

             // Determine the actual index (wrapping around if needed)
             if (currentFilteredIndex !== -1) {
                 nextFilteredIndex = nextFilteredIndex % appState.filteredSongs.length;
                 nextSongId = appState.filteredSongs[nextFilteredIndex]?.id;
             } else {
                 nextOriginalIndex = nextFilteredIndex % appState.songs.length;
                 nextSongId = appState.songs[nextOriginalIndex]?.id;
             }
         }
    }

    // --- Final Play Action ---
    if (nextSongId) {
         if (nextOriginalIndex === -1) { // Find index if not already determined
             nextOriginalIndex = findSongIndexById(nextSongId);
         }

        if (nextOriginalIndex !== -1) {
             // Pass keepQueueMode=true only if we are *continuing* queue playback
             const keepMode = appState.playMode === 'queue';
            playSong(nextOriginalIndex, keepMode);
            return true; // Indicate successful playback start
        } else {
            console.error("Could not find original index for next song ID:", nextSongId);
            appState.playMode = 'playlist'; // Reset state on error
            appState.currentQueueIndex = -1;
            renderQueueList(); // Update UI on error
            return false; // Indicate failure
        }
    } else {
         console.log("No next song could be determined (likely end of list with loop none).");
         resetPlayerInfo(); // Ensure UI is reset
         return false; // Indicate playback stopped
    }
}

    function playPreviousSong() {
        if (appState.songs.length === 0 && appState.queue.length === 0) return;

        // Always try to restart current song if played > 3 seconds, regardless of mode
        try {
            if (appState.isPlayerReady && appState.player && typeof appState.player.getCurrentTime === 'function' && appState.player.getCurrentTime() > 3) {
                 console.log("Restarting current song.");
                appState.player.seekTo(0);
                return;
            }
        } catch (error) {
            console.warn("Could not get current time for previous song logic:", error);
        }

        let prevSongId = null;

        if (appState.playMode === 'queue' && appState.queue.length > 0) {
            // Playing from queue
             console.log("Queue mode: Playing previous from queue.");
             const prevQueueIndex = appState.currentQueueIndex - 1;
             if (prevQueueIndex >= 0) {
                 // Play previous song in the queue
                 appState.currentQueueIndex = prevQueueIndex;
                 prevSongId = appState.queue[appState.currentQueueIndex];
             } else {
                 // Reached beginning of the queue - Stop? Or play previous from playlist?
                 console.log("Reached beginning of queue. Stopping or falling back?");
                  // Option 1: Stop or do nothing
                  // prevSongId = null;
                  // Option 2: Fallback to playlist previous (more complex)
                   appState.playMode = 'playlist';
                   appState.currentQueueIndex = -1;
                   showSnackbar("キューの先頭です");
                  // Fallback to previous from original playlist context
                  const firstQueueSongId = appState.queue[0];
                  const firstPlayedOriginalIndex = findSongIndexById(firstQueueSongId);
                  const baseIndex = (firstPlayedOriginalIndex !== -1) ? firstPlayedOriginalIndex : appState.currentSongIndex;

                   if (appState.isShuffle) { // Find a random different one
                         if (appState.songs.length <= 1) {
                            const originalIndex = 0;
                            prevSongId = appState.songs[originalIndex]?.id;
                         } else {
                             let prevOriginalIndex;
                             do {
                                prevOriginalIndex = Math.floor(Math.random() * appState.songs.length);
                             } while (prevOriginalIndex === baseIndex && appState.songs.length > 1);
                              prevSongId = appState.songs[prevOriginalIndex]?.id;
                         }
                    } else { // Find previous in original list order
                        let prevOriginalIndex = baseIndex - 1;
                        if (prevOriginalIndex < 0) {
                            prevOriginalIndex = appState.songs.length - 1; // Loop to end
                        }
                         prevSongId = appState.songs[prevOriginalIndex]?.id;
                    }
                    console.log("Falling back to playlist/shuffle. Prev ID:", prevSongId);
             }

        } else {
            // No queue involved, play previous from playlist/shuffle
             console.log("Playlist/Shuffle mode: Playing previous.");
             const currentIndex = appState.currentSongIndex;
             if (currentIndex === -1) {
                 // Nothing playing, maybe play last song? Or first? Let's play first for consistency.
                  prevSongId = appState.filteredSongs[0]?.id || appState.songs[0]?.id;
             } else if (appState.isShuffle) {
                 if (appState.songs.length <= 1) {
                     const originalIndex = 0;
                     prevSongId = appState.songs[originalIndex]?.id;
                 } else {
                     let prevOriginalIndex;
                     do {
                        prevOriginalIndex = Math.floor(Math.random() * appState.songs.length);
                     } while (prevOriginalIndex === currentIndex && appState.songs.length > 1);
                     prevSongId = appState.songs[prevOriginalIndex]?.id;
                 }
             } else {
                 // Find previous song in the *currently filtered* list if possible
                 const currentFilteredIndex = appState.filteredSongs.findIndex(s => s.id === appState.songs[currentIndex].id);
                  let prevFilteredIndex = -1;
                  if (currentFilteredIndex !== -1) {
                      prevFilteredIndex = currentFilteredIndex - 1;
                      if (prevFilteredIndex < 0) {
                          prevFilteredIndex = appState.filteredSongs.length - 1; // Loop to end
                      }
                  } else {
                     // Fallback to original list logic
                     let prevOriginalIndex = currentIndex - 1;
                     if (prevOriginalIndex < 0) {
                         prevOriginalIndex = appState.songs.length - 1;
                     }
                      prevSongId = appState.songs[prevOriginalIndex]?.id; // Get ID directly
                  }
                  if (!prevSongId && prevFilteredIndex !== -1) { // If ID not set by fallback
                    prevSongId = appState.filteredSongs[prevFilteredIndex]?.id;
                  }
             }
        }

        // Finally, play the determined previous song ID
        if (prevSongId) {
            const prevOriginalIndex = findSongIndexById(prevSongId);
            if (prevOriginalIndex !== -1) {
                playSong(prevOriginalIndex);
            } else {
                console.error("Could not find original index for previous song ID:", prevSongId);
                appState.playMode = 'playlist'; // Reset state on error
                appState.currentQueueIndex = -1;
            }
        } else {
            console.log("No previous song could be determined.");
        }
    }
    function handleSongEnd() {
    console.log("Song ended. Loop mode:", appState.loopMode, "Play mode:", appState.playMode);
    let nextActionTaken = false; // Flag to check if next song was played

    // --- Handle Loop One ---
    if (appState.loopMode === 'one') {
        if(appState.player && typeof appState.player.seekTo === 'function' && typeof appState.player.playVideo === 'function') {
            try {
                appState.player.seekTo(0);
                appState.player.playVideo();
                console.log("Looping one song.");
                nextActionTaken = true;
                // No need to call renderQueueList here, the playing item remains the same
                return; // Don't proceed further if looping one
            } catch(e){
                console.error("Error restarting song for loop one:", e);
                // Fall through to play next if loop one fails
            }
        }
    }

    // --- Determine Next Song (Queue or Playlist/Shuffle) ---
    // playNextSong handles the logic of queue vs playlist/shuffle/loop
    // In 'all' mode, always play next.
    // In 'none' mode, play next UNLESS it was the very last song in the context.
    if (appState.loopMode === 'all' || appState.loopMode === 'none') {
        console.log(`Song ended, loopMode=${appState.loopMode}. Calling playNextSong.`);
        // playNextSong will return true if it successfully starts the next song, false otherwise (e.g., end of list with loop none)
        const didPlayNext = playNextSong(); // Call playNextSong to handle the logic
        nextActionTaken = didPlayNext; // Update flag based on result
    }

    // --- Final UI Update ---
    // Render the queue list after a song ends to reflect any potential change
    // in highlighting or if the queue was cleared/mode switched.
    if (!nextActionTaken) {
         // If no next action was taken (e.g., loop none and last song, or error in playNextSong)
         resetPlayerInfo(); // Ensure UI reflects the stopped state
         console.log("Playback stopped (end of list/queue or error).");
    }
    // Always call renderQueueList to update highlighting or show empty state
    renderQueueList();
}

    
    function toggleShuffle() {
      appState.isShuffle = !appState.isShuffle;
      const isActive = appState.isShuffle;
      elements.btnShuffle?.classList.toggle('btn-active', isActive);
      elements.btnShuffle?.classList.toggle('btn-inactive', !isActive);
      elements.btnShuffle?.setAttribute('aria-pressed', isActive);
       elements.btnShuffleMobile?.classList.toggle('btn-active', isActive);
       elements.btnShuffleMobile?.classList.toggle('btn-inactive', !isActive);
       elements.btnShuffleMobile?.setAttribute('aria-pressed', isActive);
      showSnackbar(`シャッフル: ${isActive ? 'オン' : 'オフ'}`);
    }
    function toggleLoopMode() {
      let loopIconHTML = ''; let loopLabel = ''; let isActive = true;
      switch (appState.loopMode) {
        case 'none': appState.loopMode = 'all'; loopIconHTML = '<i class="fas fa-repeat"></i>'; loopLabel = 'リピート: 全曲'; break;
        case 'all': appState.loopMode = 'one'; loopIconHTML = '<i class="fas fa-repeat-1" style="position: relative;"><span class="text-xs absolute -top-1 -right-1 bg-white text-black rounded-full px-1" style="font-family: sans-serif; line-height: 1;">1</span></i>'; loopLabel = 'リピート: 1曲'; break;
        case 'one': default: appState.loopMode = 'none'; loopIconHTML = '<i class="fas fa-repeat"></i>'; loopLabel = 'リピート: オフ'; isActive = false; break;
      }
        if (elements.btnLoop) { elements.btnLoop.innerHTML = loopIconHTML; elements.btnLoop.classList.toggle('btn-active', isActive); elements.btnLoop.classList.toggle('btn-inactive', !isActive); elements.btnLoop.setAttribute('aria-label', loopLabel); }
        if (elements.btnLoopMobile) { elements.btnLoopMobile.innerHTML = loopIconHTML; elements.btnLoopMobile.classList.toggle('btn-active', isActive); elements.btnLoopMobile.classList.toggle('btn-inactive', !isActive); elements.btnLoopMobile.setAttribute('aria-label', loopLabel); }
      showSnackbar(loopLabel);
    }
    function handleVolumeChange() { if(!elements.volumeSlider) return; const volume = parseInt(elements.volumeSlider.value); setVolume(volume); }
     function setVolume(volume) {
         volume = Math.max(0, Math.min(100, volume)); appState.volume = volume;
         if(elements.volumeSlider) elements.volumeSlider.value = volume;
         if(elements.volumeSliderBar) elements.volumeSliderBar.value = volume;
         if (appState.isPlayerReady && appState.player && typeof appState.player.setVolume === 'function') { try { appState.player.setVolume(volume); } catch (e) { console.error("Error setting volume:", e); } }
         updateVolumeIcon(elements.volumeIconBar, volume);
     }
    function adjustVolume(delta) { setVolume(appState.volume + delta); }
    function seekToPosition(event) {
        if (!appState.isPlayerReady || !currentSongId() || !elements.progressContainer || !appState.player) return;
        const rect = elements.progressContainer.getBoundingClientRect(); const clickX = event.pageX - rect.left - window.scrollX;
        const clampedX = Math.max(0, Math.min(clickX, rect.width)); if (rect.width <= 0) return; const percent = clampedX / rect.width;
        try { const duration = appState.player.getDuration(); if (duration > 0) { const seekTime = duration * percent; appState.player.seekTo(seekTime, true); updateProgress(); }
        } catch (error) { console.error("Error seeking:", error); showSnackbar("シーク中にエラーが発生しました。"); }
    }
     function seekRelative(deltaSeconds) {
         if (!appState.isPlayerReady || !currentSongId() || !appState.player) return;
         try { const currentTime = appState.player.getCurrentTime(); const duration = appState.player.getDuration(); if (duration > 0) { let seekTime = currentTime + deltaSeconds; seekTime = Math.max(0, Math.min(seekTime, duration)); appState.player.seekTo(seekTime, true); updateProgress(); }
         } catch (error) { console.error("Error seeking relative:", error); }
     }
    function startProgressUpdate() { stopProgressUpdate(); if (!appState.progressInterval) { appState.progressInterval = setInterval(updateProgress, 250); } updateProgress(); }
    function stopProgressUpdate() { if (appState.progressInterval) { clearInterval(appState.progressInterval); appState.progressInterval = null; } }
    function updateProgress() {
        const progressBar = elements.progressBar; const currentTimeEl = elements.currentTime; const totalTimeEl = elements.totalTime;
        if (!progressBar || !currentTimeEl || !totalTimeEl) return; const song = currentSongData();
        if (!appState.isPlayerReady || !appState.player || typeof appState.player.getCurrentTime !== 'function' || !song) {
            if (progressBar.style.width !== '0%') progressBar.style.width = '0%'; currentTimeEl.textContent = '00:00'; totalTimeEl.textContent = song?.duration && song.duration !== '--:--' ? song.duration : '00:00'; if(elements.currentSongDuration) { elements.currentSongDuration.textContent = song?.duration || '--:--'; }
             updateNowPlayingBar(); return;
        }
        try { const currentTime = appState.player.getCurrentTime(); const duration = appState.player.getDuration();
            if (typeof currentTime === 'number' && typeof duration === 'number' && duration > 0) {
                const percent = Math.min(100, Math.max(0, (currentTime / duration) * 100)); if (!isNaN(percent)) { progressBar.style.width = `${percent}%`; } else { if (progressBar.style.width !== '0%') progressBar.style.width = '0%'; }
                currentTimeEl.textContent = formatTime(currentTime); const formattedDuration = formatTime(duration);
                if (totalTimeEl.textContent !== formattedDuration || (song && song.duration === '--:--')) {
                     totalTimeEl.textContent = formattedDuration; if(elements.currentSongDuration) elements.currentSongDuration.textContent = formattedDuration; if (song && song.duration === '--:--') { song.duration = formattedDuration; }
                }
            } else {
                 if (progressBar.style.width !== '0%') progressBar.style.width = '0%'; currentTimeEl.textContent = '00:00'; const knownDuration = song?.duration && song.duration !== '--:--' ? song.duration : '00:00'; if(totalTimeEl.textContent !== knownDuration) totalTimeEl.textContent = knownDuration; if(elements.currentSongDuration && elements.currentSongDuration.textContent !== (song?.duration || '--:--')) { elements.currentSongDuration.textContent = song?.duration || '--:--'; }
            }
            updateNowPlayingBar();
        } catch (error) { if (progressBar.style.width !== '0%') progressBar.style.width = '0%'; currentTimeEl.textContent = '00:00'; totalTimeEl.textContent = '00:00'; if(elements.currentSongDuration) elements.currentSongDuration.textContent = '--:--'; stopProgressUpdate(); updateNowPlayingBar(); }
    }
     function resetPlayerInfo() {
         if(elements.currentSongTitle) elements.currentSongTitle.textContent = "選択された曲はありません"; if(elements.currentSongDuration) elements.currentSongDuration.textContent = "--:--"; if(elements.progressBar) elements.progressBar.style.width = '0%'; if(elements.currentTime) elements.currentTime.textContent = "00:00"; if(elements.totalTime) elements.totalTime.textContent = "00:00"; if(elements.shareBtn) elements.shareBtn.disabled = true; if(elements.openYouTubeBtn) elements.openYouTubeBtn.disabled = true; if(elements.nowPlayingBadge) elements.nowPlayingBadge.classList.add('hidden'); updateActiveListItem(); updateNowPlayingBar();
     }

    // ==========================================================================
    // Now Playing Bar Update Function (Keep existing)
    // ==========================================================================
    function updateNowPlayingBar() {
        const song = currentSongData(); const isVisible = !!song;
        if (appState.isBarVisible !== isVisible) { appState.isBarVisible = isVisible; elements.nowPlayingBar?.classList.toggle('active', isVisible); elements.body?.classList.toggle('has-now-playing-bar', isVisible); }
        if (isVisible && song && elements.nowPlayingBar) {
            if (elements.nowPlayingBarThumb) { elements.nowPlayingBarThumb.src = song.thumbnail || ''; elements.nowPlayingBarThumb.alt = song.title || 'Album Art'; }
            if(elements.nowPlayingBarTitle) elements.nowPlayingBarTitle.textContent = song.title || '不明なタイトル'; if(elements.nowPlayingBarArtist) elements.nowPlayingBarArtist.textContent = 'Rei Kikuchi';
             const playIconBar = elements.btnPlayBar?.querySelector('i'); if (playIconBar) { playIconBar.className = `fas ${appState.isPlaying ? 'fa-pause' : 'fa-play'} text-xl`; } if(elements.btnPlayBar) elements.btnPlayBar.setAttribute('aria-label', appState.isPlaying ? '一時停止' : '再生');
            if(elements.nowPlayingBarProgress && appState.player) { try { const currentTime = appState.player.getCurrentTime(); const duration = appState.player.getDuration(); if (typeof currentTime === 'number' && typeof duration === 'number' && duration > 0) { const percent = Math.min(100, Math.max(0, (currentTime / duration) * 100)); elements.nowPlayingBarProgress.style.width = `${percent}%`; } else { elements.nowPlayingBarProgress.style.width = '0%'; } } catch(e) { elements.nowPlayingBarProgress.style.width = '0%'; } }
             if(elements.volumeSliderBar) elements.volumeSliderBar.value = appState.volume; updateVolumeIcon(elements.volumeIconBar, appState.volume);
        } else if (!isVisible && elements.nowPlayingBar) {
             if(elements.nowPlayingBarTitle) elements.nowPlayingBarTitle.textContent = '曲が選択されていません'; if(elements.nowPlayingBarThumb) elements.nowPlayingBarThumb.src = ''; if(elements.nowPlayingBarProgress) elements.nowPlayingBarProgress.style.width = '0%'; const playIconBar = elements.btnPlayBar?.querySelector('i'); if (playIconBar) playIconBar.className = 'fas fa-play text-xl'; if(elements.btnPlayBar) elements.btnPlayBar.setAttribute('aria-label', '再生');
        }
    }

    // ==========================================================================
    // Playlist Functions (Keep existing)
    // ==========================================================================
    // 既存の showCreatePlaylistModal 関数を確認 (おそらく変更不要)
    function showCreatePlaylistModal() {
    // ログインチェック
    if (!appState.loggedInUser) {
        showAccountModal(); // アカウントモーダルを表示
        showSnackbar('プレイリスト作成にはログインが必要です');
        return; // 未ログインならここで終了
    }
    // ログイン済みならモーダル表示
    if(elements.playlistElements.nameInput) {
        elements.playlistElements.nameInput.value = ''; // 入力欄をクリア
    } else {
        console.error("Playlist name input element not found in 'elements'.");
        return; // 入力欄が見つからない場合は中断
    }
    // モーダルを表示し、入力欄にフォーカス
    showModal('createPlaylist', elements.playlistElements.nameInput);
}
function saveNewPlaylist() {
    if(!elements.playlistElements.nameInput) {
        console.error("Save cancelled: Playlist name input element not found.");
        return;
    }
    const name = elements.playlistElements.nameInput.value.trim();
    if (!name) {
        showSnackbar('プレイリスト名を入力してください');
        elements.playlistElements.nameInput.focus(); // 入力欄にフォーカスを戻す
        return; // 名前が空ならここで終了
    }
    // 新しいプレイリストオブジェクトを作成
    const newPlaylist = {
        id: `pl_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`,
        name: name,
        songs: [], // 最初は空
        created: new Date().toISOString() // 作成日時
    };
    // 状態に追加
    appState.userPlaylists.push(newPlaylist);
    saveUserPlaylists(); // ローカルストレージに保存
    renderUserPlaylists(); // マイプレイリストタブを再描画
    // 他のリスト（メイン、履歴、お気に入り）のドロップダウンも更新するために再描画
    renderPlaylist();
    renderHistoryList();
    renderFavoritesList();
    hideModal('createPlaylist'); // モーダルを閉じる
    showSnackbar(`プレイリスト「${escapeHTML(name)}」を作成しました`);
}
    function deletePlaylist(playlistId) { const playlistIndex = appState.userPlaylists.findIndex(p => p && p.id === playlistId); if (playlistIndex === -1) return; const playlist = appState.userPlaylists[playlistIndex]; if (confirm(`プレイリスト「${escapeHTML(playlist.name)}」を削除してもよろしいですか？`)) { appState.userPlaylists.splice(playlistIndex, 1); saveUserPlaylists(); renderUserPlaylists(); renderPlaylist(); renderHistoryList(); renderFavoritesList(); if (appState.currentSelectedPlaylistId === playlistId) { hideModal('playlistDetail'); appState.currentSelectedPlaylistId = null; } showSnackbar(`プレイリスト「${escapeHTML(playlist.name)}」を削除しました`); } }
    function addSongToPlaylist(songId, playlistId) { const playlist = appState.userPlaylists.find(p => p && p.id === playlistId); const song = findSongById(songId); if (!playlist || !song) { console.error("Playlist or Song not found for adding:", playlistId, songId); showSnackbar("プレイリストまたは曲が見つかりません。"); return; } if (!playlist.songs) playlist.songs = []; if (!playlist.songs.includes(songId)) { playlist.songs.push(songId); saveUserPlaylists(); renderUserPlaylists(); if (appState.currentSelectedPlaylistId === playlistId && elements.modals.playlistDetail?.classList.contains('show')) { renderPlaylistDetail(playlist); } renderPlaylist(); renderHistoryList(); renderFavoritesList(); showSnackbar(`「${escapeHTML(song.title)}」を「${escapeHTML(playlist.name)}」に追加しました`); } else { showSnackbar(`「${escapeHTML(song.title)}」は既に「${escapeHTML(playlist.name)}」に存在します`); } closeAllPlaylistDropdowns(); }
    function viewPlaylist(playlistId) { if (!appState.songs || appState.songs.length === 0) { showSnackbar("楽曲リストの読み込みが完了していません。"); console.warn("[DEBUG] viewPlaylist called before appState.songs was populated."); return; } const playlist = appState.userPlaylists.find(p => p && p.id === playlistId); if (!playlist) { showSnackbar("プレイリストが見つかりません。"); console.error(`[DEBUG] viewPlaylist: Playlist not found for ID: ${playlistId}`); return; } appState.currentSelectedPlaylistId = playlistId; renderPlaylistDetail(playlist); showModal('playlistDetail'); }
    function removeSongFromPlaylist() { const playlistId = appState.currentSelectedPlaylistId; const playlist = appState.userPlaylists.find(p => p && p.id === playlistId); if (!playlist || !playlist.songs || !elements.playlistElements.detailContent) return; const selectedCheckboxes = elements.playlistElements.detailContent.querySelectorAll('.song-select:checked'); const selectedSongIds = Array.from(selectedCheckboxes).map(el => el.dataset.id); if (selectedSongIds.length === 0) { showSnackbar('削除する曲を選択してください'); return; } const initialLength = playlist.songs.length; playlist.songs = playlist.songs.filter(songId => !selectedSongIds.includes(songId)); const removedCount = initialLength - playlist.songs.length; if (removedCount > 0) { saveUserPlaylists(); renderUserPlaylists(); renderPlaylistDetail(playlist); showSnackbar(`${removedCount}曲をプレイリストから削除しました`); } }
    function sharePlaylist() { const playlistId = appState.currentSelectedPlaylistId; const playlist = appState.userPlaylists.find(p => p && p.id === playlistId); if (!playlist || !elements.playlistElements.shareLinkInput || !elements.playlistElements.shareObjectTitle) { showSnackbar("共有するプレイリストが見つかりません。"); return; } const shareLink = `${window.location.origin}${window.location.pathname}?sharedPlaylistId=${playlistId}`; const shareTitle = `プレイリスト: ${escapeHTML(playlist.name)}`; elements.playlistElements.shareLinkInput.value = shareLink; elements.playlistElements.shareObjectTitle.textContent = shareTitle; hideModal('playlistDetail'); showModal('share'); }

    // ==========================================================================
    // Share Functions (Keep existing)
    // ==========================================================================
    function showShareModal() { const song = currentSongData(); if (!song) { showSnackbar('共有する曲を再生してください'); return; } const shareLink = `https://www.youtube.com/watch?v=${song.id}`; const shareTitle = `曲: ${escapeHTML(song.title)}`; if(!elements.playlistElements.shareLinkInput || !elements.playlistElements.shareObjectTitle || !elements.modals.share) { console.error("Share modal elements missing."); return; } elements.playlistElements.shareLinkInput.value = shareLink; elements.playlistElements.shareObjectTitle.textContent = shareTitle; const encodedLink = encodeURIComponent(shareLink); const encodedTitle = encodeURIComponent(`${shareTitle} - Rei Kikuchi Premium Player`); const twitterBtn = elements.modals.share.querySelector('button[style*="1DA1F2"]'); if (twitterBtn) twitterBtn.onclick = () => window.open(`https://twitter.com/intent/tweet?text=${encodedTitle}&url=${encodedLink}`, '_blank'); const facebookBtn = elements.modals.share.querySelector('button[style*="4267B2"]'); if (facebookBtn) facebookBtn.onclick = () => window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodedLink}`, '_blank'); showModal('share', elements.modalButtons.copyLink); }
    function copyShareLink() { const shareLinkInput = elements.playlistElements.shareLinkInput; if (!shareLinkInput || !shareLinkInput.value) { showSnackbar('コピーするリンクがありません。'); return; } navigator.clipboard.writeText(shareLinkInput.value).then(() => { showSnackbar('リンクをクリップボードにコピーしました'); }).catch(err => { console.warn('Clipboard API copy failed, trying fallback: ', err); try { shareLinkInput.select(); shareLinkInput.setSelectionRange(0, 99999); const successful = document.execCommand('copy'); if (successful) showSnackbar('リンクをクリップボードにコピーしました'); else showSnackbar('リンクのコピーに失敗しました'); } catch (errFallback) { console.error('Fallback copy failed: ', errFallback); showSnackbar('リンクのコピーに失敗しました'); } window.getSelection()?.removeAllRanges(); }); }

    // ==========================================================================
    // "Open on YouTube" Function (Keep existing)
    // ==========================================================================
    function handleOpenYouTube() { const song = currentSongData(); if (!song) { showSnackbar('再生中の曲がありません。'); return; } const youtubeUrl = `https://www.youtube.com/watch?v=${song.id}`; window.open(youtubeUrl, '_blank'); }

    // ==========================================================================
    // Account Functions (Keep existing)
    // ==========================================================================
    function showAccountModal() { console.log("showAccountModal called. Current user:", appState.loggedInUser); const isLoggedIn = !!appState.loggedInUser; updateAccountUI(isLoggedIn); if (isLoggedIn) { switchAuthSection('accountInfo'); } else { switchAuthSection('login'); } showModal('account'); }
    function switchAuthSection(section) { console.log("Attempting to switch auth section to:", section); if(!elements.accountSections) { console.error("elements.accountSections is not defined!"); return; } Object.values(elements.accountSections).forEach(el => { if(el) el.classList.add('hidden'); }); const sectionToShow = elements.accountSections[section]; if (sectionToShow) { sectionToShow.classList.remove('hidden'); console.log(`Section '${section}' should now be visible.`); const firstFocusable = sectionToShow.querySelector('button, [href], input:not([type="hidden"]), select, textarea, [tabindex]:not([tabindex="-1"])'); if (firstFocusable) { setTimeout(() => firstFocusable.focus(), 50); } } else { console.error("Invalid section requested in switchAuthSection:", section); } }
     function showLoadingState(button, isLoading) { if (!button) return; button.disabled = isLoading; if (isLoading) { button.innerHTML = '<i class="fas fa-spinner fa-spin"></i>'; } else { if (button.id === 'login-btn') button.textContent = 'ログイン'; else if (button.id === 'register-btn') button.textContent = '登録'; else if (button.id === 'sync-data-btn') button.innerHTML = '<i class="fas fa-sync mr-2"></i> データを同期'; else if (button.id === 'logout-btn') button.innerHTML = '<i class="fas fa-sign-out-alt mr-2"></i> ログアウト'; } }
    function handleLogin() { const emailInput = elements.accountFields.loginEmail; const passwordInput = elements.accountFields.loginPassword; if(!emailInput || !passwordInput) return false; const email = emailInput.value.trim(); const password = passwordInput.value; if (!email || !password) { showSnackbar("メールアドレスとパスワードを入力してください。"); return false; } console.log("Attempting mock login for:", email); showLoadingState(elements.modalButtons.login, true); setTimeout(() => { const mockUser = { name: "デモユーザー", email: email }; appState.loggedInUser = mockUser; saveToLocalStorage('reiKikuchiPlayerUser', mockUser); updateAccountUI(true); showSnackbar('ログインしました！'); hideModal('account'); showLoadingState(elements.modalButtons.login, false); }, 1000); return false; }
    function handleRegister() { const nameInput = elements.accountFields.registerName; const emailInput = elements.accountFields.registerEmail; const passwordInput = elements.accountFields.registerPassword; if(!nameInput || !emailInput || !passwordInput) return false; const name = nameInput.value.trim(); const email = emailInput.value.trim(); const password = passwordInput.value; if (!name || !email || !password) { showSnackbar("すべての項目を入力してください。"); return false; } console.log("Attempting mock registration for:", name, email); showLoadingState(elements.modalButtons.register, true); setTimeout(() => { const mockUser = { name: name, email: email }; appState.loggedInUser = mockUser; saveToLocalStorage('reiKikuchiPlayerUser', mockUser); updateAccountUI(true); showSnackbar('登録が完了しました。ようこそ！'); hideModal('account'); showLoadingState(elements.modalButtons.register, false); }, 1500); return false; }
    function handleLogout() { if (confirm("ログアウトしてもよろしいですか？")) { showLoadingState(elements.modalButtons.logout, true); setTimeout(() => { appState.loggedInUser = null; localStorage.removeItem('reiKikuchiPlayerUser'); updateAccountUI(false); showSnackbar('ログアウトしました'); hideModal('account'); showLoadingState(elements.modalButtons.logout, false); renderPlaylist(); renderHistoryList(); renderFavoritesList(); renderUserPlaylists(); }, 500); } }
    function updateAccountUI(isLoggedIn) { console.log("Updating Account UI elements, loggedIn:", isLoggedIn); if (elements.modalButtons.account) { if (isLoggedIn) { elements.modalButtons.account.innerHTML = '<i class="fas fa-user-check"></i>'; elements.modalButtons.account.classList.remove('btn-inactive'); elements.modalButtons.account.classList.add('btn-active'); elements.modalButtons.account.setAttribute('aria-label', 'アカウント (ログイン済み)'); } else { elements.modalButtons.account.innerHTML = '<i class="fas fa-user"></i>'; elements.modalButtons.account.classList.add('btn-inactive'); elements.modalButtons.account.classList.remove('btn-active'); elements.modalButtons.account.setAttribute('aria-label', 'アカウント (未ログイン)'); } } if (elements.accountFields.userName && elements.accountFields.userEmail) { if (isLoggedIn && appState.loggedInUser) { elements.accountFields.userName.textContent = appState.loggedInUser.name; elements.accountFields.userEmail.textContent = appState.loggedInUser.email; } else { elements.accountFields.userName.textContent = ''; elements.accountFields.userEmail.textContent = ''; } } if(elements.createPlaylistBtn) { elements.createPlaylistBtn.style.display = isLoggedIn ? 'inline-block' : 'none'; } renderPlaylist(); renderHistoryList(); renderFavoritesList(); renderUserPlaylists(); }
    function syncUserData() { if (!appState.loggedInUser) { showSnackbar("同期するにはログインしてください。"); showAccountModal(); return; } console.log("Attempting data sync for user:", appState.loggedInUser.email); showLoadingState(elements.modalButtons.syncData, true); showSnackbar("データをサーバーと同期中... (デモ)"); setTimeout(() => { showSnackbar('データ同期が完了しました (デモ)'); showLoadingState(elements.modalButtons.syncData, false); }, 2000); }

    // ==========================================================================
    // Utility Functions (Keep existing)
    // ==========================================================================
    function currentSongId() { return appState.currentSongIndex !== -1 ? appState.songs[appState.currentSongIndex]?.id : null; }
    function currentSongData() { return appState.currentSongIndex !== -1 ? appState.songs[appState.currentSongIndex] : null; }
    function findSongIndexById(songId) { if (!songId) return -1; return appState.songs.findIndex(song => song && song.id === songId); }
    function findSongById(songId) { if (!songId) return null; return appState.songs.find(song => song && song.id === songId); }
    function formatTime(seconds) { if (isNaN(seconds) || seconds < 0) return '00:00'; seconds = Math.floor(seconds); const minutes = Math.floor(seconds / 60); const remainingSeconds = seconds % 60; return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`; }
    function toggleTheme() { if(!elements.body || !elements.themeToggle) return; elements.body.classList.toggle('dark'); const isDark = elements.body.classList.contains('dark'); elements.themeToggle.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>'; elements.themeToggle.classList.toggle('btn-active', isDark); elements.themeToggle.classList.toggle('btn-inactive', !isDark); elements.themeToggle.setAttribute('aria-pressed', isDark); localStorage.setItem('reiKikuchiPlayerTheme', isDark ? 'dark' : 'light'); resizeCanvas(); }
    function handleSearch() { if(!elements.searchInput) return; const searchTerm = elements.searchInput.value.toLowerCase().trim(); appState.filteredSongs = appState.songs.filter(song => song && song.title.toLowerCase().includes(searchTerm)); renderPlaylist(); if (appState.currentTab !== 'playlist') { switchTab('playlist'); } }
    function switchTab(tabName) {
    if (appState.currentTab === tabName || !elements.tabs || !elements.tabContents) return;
    appState.currentTab = tabName;
    elements.tabs.forEach(tab => {
        const isSelected = tab.dataset.tab === tabName;
        tab.classList.toggle('active', isSelected);
        tab.setAttribute('aria-selected', isSelected);
        tab.setAttribute('tabindex', isSelected ? '0' : '-1');
    });
    elements.tabContents.forEach(content => {
        if(content) content.classList.toggle('hidden', content.id !== `${tabName}-tab`);
    });
    updateActiveListItem();
    // If switching to the Queue tab, ensure it's rendered correctly
    if (tabName === 'queue') {
        renderQueueList(); // <<<====== [ADD/CONFIRM] Render queue when tab becomes visible
    }
    console.log("Switched to tab:", tabName);
}
    function addToHistory(song) { if (!song || !song.id) return; appState.history = appState.history.filter(item => item && item.id !== song.id); appState.history.push({ ...song }); if (appState.history.length > MAX_HISTORY) { appState.history = appState.history.slice(-MAX_HISTORY); } saveToLocalStorage('reiKikuchiPlayerHistory', appState.history); }
    function toggleFavorite(songId) {
        const songIndexInFavorites = appState.favorites.findIndex(fav => fav && fav.id === songId); const song = findSongById(songId); if (!song) { console.warn("Cannot toggle favorite for unknown song ID:", songId); return; }
        const favoriteButtons = document.querySelectorAll(`.favorite-btn[data-id="${songId}"]`); favoriteButtons.forEach(button => { button.classList.add('pulsing'); setTimeout(() => { button.classList.remove('pulsing'); }, 300); });
        if (songIndexInFavorites > -1) { appState.favorites.splice(songIndexInFavorites, 1); showSnackbar(`「${escapeHTML(song.title)}」をお気に入りから削除しました`); } else { appState.favorites.push({ ...song }); showSnackbar(`「${escapeHTML(song.title)}」をお気に入りに追加しました`); }
        saveToLocalStorage('reiKikuchiPlayerFavorites', appState.favorites);
        setTimeout(() => { updateFavoriteButtonsUI(songId); renderFavoritesList(); }, 50);
         if (appState.currentSelectedPlaylistId && elements.modals.playlistDetail?.classList.contains('show')) { const playlist = appState.userPlaylists.find(p => p.id === appState.currentSelectedPlaylistId); const songIsInDisplayedPlaylist = playlist?.songs.includes(songId) || (songIndexInFavorites > -1 && playlist?.songs.includes(songId)); if(playlist && songIsInDisplayedPlaylist) { setTimeout(() => renderPlaylistDetail(playlist), 60); } }
    }
    function updateFavoriteButtonsUI(songId) { const isFavorite = appState.favorites.some(fav => fav && fav.id === songId); const favoriteButtons = document.querySelectorAll(`.favorite-btn[data-id="${songId}"]`); favoriteButtons.forEach(button => { const icon = button.querySelector('i'); if (icon) { icon.classList.toggle('text-red-500', isFavorite); icon.classList.toggle('text-gray-400', !isFavorite); button.setAttribute('aria-label', isFavorite ? 'お気に入り解除' : 'お気に入り登録'); } }); }
    function saveUserPlaylists() { saveToLocalStorage('reiKikuchiPlayerPlaylists', appState.userPlaylists); }
    function saveToLocalStorage(key, data) {
    try {
        localStorage.setItem(key, JSON.stringify(data));
        // Optionally save queue whenever other data changes? Or just on unload?
        // Saving queue here ensures it's relatively up-to-date if the browser crashes.
        if (key !== LS_KEYS.QUEUE) { // Avoid recursive calls if queue save triggers this
             localStorage.setItem(LS_KEYS.QUEUE, JSON.stringify(appState.queue));
        }
    } catch (error) {
        console.error("Error saving to localStorage:", key, error);
        showSnackbar("設定の保存中にエラーが発生しました。");
    }
}
     function showModal(modalId, elementToFocusInitially = null) { const modal = elements.modals[modalId]; if (!modal || modal.classList.contains('show')) { if (modal && modal.classList.contains('show') && elementToFocusInitially) { setTimeout(() => elementToFocusInitially.focus(), 50); } return; } console.log("Showing modal:", modalId); lastFocusedElement = document.activeElement; modal.style.display = 'flex'; void modal.offsetWidth; modal.classList.add('show'); appState.activeModalId = modalId; if(elements.body) elements.body.style.overflow = 'hidden'; const focusableElements = Array.from( modal.querySelectorAll('button, [href], input:not([type="hidden"]), select, textarea, [tabindex]:not([tabindex="-1"])') ).filter(el => el.offsetParent !== null && !el.disabled); const firstFocusable = focusableElements[0]; const lastFocusable = focusableElements[focusableElements.length - 1]; if (modal._keyDownListener) { modal.removeEventListener('keydown', modal._keyDownListener); } modal._keyDownListener = (e) => handleModalKeyDown(e, firstFocusable, lastFocusable, modalId); modal.addEventListener('keydown', modal._keyDownListener); setTimeout(() => { let targetElement = elementToFocusInitially; if (!targetElement) { if (modalId === 'createPlaylist') targetElement = elements.playlistElements.nameInput; else if (modalId === 'account' && !appState.loggedInUser) targetElement = elements.accountFields.loginEmail; else if (modalId === 'account' && appState.loggedInUser) targetElement = elements.modalButtons.syncData; else if (modalId === 'share') targetElement = elements.modalButtons.copyLink; else if (modalId === 'offline') targetElement = modal.querySelector('#cache-current-btn'); else if (modalId === 'playlistDetail') targetElement = modal.querySelector('.modal-close-btn'); else targetElement = firstFocusable; } if (targetElement && typeof targetElement.focus === 'function') { targetElement.focus(); } else if (modal && typeof modal.focus === 'function') { modal.focus(); } }, 150); }
    function hideModal(modalId) { const modal = elements.modals[modalId]; if (!modal || !modal.classList.contains('show')) { return; } modal.classList.remove('show'); if (appState.activeModalId === modalId) { appState.activeModalId = null; } setTimeout(() => { modal.style.display = 'none'; if (modal._keyDownListener) { modal.removeEventListener('keydown', modal._keyDownListener); delete modal._keyDownListener; } const anyOtherModalOpen = Object.values(elements.modals).some( m => m && m.id !== modal.id && m.classList.contains('show') ); if (!anyOtherModalOpen) { if(elements.body) elements.body.style.overflow = ''; if (lastFocusedElement && typeof lastFocusedElement.focus === 'function') { lastFocusedElement.focus(); } lastFocusedElement = null; } if (modalId === 'playlistDetail') appState.currentSelectedPlaylistId = null; if (modalId === 'share' && elements.playlistElements.shareLinkInput) elements.playlistElements.shareLinkInput.value = ''; if (modalId === 'createPlaylist' && elements.playlistElements.nameInput) elements.playlistElements.nameInput.value = ''; }, 300); }
     function handleModalKeyDown(e, firstFocusable, lastFocusable, modalId) { if (e.key === 'Escape') { hideModal(modalId); return; } if (e.key === 'Tab' && firstFocusable) { if (e.shiftKey) { if (document.activeElement === firstFocusable) { lastFocusable?.focus(); e.preventDefault(); } } else { if (document.activeElement === lastFocusable) { firstFocusable?.focus(); e.preventDefault(); } } if (firstFocusable === lastFocusable && document.activeElement === firstFocusable) { e.preventDefault(); } } }
    function showSnackbar(message) { const snackbar = elements.snackbar; if (!snackbar) return; snackbar.textContent = message; if (appState.snackbarTimeoutId) { clearTimeout(appState.snackbarTimeoutId); snackbar.classList.remove('show'); void snackbar.offsetWidth; } snackbar.classList.add('show'); appState.snackbarTimeoutId = setTimeout(() => { snackbar.classList.remove('show'); appState.snackbarTimeoutId = null; }, 3000); }
    function handleGlobalKeyDown(event) { const activeElement = document.activeElement; const isInputFocused = activeElement && ['INPUT', 'TEXTAREA', 'SELECT'].includes(activeElement.tagName); if (appState.activeModalId || (isInputFocused && event.key !== 'Escape')) { return; } switch (event.key) { case ' ': if (!isInputFocused) { event.preventDefault(); togglePlayPause(); } break; case 'ArrowRight': event.preventDefault(); if (event.ctrlKey || event.metaKey) seekRelative(SEEK_STEP); else playNextSong(); break; case 'ArrowLeft': event.preventDefault(); if (event.ctrlKey || event.metaKey) seekRelative(-SEEK_STEP); else playPreviousSong(); break; case 'ArrowUp': if (!elements.volumeSlider || activeElement !== elements.volumeSlider) { event.preventDefault(); adjustVolume(VOLUME_STEP); } break; case 'ArrowDown': if (!elements.volumeSlider || activeElement !== elements.volumeSlider) { event.preventDefault(); adjustVolume(-VOLUME_STEP); } break; case 'f': if (!isInputFocused) { event.preventDefault(); elements.searchInput?.focus(); } break; case 't': event.preventDefault(); toggleTheme(); break; } }
    function drawVisualizer() { if (!appState.visualizer.canvasCtx || !appState.visualizer.dataArray || !appState.visualizer.canvas) { appState.visualizer.animationFrameId = null; return; } const bufferLength = appState.visualizer.bufferLength; const dataArray = appState.visualizer.dataArray; const isPlayingNow = appState.isPlaying; let hasPositiveValue = false; for (let i = 0; i < bufferLength; i++) { if (isPlayingNow) { const timeFactor = Date.now() * 0.002 + i * 0.08; const randomFactor = Math.random() * 30; const sineValue = (Math.sin(timeFactor) + 1) / 2; const baseHeight = 10; dataArray[i] = Math.max(0, Math.min(255, baseHeight + (sineValue * 150) + randomFactor)); if (dataArray[i] > 1) hasPositiveValue = true; } else { dataArray[i] = Math.max(0, dataArray[i] * 0.96 - 0.5); if (dataArray[i] > 1) hasPositiveValue = true; } } const canvas = appState.visualizer.canvas; const canvasCtx = appState.visualizer.canvasCtx; const width = canvas.width; const height = canvas.height; if (width <= 0 || height <= 0) { appState.visualizer.animationFrameId = null; return; } canvasCtx.clearRect(0, 0, width, height); const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#8e24aa'; const secondaryColor = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color').trim() || '#5e35b1'; const gradient = canvasCtx.createLinearGradient(0, 0, 0, height); gradient.addColorStop(0, primaryColor); gradient.addColorStop(1, secondaryColor); canvasCtx.fillStyle = gradient; const barWidthRatio = 0.7; const spacingRatio = 0.4; const totalBarWidth = width / bufferLength; const barWidth = Math.max(1, totalBarWidth * barWidthRatio); const spacing = Math.max(1, totalBarWidth * spacingRatio); const totalBarAndSpaceWidth = barWidth + spacing; const numBarsThatFit = totalBarAndSpaceWidth > 0 ? Math.floor((width + spacing) / totalBarAndSpaceWidth) : 0; const actualBufferLength = Math.min(bufferLength, numBarsThatFit); const totalDrawingWidth = actualBufferLength * totalBarAndSpaceWidth - (actualBufferLength > 0 ? spacing : 0); const offsetX = Math.max(0, (width - totalDrawingWidth) / 2); let x = offsetX; for (let i = 0; i < actualBufferLength; i++) { const rawHeight = (dataArray[i] / 255) * height * 0.95; const barHeight = Math.max(1, rawHeight); const borderRadius = Math.min(3, barWidth / 3); canvasCtx.beginPath(); const startX = Math.round(x); const startY = Math.round(height); const endX = Math.round(x + barWidth); const endY = Math.round(height - barHeight); if (barHeight > 1) { canvasCtx.moveTo(startX, startY); canvasCtx.lineTo(startX, endY + borderRadius); canvasCtx.quadraticCurveTo(startX, endY, startX + borderRadius, endY); canvasCtx.lineTo(endX - borderRadius, endY); canvasCtx.quadraticCurveTo(endX, endY, endX, endY + borderRadius); canvasCtx.lineTo(endX, startY); } canvasCtx.fill(); x += totalBarAndSpaceWidth; } if (isPlayingNow || hasPositiveValue) { appState.visualizer.animationFrameId = requestAnimationFrame(drawVisualizer); } else { appState.visualizer.animationFrameId = null; console.log("[DEBUG] Visualizer loop stopped naturally (decayed)."); } }
    function resizeCanvas() { const canvas = appState.visualizer.canvas; if (!canvas) return; const parent = canvas.parentElement; if (!parent) return; const rect = parent.getBoundingClientRect(); if (rect.width > 0 && rect.height > 0 && (canvas.width !== rect.width || canvas.height !== rect.height)) { canvas.width = rect.width; canvas.height = rect.height; console.log("Resized visualizer canvas to:", rect.width, rect.height); if (appState.visualizer.animationFrameId === null) { drawVisualizer(); } } }
     function updateActiveListItem() { const currentId = currentSongId(); const listContainers = [ elements.playlist, elements.historyList, elements.favoritesList, elements.playlistElements?.detailContent ]; listContainers.forEach(container => { if (container) { const previouslyActive = container.querySelector('.active'); previouslyActive?.classList.remove('active'); if (currentId) { const activeItem = container.querySelector(`.playlist-item[data-id="${currentId}"], .history-item[data-id="${currentId}"], .favorite-item[data-id="${currentId}"]`); if (activeItem) { activeItem.classList.add('active'); const isVisible = !activeItem.closest('.tab-content.hidden, .modal:not(.show)'); if(isVisible) { const itemRect = activeItem.getBoundingClientRect(); const containerRect = container.getBoundingClientRect(); const containerHasHeight = containerRect.height > 0; const isFullyVisible = containerHasHeight && itemRect.top >= containerRect.top && itemRect.bottom <= containerRect.bottom; if (!isFullyVisible && containerHasHeight) { activeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } } } } } }); }
      function handleUrlParams() { try { const urlParams = new URLSearchParams(window.location.search); const sharedPlaylistId = urlParams.get('sharedPlaylistId'); const songIdToPlay = urlParams.get('playSongId'); if (sharedPlaylistId) { const playlist = appState.userPlaylists.find(p => p && p.id === sharedPlaylistId); if (playlist) { showSnackbar(`共有されたプレイリスト「${escapeHTML(playlist.name)}」を表示します`); viewPlaylist(sharedPlaylistId); switchTab('user-playlists'); } else { showSnackbar("共有されたプレイリストが見つかりませんでした。"); } } else if (songIdToPlay) { const originalIndex = findSongIndexById(songIdToPlay); if (originalIndex !== -1) { playSong(originalIndex); showSnackbar(`共有された曲を再生します`); } else { showSnackbar("共有された曲が見つかりませんでした。"); } } } catch(e) { console.error("Error handling URL parameters:", e); } }
      function escapeHTML(str) { if (typeof str !== 'string') return ''; const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }; return str.replace(/[&<>"']/g, (m) => map[m]); }
       function checkBottomControlsVisibility() { const isMobile = window.innerWidth < 1024; if (elements.bottomControls) { elements.bottomControls.classList.toggle('hidden', !isMobile); } if(elements.body) { elements.body.classList.toggle('has-bottom-controls', isMobile); } }

    // ==========================================================================
    // YouTube API Object (Keep existing)
    // ==========================================================================
     const youtubeAPI = { apiKey: 'AIzaSyCbzvjP9vFa5I8N1qLI5H9LUpYim0nkQS4', channelId: 'UCYAuSEKhuk3v4ZKzm5Lqb1Q', async getLatestVideos(maxResults = 15) { console.log(`Fetching latest ${maxResults} videos...`); try { const response = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=${this.channelId}&maxResults=${maxResults}&order=date&type=video&key=${this.apiKey}`); if (!response.ok) { let errorMsg = `YouTube Search API error: ${response.status}`; try { const errorData = await response.json(); errorMsg = `YouTube Search API error: ${response.status} - ${errorData?.error?.message || 'Unknown error'}`; } catch (e) {} throw new Error(errorMsg); } const data = await response.json(); if (!data.items) { console.warn("No items found in YouTube search response."); return []; } console.log(`Found ${data.items.length} videos from search.`); return data.items.map(item => ({ id: item.id.videoId, title: item.snippet.title, description: item.snippet.description, thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.medium?.url || item.snippet.thumbnails.default?.url, publishedAt: item.snippet.publishedAt, duration: null })); } catch (error) { console.error('YouTube Search API error:', error); showSnackbar('YouTube動画の取得に失敗しました'); return []; } }, async getVideoDetails(videoIds) { if (!videoIds || videoIds.length === 0) return []; console.log(`Fetching details for ${videoIds.length} video(s)...`); const MAX_IDS_PER_REQUEST = 50; let allDetails = []; for (let i = 0; i < videoIds.length; i += MAX_IDS_PER_REQUEST) { const chunkIds = videoIds.slice(i, i + MAX_IDS_PER_REQUEST); try { const response = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=contentDetails,statistics&id=${chunkIds.join(',')}&key=${this.apiKey}`); if (!response.ok) { let errorMsg = `YouTube Videos API error: ${response.status}`; try { const errorData = await response.json(); errorMsg = `YouTube Videos API error: ${response.status} - ${errorData?.error?.message || 'Unknown error'}`; } catch (e) {} throw new Error(errorMsg); } const data = await response.json(); if (data.items) { const chunkDetails = data.items.map(item => ({ id: item.id, duration: item.contentDetails?.duration ? this.convertDuration(item.contentDetails.duration) : '--:--', viewCount: item.statistics?.viewCount })); allDetails = allDetails.concat(chunkDetails); } } catch (error) { console.error(`YouTube Videos API error (chunk ${i / MAX_IDS_PER_REQUEST}):`, error); showSnackbar('動画詳細の一部の取得に失敗しました'); } } console.log(`Fetched details for ${allDetails.length} video(s).`); return allDetails; }, convertDuration(isoDuration) { const regex = /P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?/; const matches = isoDuration.match(regex); if (!matches) return '--:--'; const hours = parseInt(matches[5] || 0); const minutes = parseInt(matches[6] || 0); const seconds = Math.floor(parseFloat(matches[7] || 0)); let formattedTime = ""; if (hours > 0) { formattedTime += `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; } else { formattedTime += `${minutes}:${seconds.toString().padStart(2, '0')}`; } return formattedTime; }, async updatePlaylist() { try { showSnackbar('YouTubeから最新の曲を取得中...'); const latestVideos = await this.getLatestVideos(25); if (latestVideos.length === 0) { showSnackbar('新しい曲は見つかりませんでした'); return; } const videoIds = latestVideos.map(video => video.id); const videoDetails = await this.getVideoDetails(videoIds); const videosWithDetails = latestVideos.map(video => { const details = videoDetails.find(detail => detail.id === video.id) || {}; return { ...video, duration: details.duration || '--:--', }; }); const currentSongIds = new Set(appState.songs.map(s => s.id)); const newSongs = videosWithDetails.filter(video => !currentSongIds.has(video.id)); if (newSongs.length === 0) { showSnackbar('新しい曲は見つかりませんでした'); return; } appState.songs.unshift(...newSongs.map(video => ({ id: video.id, title: video.title, duration: video.duration, thumbnail: video.thumbnail }))); appState.filteredSongs = [...appState.songs]; renderPlaylist(); showSnackbar(`${newSongs.length}曲の新しい曲を追加しました`); } catch (error) { console.error('プレイリスト更新エラー:', error); showSnackbar(`プレイリストの更新に失敗しました: ${error.message || '不明なエラー'}`); } }, startAutoSync(intervalMinutes = 60) { console.log(`Starting auto-sync every ${intervalMinutes} minutes.`); const intervalId = setInterval(() => { console.log("Auto-sync triggered."); this.updatePlaylist(); }, intervalMinutes * 60 * 1000); return intervalId; } };
    function setupYouTubeSync() { if (document.getElementById('youtube-sync-btn')) return; const syncButton = document.createElement('button'); syncButton.id = 'youtube-sync-btn'; syncButton.className = 'px-3 py-1 rounded-md text-sm focusable'; syncButton.style.backgroundColor = 'var(--primary-color)'; syncButton.style.color = 'white'; syncButton.innerHTML = '<i class="fab fa-youtube mr-1"></i> 新曲を同期'; const buttonContainer = document.querySelector('.player-main-column .flex.justify-end.mb-2.gap-2'); if (buttonContainer) { buttonContainer.prepend(syncButton); syncButton.addEventListener('click', () => { youtubeAPI.updatePlaylist(); }); console.log("YouTube Sync button added."); } else { console.error("Could not find button container to add YouTube Sync button."); } }

    // ==========================================================================
    // Offline Playback (Placeholder - Keep commented out if not using)
    // ==========================================================================
    /*
    const offlinePlayback = { ... };
    */

    // ==========================================================================
    // DOMContentLoaded Listener
    // ==========================================================================
    document.addEventListener('DOMContentLoaded', function() {
      console.log("DOM fully loaded and parsed.");
      function setCorrectViewportHeight() { let vh = window.innerHeight * 0.01; document.documentElement.style.setProperty('--vh', `${vh}px`); }
      setCorrectViewportHeight(); window.addEventListener('resize', setCorrectViewportHeight);
      console.log("DOMContentLoaded setup finished. Waiting for YT API...");
    });

    // --- Final log ---
    console.log("Player script parsed. Waiting for YouTube API ready event...");

    // Add listener to save queue before unload (optional but good practice)
window.addEventListener('beforeunload', () => {
    try {
        // Only save if queue is not empty? Or always save/remove?
        // Always saving ensures removal if queue becomes empty.
        if (appState.queue.length > 0) {
            localStorage.setItem(LS_KEYS.QUEUE, JSON.stringify(appState.queue));
            console.log("Queue saved before page unload.");
        } else {
            // Remove the key if the queue is empty to avoid loading an empty array later unnecessarily
            localStorage.removeItem(LS_KEYS.QUEUE);
            console.log("Empty queue, removed key before page unload.");
        }
    } catch (error) {
        console.error("Error saving queue before unload:", error);
    }
});
        // Add these to the initializeElementsJG function, inside the elementsJG = { ... } object:
        function initializeElementsJG() {
            elementsJG = {
                // ... other elements ...
                profileModal: document.getElementById('profileModalJG'),
                closeProfileModalButton: document.getElementById('closeProfileModalJG'),
                // ... rest of elements ...
            };
            // ... rest of initializeElementsJG ...
        }

        // Add these two new functions:
        function showProfileModalJG() {
            if (elementsJG.profileModal) {
                elementsJG.profileModal.style.display = 'flex';
                appStateJG.activeModalId = 'profileModalJG';
            }
        }

        function hideProfileModalJG() {
            if (elementsJG.profileModal) {
                elementsJG.profileModal.style.display = 'none';
                appStateJG.activeModalId = null;
            }
        }

        // Add event listeners in setupEventListenersJG function:
        function setupEventListenersJG() {
            // ... other listeners ...
            elementsJG.themeToggle?.addEventListener('click', cycleThemeJG); 
            
            // NEW Listeners for Profile Modal
            elementsJG.profileButton?.addEventListener('click', showProfileModalJG);
            elementsJG.closeProfileModalButton?.addEventListener('click', hideProfileModalJG);
            elementsJG.profileModal?.addEventListener('click', (e) => {
                if (e.target === elementsJG.profileModal) { // Click on backdrop
                    hideProfileModalJG();
                }
            });

            elementsJG.logTabs = document.querySelectorAll('.safari-navigation-tabs-jg .log-tab-jg');
            // ... rest of listeners ...
        }

        // Modify handleGlobalKeydownJG function to include the new modal:
        function handleGlobalKeydownJG(event) {
            const tTN = event.target.tagName.toLowerCase();
            if (tTN === 'input' || tTN === 'textarea' || event.target.isContentEditable) {
                if (event.key === 'Escape' && appStateJG.activeModalId) {
                    if (appStateJG.activeModalId === 'createPlaylistModalJG') hideCreatePlaylistModalJG();
                    else if (appStateJG.activeModalId === 'addToPlaylistModalJG') hideAddToPlaylistModalJG();
                    else if (appStateJG.activeModalId === 'editSongModalJG') hideEditSongModalJG();
                    else if (appStateJG.activeModalId === 'profileModalJG') hideProfileModalJG(); // ADDED
                }
                return;
            }
            let pD = true;
            switch (event.key) {
                // ... other cases ...
                case 'Escape':
                    if (appStateJG.activeModalId) {
                        if (appStateJG.activeModalId === 'createPlaylistModalJG') hideCreatePlaylistModalJG();
                        else if (appStateJG.activeModalId === 'addToPlaylistModalJG') hideAddToPlaylistModalJG();
                        else if (appStateJG.activeModalId === 'editSongModalJG') hideEditSongModalJG();
                        else if (appStateJG.activeModalId === 'profileModalJG') hideProfileModalJG(); // ADDED
                    } else {
                        pD = false;
                    }
                    break;
                default:
                    pD = false;
                    break;
            }
            if (pD) event.preventDefault();
        }
  </script>

</body>

</html>
