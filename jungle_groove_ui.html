<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jungle Groove - Wild Music Safari</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Kalam:wght@400;700&family=Montserrat:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* jungle_groove_styles.css */
        :root {
            --jg-bg-deep-jungle: #1A3A3A;
            --jg-bg-forest-floor: #4A3B31;
            --jg-surface-bark: #785C4A;
            --jg-surface-leaf: #5C824D;
            --jg-accent-sunburst: #FFA726;
            --jg-accent-canopy: #4CAF50;
            --jg-accent-waterfall: #29B6F6;
            --jg-text-light: #F5EFE6;
            --jg-text-earth: #D2B48C;
            --jg-text-shadow: #A08A72;
            --jg-border-vine: #6B4F3A;
            --jg-shadow-heavy: rgba(0,0,0,0.4);
            --jg-shadow-light: rgba(0,0,0,0.2);

            --font-display-jg: 'Kalam', cursive;
            --font-body-jg: 'Montserrat', sans-serif;

            --jg-surface-bark-rgb: 120, 92, 74;
            --jg-surface-leaf-rgb: 92, 130, 77;
            --jg-bg-forest-floor-rgb: 74, 59, 49;
            --jg-accent-canopy-rgb: 76, 175, 80;

            --jg-placeholder-bg: var(--jg-surface-bark);
        }

        body.jungle-theme {
            font-family: var(--font-body-jg);
            background-color: var(--jg-bg-deep-jungle);
            color: var(--jg-text-light);
            margin: 0;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        .jungle-background-layers { position: fixed; inset: 0; z-index: -1; }
        .jungle-background-layers .layer {
            position: absolute; inset: 0;
            transition: transform 0.5s ease-out, opacity 0.5s ease;
        }
        .layer-1 {
            /* background-image: linear-gradient(to bottom, #3A506B, #1C2541 70%), url('path/to/distant_trees_silhouette.png'); */ /* COMMENTED OUT */
            background: linear-gradient(to bottom, #3A506B, #1C2541 70%);
            opacity: 0.8;
        }
        .layer-2 {
            /* background-image: url('path/to/mid_foliage_texture.png'); */ /* COMMENTED OUT */
            background-color: rgba(var(--jg-surface-leaf-rgb), 0.15);
            opacity: 0.4;
            transform: scale(1.05);
        }
        .layer-3 {
            /* background-image: url('path/to/foreground_vines.png'); */ /* COMMENTED OUT */
            /* background-position: bottom left; */
            opacity: 0.6;
            transform: scale(1.1);
        }

        .app-safari-hut {
            width: 95vw;
            height: 90vh;
            max-width: 1500px;
            max-height: 850px;
            margin: 2.5vh auto;
            background-color: rgba(40, 30, 20, 0.65);
            backdrop-filter: blur(15px) saturate(120%);
            -webkit-backdrop-filter: blur(15px) saturate(120%);
            border: 3px solid var(--jg-surface-bark);
            border-radius: 25px;
            box-shadow: 0 10px 40px var(--jg-shadow-heavy);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .safari-map-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem 1.5rem;
            background-color: rgba(var(--jg-surface-bark-rgb), 0.85);
            border-bottom: 2px solid var(--jg-border-vine);
            box-shadow: 0 4px 10px var(--jg-shadow-light);
        }
        .compass-logo {
            font-family: var(--font-display-jg);
            font-size: 1.6rem;
            font-weight: 700;
            color: var(--jg-text-light);
        }
        .compass-logo i { color: var(--jg-accent-sunburst); margin-right: 0.5rem; transform: rotate(-15deg); }
        .text-accent-jg { color: var(--jg-accent-canopy); }

        .search-outpost {
            display: flex;
            align-items: center;
            background-color: rgba(var(--jg-bg-forest-floor-rgb), 0.75);
            padding: 0.5rem 1rem;
            border-radius: 30px;
            border: 1px solid var(--jg-border-vine);
        }
        .search-outpost i { color: var(--jg-text-shadow); margin-right: 0.7rem; }
        #animal-tracker {
            background: transparent; border: none; outline: none;
            color: var(--jg-text-light); font-size: 0.9rem; width: 250px;
        }
        #animal-tracker::placeholder { color: var(--jg-text-shadow); opacity: 0.8; }

        .safari-tools { display: flex; align-items: center; gap: 0.75rem; }
        .tool-btn-jg {
            background-color: var(--jg-surface-bark);
            border: 1px solid var(--jg-border-vine);
            color: var(--jg-text-earth);
            width: 40px; height: 40px;
            border-radius: 50%;
            display: inline-flex; align-items: center; justify-content: center;
            font-size: 1.1rem;
            transition: all 0.2s ease;
            box-shadow: 0 2px 5px var(--jg-shadow-light);
        }
        .tool-btn-jg:hover {
            background-color: var(--jg-accent-sunburst);
            color: var(--jg-bg-deep-jungle);
            transform: scale(1.1);
        }
        .tool-btn-jg.profile .profile-avatar-placeholder { /* From HTML */
            width: 30px; height: 30px; border-radius: 50%;
            background-color: var(--jg-text-shadow); /* Placeholder color */
        }

        .safari-zone {
            flex-grow: 1;
            display: flex;
            padding: 1.5rem;
            gap: 1.5rem;
            overflow: hidden;
        }

        .watering-hole-player {
            flex: 3;
            /* background: linear-gradient(135deg, rgba(var(--jg-surface-leaf-rgb),0.7), rgba(var(--jg-surface-bark-rgb),0.5)), url('path/to/jungle_texture_dense.png'); */ /* COMMENTED OUT */
            background: linear-gradient(135deg, rgba(var(--jg-surface-leaf-rgb),0.7), rgba(var(--jg-surface-bark-rgb),0.5));
            border-radius: 20px;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: inset 0 0 15px var(--jg-shadow-light);
            border: 2px solid var(--jg-border-vine);
        }
        .album-canopy {
            width: 280px; height: 280px;
            border-radius: 15px;
            margin-bottom: 1.5rem;
            position: relative;
            box-shadow: 0 8px 25px var(--jg-shadow-heavy);
            overflow: hidden;
            background-color: var(--jg-bg-forest-floor);
        }
        #main-album-art-jg.album-art-placeholder { /* From HTML */
            width: 100%; height: 100%;
            border: 4px solid var(--jg-surface-bark);
            background-color: var(--jg-text-shadow); /* Placeholder for the actual image */
            display: flex; align-items: center; justify-content: center;
            font-size: 3rem; color: var(--jg-bg-deep-jungle);
        }
        .leaf-overlay {
            position: absolute; inset: 0;
            /* background-image: url('path/to/leaf_pattern_transparent.png'); */ /* COMMENTED OUT */
            opacity: 0.1;
            pointer-events: none;
        }
        .track-details-jg { text-align: center; margin-bottom: 1.5rem; }
        #song-title-jg {
            font-family: var(--font-display-jg);
            font-size: 2.5rem; font-weight: 700;
            color: var(--jg-text-light); margin-bottom: 0.25rem;
            min-height: 1.2em;
        }
        #artist-name-jg {
            font-size: 1.1rem; color: var(--jg-text-earth);
            min-height: 1.2em;
        }

        .player-controls-jg { display: flex; align-items: center; gap: 1rem; margin-bottom: 1.5rem; }
        .control-rock {
            /* background-image: url('path/to/rock_texture.png'); */ /* COMMENTED OUT */
            background-color: var(--jg-surface-bark);
            border: 2px solid #5C4033;
            color: var(--jg-text-earth);
            border-radius: 50%;
            width: 60px; height: 60px;
            font-size: 1.2rem;
            display: inline-flex; align-items: center; justify-content: center;
            box-shadow: 2px 2px 5px var(--jg-shadow-light), inset 1px 1px 3px rgba(255,255,255,0.1);
            transition: all 0.15s ease-out;
            text-shadow: 1px 1px 2px var(--jg-shadow-heavy);
        }
        .control-rock:hover { transform: translateY(-2px) scale(1.05); box-shadow: 4px 4px 8px var(--jg-shadow-light), inset 1px 1px 3px rgba(255,255,255,0.1); }
        .control-rock:active { transform: translateY(1px) scale(0.98); box-shadow: 1px 1px 3px var(--jg-shadow-light), inset 1px 1px 3px rgba(0,0,0,0.2); }
        .control-rock.small { width: 45px; height: 45px; font-size: 1rem; }
        .control-rock.play {
            width: 75px; height: 75px; font-size: 2rem;
            /* background-image: url('path/to/mossy_rock_texture.png'); */ /* COMMENTED OUT */
            background-color: var(--jg-accent-canopy);
            border-color: var(--jg-accent-canopy);
            color: var(--jg-text-light);
        }
        .control-rock.play i.fa-paw { font-size: 2.2rem; }

        .progress-liana-jg { display: flex; align-items: center; gap: 0.75rem; width: 100%; max-width: 400px; margin-bottom: 1rem; }
        .progress-liana-jg span { font-size: 0.8rem; color: var(--jg-text-shadow); }
        .liana-slider {
            -webkit-appearance: none; appearance: none; flex-grow: 1; height: 8px;
            /* background-image: url('path/to/vine_texture.png'); */ /* COMMENTED OUT */
            background-color: var(--jg-border-vine);
            border-radius: 4px; cursor: pointer;
        }
        .liana-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 18px; height: 18px;
            /* background-image: url('path/to/leaf_thumb.png'); */ /* COMMENTED OUT */
            background-color: var(--jg-accent-canopy);
            background-size: contain;
            border: none;
            border-radius: 50%;
            /* transform: rotate(15deg); */
        }

        .volume-fruit-jg { display: flex; align-items: center; gap: 0.5rem; }
        .animal-icon { font-size: 1.2rem; color: var(--jg-text-shadow); }
        .fruit-slider {
            -webkit-appearance: none; appearance: none; width: 120px; height: 10px;
            background: var(--jg-surface-bark); border-radius: 5px; cursor: pointer;
        }
        .fruit-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 16px; height: 16px;
            background: var(--jg-accent-sunburst);
            border-radius: 50%; border: 1px solid #D47500;
        }

        .explorers-log {
            flex: 2;
            background-color: rgba(var(--jg-surface-bark-rgb), 0.65);
            border-radius: 15px;
            border: 2px solid var(--jg-border-vine);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .log-tabs-jg { display: flex; border-bottom: 2px solid var(--jg-border-vine); margin-bottom: 1rem; }
        .log-tab-jg {
            flex-grow: 1; padding: 0.75rem 0.5rem;
            font-family: var(--font-display-jg); font-size: 1.1rem;
            color: var(--jg-text-earth); border: none; background: transparent;
            position: relative; opacity: 0.7; transition: opacity 0.2s, color 0.2s;
            cursor: pointer; /* Added for better UX */
        }
        .log-tab-jg:hover { opacity: 1; color: var(--jg-accent-sunburst); }
        .log-tab-jg.active {
            opacity: 1; color: var(--jg-accent-sunburst); font-weight: 700;
        }
        .log-tab-jg.active::after {
            content: ''; position: absolute;
            bottom: -2px; left: 10%; width: 80%; height: 3px;
            background-color: var(--jg-accent-sunburst); border-radius: 1.5px;
        }
        .log-tab-jg i { margin-right: 0.4rem; }
        #queue-count-jg {
            background: var(--jg-accent-waterfall); color: white; font-size: 0.7rem;
            padding: 1px 5px; border-radius: 8px; margin-left: 0.3rem;
            font-family: var(--font-body-jg);
        }

        .log-content-jg { flex-grow: 1; overflow-y: auto; }
        .log-panel-jg { display: none; padding-top: 0.5rem; }
        .log-panel-jg.active { display: block; animation: revealPanel 0.4s ease-in-out; }
        @keyframes revealPanel { from { opacity:0; transform:scale(0.98); } to { opacity:1; transform:scale(1); } }

        .log-entry-jg {
            display: flex; align-items: center; padding: 0.75rem;
            margin-bottom: 0.5rem; border-radius: 10px;
            background-color: rgba(var(--jg-bg-forest-floor-rgb), 0.55);
            transition: background-color 0.2s, transform 0.2s;
            cursor: pointer;
        }
        .log-entry-jg:hover {
            background-color: rgba(var(--jg-surface-leaf-rgb),0.5);
            transform: translateX(5px);
        }
        .log-entry-jg.active-song {
            background-color: rgba(var(--jg-accent-canopy-rgb),0.4);
            border-left: 4px solid var(--jg-accent-canopy);
            padding-left: calc(0.75rem - 4px);
        }
        /* Applied to img tag directly in JS rendering now, but keep for HTML example */
        .log-entry-jg .img-placeholder.list-thumb-placeholder {
            width: 40px; height: 40px; border-radius: 6px; margin-right: 0.75rem;
            background-color: var(--jg-text-shadow);
            display: flex; align-items: center; justify-content: center;
            font-size: 1rem; color: var(--jg-bg-forest-floor);
            object-fit: cover; /* Ensure image covers if src is real */
            flex-shrink: 0; /* Prevent shrinking */
        }
        /* Make sure actual img tags rendered by JS also have this class or similar styling if they are placeholders */
         .log-entry-jg > img { /* Style for dynamically added images if not using placeholder class */
            width: 40px; height: 40px; border-radius: 6px; margin-right: 0.75rem;
            object-fit: cover;
            flex-shrink: 0;
        }

        .log-entry-jg > div { flex-grow: 1; overflow:hidden; }
        .log-entry-jg .title { display: block; font-weight: 600; color: var(--jg-text-light); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
        .log-entry-jg .artist { display: block; font-size: 0.85rem; color: var(--jg-text-earth); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
        .log-entry-jg .duration { font-size: 0.85rem; color: var(--jg-text-shadow); margin-left: auto; padding-left:0.5rem; flex-shrink: 0; }
        .log-entry-jg > button.song-item-action-jg {
            background: none; border: none; padding: 0.5rem; margin-left: 0.5rem;
            cursor: pointer; flex-shrink: 0;
        }
        .log-entry-jg > button.song-item-action-jg i {
            font-size: 1rem; color: var(--jg-text-shadow); transition: color 0.2s;
        }
        .log-entry-jg:hover > button.song-item-action-jg i { color: var(--jg-accent-sunburst); }
        /* Fallback for the static HTML example (the last <i> in log-entry-jg) */
        .log-entry-jg > i.fa-feather-alt, .log-entry-jg > i.fa-play-circle {
             font-size: 1rem; color: var(--jg-text-shadow); transition: color 0.2s; margin-left: auto; padding-left:0.5rem; flex-shrink: 0;
        }
        .log-entry-jg:hover > i.fa-feather-alt { color: var(--jg-accent-sunburst); }


        .log-actions-jg {
            padding-top: 1rem; border-top: 1px solid var(--jg-border-vine);
            display: flex; gap: 0.75rem; justify-content: center;
        }
        .log-actions-jg button {
            background-color: var(--jg-surface-leaf); color: var(--jg-text-light);
            padding: 0.5rem 1rem; border-radius: 20px; border: 1px solid var(--jg-accent-canopy);
            font-size: 0.85rem; font-weight: 500; transition: all 0.2s;
             cursor: pointer; /* Added for better UX */
        }
        .log-actions-jg button:hover {
            background-color: var(--jg-accent-canopy);
            transform: translateY(-1px); box-shadow: 0 2px 8px var(--jg-shadow-light);
        }
        .log-actions-jg button i { margin-right: 0.4rem; }

        .control-rock.active-control {
            color: var(--jg-accent-sunburst) !important;
            border-color: var(--jg-accent-sunburst);
            box-shadow: 0 0 10px var(--jg-accent-sunburst), inset 1px 1px 3px rgba(255,255,255,0.1);
        }
        .loop-indicator-jg {
            position: absolute;
            top: 0px; right: 5px; font-size: 0.6rem; font-weight: bold;
            background-color: var(--jg-accent-sunburst); color: var(--jg-bg-deep-jungle);
            border-radius: 50%; width: 12px; height: 12px;
            line-height: 12px; text-align: center; font-family: var(--font-body-jg);
        }

        /* HTML placeholder image styling */
        .img-placeholder {
            display: inline-block;
            background-color: var(--jg-placeholder-bg);
            object-fit: cover; /* If src is ever set */
        }
        /* Specific placeholder styles are now in their respective component styles */

        @media (max-width: 1024px) {
            .app-safari-hut { width: 100vw; height: 100vh; margin: 0; border-radius: 0; max-height: none; }
            .safari-zone { flex-direction: column; padding: 0.75rem; }
            .watering-hole-player { flex: 1; padding: 1rem; min-height: 350px; }
            .album-canopy { width: 180px; height: 180px; }
            #song-title-jg { font-size: 1.8rem; }
            .explorers-log { flex: 1; }
            #animal-tracker { width: 150px; }
        }
        @media (max-width: 767px) {
            .safari-map-bar { padding: 0.75rem 1rem; }
            .compass-logo { font-size: 1.2rem;}
            .search-outpost { padding: 0.4rem 0.8rem;}
            #animal-tracker { width: 120px; font-size: 0.8rem;}
            .tool-btn-jg { width: 36px; height: 36px; font-size: 1rem; }
            .watering-hole-player { padding: 0.75rem; }
            .album-canopy { width: 150px; height: 150px; margin-bottom: 1rem; }
            #main-album-art-jg.album-art-placeholder { font-size: 2rem; }
            #song-title-jg { font-size: 1.5rem; }
            #artist-name-jg { font-size: 0.9rem; }
            .player-controls-jg { gap: 0.75rem; margin-bottom: 1rem; }
            .control-rock { width: 50px; height: 50px; font-size: 1rem; }
            .control-rock.small { width: 40px; height: 40px; font-size: 0.9rem; }
            .control-rock.play { width: 65px; height: 65px; font-size: 1.8rem; }
            .log-tabs-jg { margin-bottom: 0.75rem; }
            .log-tab-jg { font-size: 0.95rem; padding: 0.6rem 0.3rem; }
            .log-entry-jg { padding: 0.6rem; }
            /* Style for images in log entries on small screens */
            .log-entry-jg .img-placeholder.list-thumb-placeholder,
            .log-entry-jg > img {
                width: 35px; height: 35px; margin-right: 0.5rem;
            }
            .log-entry-jg .title { font-size: 0.9rem;}
            .log-entry-jg .artist { font-size: 0.75rem;}
        }

        /* Light mode styles - Toggled by JS */
        body.light-mode-jg {
            --jg-bg-deep-jungle: #E0F2E9; /* Light greenish white */
            --jg-bg-forest-floor: #F5EFE6; /* Light beige */
            --jg-surface-bark: #BCAAA4;    /* Lighter brown */
            --jg-surface-leaf: #A5D6A7;    /* Light green */
            --jg-accent-sunburst: #FF8F00; /* Deeper orange */
            --jg-accent-canopy: #388E3C;   /* Darker green */
            --jg-accent-waterfall: #1976D2;/* Deeper blue */
            --jg-text-light: #37474F;      /* Dark gray for text on light bg */
            --jg-text-earth: #5D4037;      /* Brownish text */
            --jg-text-shadow: #78909C;     /* Lighter shadow/muted text */
            --jg-border-vine: #8D6E63;     /* Lighter vine border */

            --jg-surface-bark-rgb: 188, 170, 164;
            --jg-surface-leaf-rgb: 165, 214, 167;
            --jg-bg-forest-floor-rgb: 245, 239, 230;
            --jg-accent-canopy-rgb: 56, 142, 60;
        }

        body.light-mode-jg .app-safari-hut {
            background-color: rgba(250, 250, 250, 0.75); /* Lighter hut bg */
            border-color: var(--jg-surface-bark);
        }
        body.light-mode-jg .safari-map-bar {
            background-color: rgba(var(--jg-surface-bark-rgb), 0.85);
        }
        body.light-mode-jg .search-outpost {
            background-color: rgba(var(--jg-bg-forest-floor-rgb), 0.85);
        }
        body.light-mode-jg #animal-tracker::placeholder { color: var(--jg-text-shadow); }

        body.light-mode-jg .watering-hole-player {
             background: linear-gradient(135deg, rgba(var(--jg-surface-leaf-rgb),0.7), rgba(var(--jg-surface-bark-rgb),0.5));
             border-color: var(--jg-border-vine);
        }
        body.light-mode-jg #main-album-art-jg.album-art-placeholder {
            border-color: var(--jg-surface-bark);
            background-color: var(--jg-text-shadow);
            color: var(--jg-bg-deep-jungle);
        }
        body.light-mode-jg .control-rock {
            background-color: var(--jg-surface-bark);
            border-color: #A1887F; /* Slightly darker than surface bark for contrast */
            color: var(--jg-text-earth);
        }
        body.light-mode-jg .control-rock.play {
            background-color: var(--jg-accent-canopy);
            border-color: var(--jg-accent-canopy);
            color: var(--jg-text-light);
        }
         body.light-mode-jg .control-rock.active-control {
            color: var(--jg-accent-sunburst) !important;
            border-color: var(--jg-accent-sunburst);
            box-shadow: 0 0 10px var(--jg-accent-sunburst), inset 1px 1px 3px rgba(0,0,0,0.05);
        }
        body.light-mode-jg .liana-slider { background-color: var(--jg-border-vine); }
        body.light-mode-jg .liana-slider::-webkit-slider-thumb { background-color: var(--jg-accent-canopy); }
        body.light-mode-jg .fruit-slider { background: var(--jg-surface-bark); }
        body.light-mode-jg .fruit-slider::-webkit-slider-thumb { background: var(--jg-accent-sunburst); border-color: #BF6A00; }

        body.light-mode-jg .explorers-log {
            background-color: rgba(var(--jg-surface-bark-rgb), 0.65);
            border-color: var(--jg-border-vine);
        }
        body.light-mode-jg .log-tabs-jg { border-bottom-color: var(--jg-border-vine); }
        body.light-mode-jg .log-tab-jg { color: var(--jg-text-earth); }
        body.light-mode-jg .log-tab-jg:hover { color: var(--jg-accent-sunburst); }
        body.light-mode-jg .log-tab-jg.active { color: var(--jg-accent-sunburst); }
        body.light-mode-jg .log-tab-jg.active::after { background-color: var(--jg-accent-sunburst); }

        body.light-mode-jg .log-entry-jg { background-color: rgba(var(--jg-bg-forest-floor-rgb), 0.7); }
        body.light-mode-jg .log-entry-jg:hover { background-color: rgba(var(--jg-surface-leaf-rgb),0.6); }
        body.light-mode-jg .log-entry-jg.active-song {
            background-color: rgba(var(--jg-accent-canopy-rgb),0.3);
            border-left-color: var(--jg-accent-canopy);
        }
        body.light-mode-jg .log-entry-jg .img-placeholder.list-thumb-placeholder {
            background-color: var(--jg-text-shadow);
            color: var(--jg-bg-forest-floor);
        }
        body.light-mode-jg .log-actions-jg { border-top-color: var(--jg-border-vine); }
        body.light-mode-jg .log-actions-jg button {
            background-color: var(--jg-surface-leaf);
            color: var(--jg-text-light); /* ensure text is readable on light green */
            border-color: var(--jg-accent-canopy);
        }
        body.light-mode-jg .log-actions-jg button:hover {
            background-color: var(--jg-accent-canopy);
        }

    </style>
</head>
<body class="jungle-theme">

    <div class="jungle-background-layers">
        <div class="layer layer-1"></div>
        <div class="layer layer-2"></div>
        <div class="layer layer-3"></div>
    </div>

    <div class="app-safari-hut">

        <header class="safari-map-bar">
            <div class="compass-logo">
                <i class="fas fa-compass"></i>
                <span>Jungle<span class="text-accent-jg">Groove</span></span>
            </div>
            <div class="search-outpost">
                <i class="fas fa-binoculars"></i>
                <input type="text" id="animal-tracker" placeholder="Track your tunes...">
            </div>
            <div class="safari-tools">
                <button id="weather-toggle" class="tool-btn-jg" title="Toggle Ambience (Theme)"><i class="fas fa-sun"></i></button>
                <button id="profile-ranger" class="tool-btn-jg profile">
                    <!-- <img src="rei_kikuchi_profile.jpg" alt="Ranger"> -->
                    <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="Ranger Profile" class="img-placeholder profile-avatar-placeholder">
                </button>
            </div>
        </header>

        <main class="safari-zone">
            <section class="watering-hole-player">
                <div class="album-canopy">
                    <!-- <img src="placeholder_jungle_album.png" alt="Album Art" id="main-album-art-jg"> -->
                    <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="Album Art" id="main-album-art-jg" class="img-placeholder album-art-placeholder">
                    <div class="leaf-overlay"></div>
                </div>
                <div class="track-details-jg">
                    <h2 id="song-title-jg">Wild Rhythms</h2>
                    <p id="artist-name-jg">The Jungle Cats</p>
                </div>
                <div class="player-controls-jg">
                    <button class="control-rock small" id="btn-shuffle-jg" title="Shuffle"><i class="fas fa-random"></i></button>
                    <button class="control-rock" id="btn-prev-jg" title="Previous"><i class="fas fa-step-backward"></i></button>
                    <button class="control-rock play" id="btn-play-jg" title="Play/Pause">
                        <i class="fas fa-play"></i>
                    </button>
                    <button class="control-rock" id="btn-next-jg" title="Next"><i class="fas fa-step-forward"></i></button>
                    <button class="control-rock small" id="btn-loop-jg" title="Loop"><i class="fas fa-redo-alt"></i></button>
                </div>
                <div class="progress-liana-jg">
                    <span id="current-time-jg">0:00</span>
                    <input type="range" id="progress-slider-jg" class="liana-slider" value="0" title="Seek">
                    <span id="total-time-jg">0:00</span>
                </div>
                <div class="volume-fruit-jg">
                    <i class="fas fa-volume-mute animal-icon monkey" title="Mute/Unmute (icon might change)"></i>
                    <input type="range" id="volume-slider-jg" class="fruit-slider" value="75" min="0" max="100" title="Volume">
                    <i class="fas fa-volume-up animal-icon parrot" title="Volume (icon might change)"></i>
                </div>
            </section>

            <aside class="explorers-log">
                <div class="log-tabs-jg">
                    <button class="log-tab-jg active" data-panel="log-library"><i class="fas fa-tree"></i> Library</button>
                    <button class="log-tab-jg" data-panel="log-paths"><i class="fas fa-map-signs"></i> Playlists</button>
                    <button class="log-tab-jg" data-panel="log-discoveries"><i class="fas fa-paw"></i> Queue <span id="queue-count-jg">0</span></button>
                    <button class="log-tab-jg" data-panel="log-trophies"><i class="fas fa-gem"></i> Favorites</button>
                    <button class="log-tab-jg" data-panel="log-history"><i class="fas fa-history"></i> History</button>
                </div>
                <div class="log-content-jg">
                    <div id="log-library" class="log-panel-jg active">
                        <!-- Library items will be dynamically inserted here -->
                        <!-- Example static items (remove when JS populates) -->
                        <div class="log-entry-jg">
                            <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="Song Thumbnail" class="img-placeholder list-thumb-placeholder">
                            <div><span class="title">King of the Beats</span><span class="artist">Leo Roars</span></div>
                            <span class="duration">3:15</span>
                            <button class="song-item-action-jg" aria-label="Favorite"> <i class="fas fa-feather-alt"></i></button>
                        </div>
                        <div class="log-entry-jg active-song">
                             <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="Song Thumbnail" class="img-placeholder list-thumb-placeholder">
                            <div><span class="title">Monkey Business Funk</span><span class="artist">Primate Groove</span></div>
                            <span class="duration">2:50</span>
                            <button class="song-item-action-jg" aria-label="Favorite"> <i class="fas fa-feather-alt"></i></button>
                        </div>
                    </div>
                    <div id="log-paths" class="log-panel-jg">
                        <!-- Playlist items will be dynamically inserted here -->
                         <div class="text-center p-8 text-jg-text-shadow">
                            <i class="fas fa-map-signs fa-3x mb-4 opacity-50"></i>
                            <h4 class="font-display-jg text-xl text-jg-text-earth mb-2">No Paths Yet</h4>
                            <p class="text-sm">Create playlists to map your musical journeys!</p>
                        </div>
                    </div>
                    <div id="log-discoveries" class="log-panel-jg">
                        <!-- Queue items will be dynamically inserted here -->
                    </div>
                    <div id="log-trophies" class="log-panel-jg">
                        <!-- Favorite items will be dynamically inserted here -->
                    </div>
                     <div id="log-history" class="log-panel-jg">
                        <!-- History items will be dynamically inserted here -->
                    </div>
                </div>
                 <div class="log-actions-jg">
                    <button id="btn-refresh-feed-jg"><i class="fas fa-sync-alt"></i> Refresh Feed</button>
                    <button id="btn-create-playlist-jg"><i class="fas fa-plus-circle"></i> New Path</button>
                </div>
            </aside>
        </main>
    </div>
    
    <!-- The YouTube Iframe API script will create its player in a div with this ID -->
    <!-- It will be dynamically created by the script if not present -->
    <!-- <div id="youtube-player-container-jg" style="position: absolute; top: -9999px; left: -9999px; width:1px; height:1px;"></div> -->

    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
        // jungle_groove_script.js
        console.log("jungle_groove_script.js parsing started. Waiting for YouTube API...");

        let elementsJG = {}; // Ensure elementsJG is declared early
        let appStateJG = {}; // Declare appStateJG early for onYouTubeIframeAPIReady if needed before full init

        // ==========================================================================
        // YouTube Player API Ready Callback (MUST BE GLOBAL and named onYouTubeIframeAPIReady)
        // ==========================================================================
        function onYouTubeIframeAPIReady() {
            console.log("GLOBAL onYouTubeIframeAPIReady CALLED BY YOUTUBE API SCRIPT!");

            // Ensure elements are initialized, especially youtubePlayerContainer.
            // This might be called before DOMContentLoaded, so elementsJG might be empty.
            // initializeElementsJG() will be called again on DOMContentLoaded to ensure all elements are captured.
            if (Object.keys(elementsJG).length === 0 || !elementsJG.youtubePlayerContainer) {
                console.warn("onYouTubeIframeAPIReady: elementsJG not fully initialized or youtubePlayerContainer missing. Initializing elements now for player creation.");
                initializeElementsJG(); // Attempt to initialize elements if not done.
            }

            if (!elementsJG.youtubePlayerContainer) {
                console.error("onYouTubeIframeAPIReady: Still no youtubePlayerContainer after trying to initialize. Player cannot be created. Make sure a div with id 'youtube-player-container-jg' exists or is created by initializeElementsJG.");
                if (typeof showSnackbarJG === 'function') { // Check if showSnackbarJG is defined
                    showSnackbarJG("プレイヤー表示領域が見つかりません。", "error");
                } else {
                    alert("プレイヤー表示領域が見つかりません。");
                }
                return;
            }
            console.log("onYouTubeIframeAPIReady: youtubePlayerContainer found:", elementsJG.youtubePlayerContainer, "with ID:", elementsJG.youtubePlayerContainer.id);

            try {
                // Initialize appStateJG here if it's not fully defined yet,
                // especially properties needed by the player or its event handlers.
                if (Object.keys(appStateJG).length < 5) { // Heuristic: if not many keys, it's not fully initialized
                    console.warn("onYouTubeIframeAPIReady: appStateJG seems partially initialized, re-setting basic player state.");
                    appStateJG.player = null;
                    appStateJG.isPlayerReady = false;
                    appStateJG.volume = appStateJG.volume || 75; // Keep existing volume if set
                }


                appStateJG.player = new YT.Player(elementsJG.youtubePlayerContainer.id, {
                    height: '1', // Hidden player
                    width: '1',  // Hidden player
                    playerVars: {
                        'autoplay': 0,
                        'controls': 0, // No YouTube controls
                        'playsinline': 1, // Important for mobile
                        'origin': window.location.origin // Security
                    },
                    events: {
                        'onReady': onPlayerReadyJG,
                        'onStateChange': onPlayerStateChangeJG,
                        'onError': onPlayerErrorJG
                    }
                });
                console.log("onYouTubeIframeAPIReady: YT.Player instance creation attempted.");
                if (appStateJG.player) {
                    console.log("onYouTubeIframeAPIReady: YT.Player instance created successfully.");
                } else {
                    console.error("onYouTubeIframeAPIReady: YT.Player instance creation failed (player object is null/undefined).");
                }
            } catch (e) {
                console.error("onYouTubeIframeAPIReady: Error creating YT.Player instance:", e);
                const message = "YouTubeプレイヤーの作成中にエラー: " + e.message;
                if (typeof showSnackbarJG === 'function') {
                    showSnackbarJG(message, "error");
                } else {
                    alert(message);
                }
            }
        }
        // ==========================================================================
        // Constants & State
        // ==========================================================================
        const MAX_HISTORY_JG = 20;
        const VOLUME_STEP_JG = 5;
        const SEEK_STEP_JG = 5; // seconds
        const LS_KEYS_JG = {
            HISTORY: 'jungleGrooveHistory',
            FAVORITES: 'jungleGrooveFavorites',
            PLAYLISTS: 'jungleGroovePlaylists',
            USER: 'jungleGrooveUser',
            THEME: 'jungleGrooveTheme',
            QUEUE: 'jungleGrooveQueue'
        };

        // appStateJG is declared at the top, now fully initialize it
        appStateJG = {
            player: null,
            songs: [],
            filteredSongs: [],
            currentSongIndex: -1,
            isPlaying: false,
            isShuffle: false,
            loopMode: 'none', // 'none', 'all', 'one'
            currentPanel: 'log-library',
            volume: 75,
            progressInterval: null,
            history: [],
            favorites: [],
            userPlaylists: [],
            queue: [],
            currentQueueIndex: -1, // For queue playback
            playMode: 'library', // 'library', 'queue'
            isPlayerReady: false,
            snackbarTimeoutId: null,
            activeModalId: null,
            currentTheme: 'dark' // 'dark' or 'light'
        };

        // elementsJG is declared at the top
        // ==========================================================================
        // Element Initialization
        // ==========================================================================
        function initializeElementsJG() {
            console.log("initializeElementsJG - START");
            elementsJG = {
                body: document.body,
                searchInput: document.getElementById('animal-tracker'),
                themeToggle: document.getElementById('weather-toggle'),
                profileButton: document.getElementById('profile-ranger'),
                mainAlbumArt: document.getElementById('main-album-art-jg'),
                songTitleDisplay: document.getElementById('song-title-jg'),
                artistNameDisplay: document.getElementById('artist-name-jg'),
                btnShuffle: document.getElementById('btn-shuffle-jg'),
                btnPrev: document.getElementById('btn-prev-jg'),
                btnPlay: document.getElementById('btn-play-jg'),
                btnNext: document.getElementById('btn-next-jg'),
                btnLoop: document.getElementById('btn-loop-jg'),
                currentTimeDisplay: document.getElementById('current-time-jg'),
                totalTimeDisplay: document.getElementById('total-time-jg'),
                progressSlider: document.getElementById('progress-slider-jg'),
                volumeSlider: document.getElementById('volume-slider-jg'),
                volumeIconMute: document.querySelector('.volume-fruit-jg .fa-volume-mute'),
                volumeIconUp: document.querySelector('.volume-fruit-jg .fa-volume-up'),
                logTabs: document.querySelectorAll('.log-tab-jg'),
                logPanels: document.querySelectorAll('.log-panel-jg'),
                libraryPanel: document.getElementById('log-library'),
                queuePanel: document.getElementById('log-discoveries'),
                favoritesPanel: document.getElementById('log-trophies'),
                historyPanel: document.getElementById('log-history'),
                playlistsPanel: document.getElementById('log-paths'),
                queueCountBadge: document.getElementById('queue-count-jg'),
                btnRefreshFeed: document.getElementById('btn-refresh-feed-jg'),
                btnCreatePlaylist: document.getElementById('btn-create-playlist-jg'),
                youtubePlayerContainer: null, // Will be set below
            };

            // Ensure YouTube player container exists or create it
            let ytContainer = document.getElementById('youtube-player-container-jg');
            if (!ytContainer) {
                console.log("initializeElementsJG: youtube-player-container-jg not found, creating it.");
                ytContainer = document.createElement('div');
                ytContainer.id = 'youtube-player-container-jg';
                // Make it invisible but available for the API
                ytContainer.style.position = 'absolute';
                ytContainer.style.top = '-9999px';
                ytContainer.style.left = '-9999px';
                ytContainer.style.width = '1px';
                ytContainer.style.height = '1px';
                document.body.appendChild(ytContainer);
            }
            elementsJG.youtubePlayerContainer = ytContainer;

            console.log("Jungle Groove Elements Initialized (from initializeElementsJG):", elementsJG);
        }

        // ==========================================================================
        // YouTube API & Song Loading
        // ==========================================================================
        const youtubeAPI_JG = {
            apiKey: 'AIzaSyCbzvjP9vFa5I8N1qLI5H9LUpYim0nkQS4', // WARNING: API Key exposed client-side
            channelId: 'UCYAuSEKhuk3v4ZKzm5Lqb1Q', // Example Channel ID

            async getLatestVideos(maxResults = 15) {
                console.log("getLatestVideos - START. API Key used:", this.apiKey ? 'Yes' : 'No');
                if (!this.apiKey || this.apiKey === 'YOUR_YOUTUBE_API_KEY_HERE' || this.apiKey.includes('_PLACEHOLDER_')) {
                    const errorMsg = "YouTube APIキーが設定されていません。";
                    console.error("youtubeAPI_JG.getLatestVideos:", errorMsg, "Current key:", this.apiKey);
                    showSnackbarJG(errorMsg, "error");
                    return [];
                }
                const apiUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=${this.channelId}&maxResults=${maxResults}&order=date&type=video&key=${this.apiKey}`;
                console.log("Fetching YouTube videos from:", apiUrl);
                try {
                    const response = await fetch(apiUrl);
                    console.log("YouTube API Response Status:", response.status, response.statusText);
                    if (!response.ok) {
                        const errorText = await response.text();
                        let errorData = null;
                        try { errorData = JSON.parse(errorText); } catch (e) { console.warn("Could not parse API error response as JSON:", errorText); }

                        const errorMessage = errorData?.error?.message || `YouTube API error: ${response.status} - ${response.statusText || errorText}`;
                        console.error("API Error Data (if JSON):", errorData);
                        console.error("API Error Text (if not JSON or for details):", errorText);
                        throw new Error(errorMessage);
                    }
                    const data = await response.json();
                    console.log("YouTube API Response Data:", data);
                    if (!data.items) {
                        console.warn("No items found in YouTube API response. Full data:", data);
                        return [];
                    }
                    return data.items.map(item => ({
                        id: item.id.videoId,
                        title: item.snippet.title,
                        artist: item.snippet.channelTitle, // Or a default like "Rei Kikuchi" if needed
                        thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.medium?.url || item.snippet.thumbnails.default?.url,
                        duration: "--:--" // Will be fetched later
                    }));
                } catch (error) {
                    console.error('Error in getLatestVideos fetch operation:', error);
                    showSnackbarJG(`曲の読み込み中にエラーが発生しました: ${error.message}`, "error");
                    return [];
                }
            },

            async getVideoDetails(videoIds) {
                console.log("getVideoDetails - START. Fetching for IDs:", videoIds);
                if (!videoIds || videoIds.length === 0) return {};
                if (!this.apiKey || this.apiKey === 'YOUR_YOUTUBE_API_KEY_HERE' || this.apiKey.includes('_PLACEHOLDER_')) {
                    console.error("youtubeAPI_JG.getVideoDetails: YouTube API Key is not properly set!", this.apiKey);
                    return {};
                }
                const MAX_IDS_PER_REQUEST = 50; // YouTube API limit
                const details = {};
                for (let i = 0; i < videoIds.length; i += MAX_IDS_PER_REQUEST) {
                    const chunkIds = videoIds.slice(i, i + MAX_IDS_PER_REQUEST);
                    try {
                        const response = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=contentDetails&id=${chunkIds.join(',')}&key=${this.apiKey}`);
                        if (!response.ok) throw new Error(`YouTube Video Details API error: ${response.status}`);
                        const data = await response.json();
                        if (data.items) {
                            data.items.forEach(item => {
                                if (item.contentDetails) {
                                details[item.id] = this.convertDuration(item.contentDetails.duration);
                                } else {
                                details[item.id] = "--:--";
                                console.warn(`Video item ${item.id} missing contentDetails.`);
                                }
                            });
                        }
                    } catch (error) {
                        console.error('Error fetching video details chunk:', error);
                    }
                }
                return details;
            },

            convertDuration(isoDuration) {
                if (!isoDuration) return '--:--';
                const regex = /PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/;
                const matches = isoDuration.match(regex);
                if (!matches) return '--:--';
                const hours = parseInt(matches[1] || 0);
                const minutes = parseInt(matches[2] || 0);
                const seconds = parseInt(matches[3] || 0);
                if (hours > 0) {
                    return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
        };

        async function loadInitialSongsJG() {
            console.log("loadInitialSongsJG - START");
            if (!elementsJG.libraryPanel) {
                console.error("loadInitialSongsJG: Library panel element not found for loading songs.");
                return;
            }
            console.log("loadInitialSongsJG: Showing loading indicator.");
            showLoadingInPanelJG(elementsJG.libraryPanel, true);

            let songs = [];
            try {
                songs = await youtubeAPI_JG.getLatestVideos(25); // Fetch 25 songs
                console.log("loadInitialSongsJG: Fetched songs from getLatestVideos:", songs.length);
            } catch (error) {
                console.error("loadInitialSongsJG: Error occurred while calling getLatestVideos:", error);
                appStateJG.songs = [];
                appStateJG.filteredSongs = [];
                if (elementsJG.libraryPanel) {
                    renderSongListJG(elementsJG.libraryPanel, [], 'library');
                    showLoadingInPanelJG(elementsJG.libraryPanel, false);
                    showEmptyMessageInPanelJG(elementsJG.libraryPanel, "読み込み失敗", "曲の取得中にエラーが発生しました。");
                }
                return;
            }

            if (songs && songs.length > 0) {
                console.log("loadInitialSongsJG: Fetching durations for " + songs.length + " songs.");
                const videoIds = songs.map(s => s.id).filter(id => id);
                if (videoIds.length > 0) {
                    try {
                        const durations = await youtubeAPI_JG.getVideoDetails(videoIds);
                        console.log("loadInitialSongsJG: Fetched durations:", durations);
                        songs = songs.map(song => ({
                            ...song,
                            artist: song.artist || "Rei Kikuchi", // Default artist if not provided by API
                            duration: durations[song.id] || "--:--"
                        }));
                    } catch (error) {
                        console.error("loadInitialSongsJG: Error fetching video details (durations):", error);
                        // Songs will still be loaded, just without proper durations for some
                    }
                }
            }

            appStateJG.songs = songs || [];
            appStateJG.filteredSongs = [...(songs || [])];
            console.log("loadInitialSongsJG: Calling renderSongListJG for library with songs:", appStateJG.filteredSongs.length);
            if (elementsJG.libraryPanel) {
                renderSongListJG(elementsJG.libraryPanel, appStateJG.filteredSongs, 'library');
                showLoadingInPanelJG(elementsJG.libraryPanel, false);
            }

            if ((!songs || songs.length === 0)) {
                if (elementsJG.libraryPanel) {
                    const apiKey = youtubeAPI_JG.apiKey;
                    if (!apiKey || apiKey === 'YOUR_YOUTUBE_API_KEY_HERE' || apiKey.includes('_PLACEHOLDER_')) {
                        showEmptyMessageInPanelJG(elementsJG.libraryPanel, "APIキーが必要です", "曲をロードするにはAPIキーを設定してください。");
                    } else {
                        showEmptyMessageInPanelJG(elementsJG.libraryPanel, "まだ曲がありません", "新しい冒険が始まるのを待とう！");
                    }
                }
            }
             // After loading songs, re-render queue if it depends on song details
            if (appStateJG.currentPanel === 'log-discoveries' && elementsJG.queuePanel) {
                renderSongListJG(elementsJG.queuePanel, appStateJG.queue.map(id => findSongByIdJG(id)).filter(s => s), 'queue');
            }
        }
        // ==========================================================================
        // UI Rendering
        // ==========================================================================
        function renderSongListJG(panelElement, songsToRender, context) {
            if (!panelElement) {
                console.warn(`Panel element for context "${context}" not found.`);
                return;
            }
            panelElement.innerHTML = ''; // Clear previous content

            if (!songsToRender || songsToRender.length === 0) {
                let emptyTitle = "何も見つからない...";
                let emptyMessage = "このエリアにはまだ何もないようだ。";
                if (context === 'library' && elementsJG.searchInput?.value) {
                    emptyTitle = "検索結果なし";
                    emptyMessage = `「${escapeHTMLJG(elementsJG.searchInput.value)}」に合う冒険は見つからなかった...`;
                } else if (context === 'queue') {
                    emptyTitle = "キューは空っぽ";
                    emptyMessage = "次の冒険の準備をしよう！";
                } else if (context === 'favorites') {
                    emptyTitle = "お気に入りの宝物なし";
                    emptyMessage = "まだお気に入りの発見がないようだ。曲の羽アイコンをクリック！";
                } else if (context === 'history') {
                    emptyTitle = "足跡なし";
                    emptyMessage = "まだどの曲も探検していないようだ。";
                }
                showEmptyMessageInPanelJG(panelElement, emptyTitle, emptyMessage);
                return;
            }

            const fragment = document.createDocumentFragment();
            songsToRender.forEach(song => {
                if (!song || !song.id) {
                    console.warn("Skipping invalid song object in renderSongListJG:", song);
                    return;
                }
                // Find the song's original index in the main appStateJG.songs list
                // This is crucial because appStateJG.currentSongIndex refers to this main list
                const originalSongIndex = appStateJG.songs.findIndex(s => s.id === song.id);

                // Determine if the song is the currently playing song
                // Compare based on song ID because currentSongIndex might not align if lists are filtered/shuffled differently
                const currentPlayingSong = appStateJG.songs[appStateJG.currentSongIndex];
                const isActive = currentPlayingSong && currentPlayingSong.id === song.id;

                const isFavorited = appStateJG.favorites.some(fav => fav.id === song.id);

                const entry = document.createElement('div');
                entry.className = `log-entry-jg ${isActive ? 'active-song' : ''}`;
                entry.dataset.id = song.id;
                // Store the original index to use when playing the song from this list item
                entry.dataset.originalIndex = originalSongIndex; // Important for playSongAtIndexJG

                // Default artist if not available
                const artistName = song.artist || "Rei Kikuchi";

                entry.innerHTML = `
                    <img src="${song.thumbnail || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'}"
                         alt="${escapeHTMLJG(song.title || '')}"
                         class="${!song.thumbnail ? 'img-placeholder list-thumb-placeholder' : ''}">
                    <div>
                        <span class="title">${escapeHTMLJG(song.title || '不明なタイトル')}</span>
                        <span class="artist">${escapeHTMLJG(artistName)}</span>
                    </div>
                    <span class="duration">${song.duration || '--:--'}</span>
                    <button class="song-item-action-jg" aria-label="${isFavorited ? 'お気に入りから削除' : 'お気に入りに追加'}">
                        <i class="fas ${isFavorited ? 'fa-heart text-jg-accent-sunburst' : 'fa-feather-alt'}"></i>
                    </button>
                `;

                entry.addEventListener('click', (e) => {
                    const clickedButton = e.target.closest('.song-item-action-jg');
                    if (clickedButton) {
                        toggleFavoriteJG(song.id, clickedButton.querySelector('i'));
                    } else {
                        // Use the stored original index to play the song
                        const indexToPlay = parseInt(entry.dataset.originalIndex, 10);
                        if (!isNaN(indexToPlay) && indexToPlay !== -1) {
                            playSongAtIndexJG(indexToPlay);
                        } else {
                            // Fallback if originalIndex is not found (e.g. song from a dynamic playlist not in main list)
                            // In this app, all displayable songs should be from appStateJG.songs
                            console.warn("Could not find original index for song:", song.title);
                            // Try to find it again, or handle error
                            const freshIndex = appStateJG.songs.findIndex(s => s.id === song.id);
                            if (freshIndex !== -1) playSongAtIndexJG(freshIndex);
                            else showSnackbarJG("この曲は現在再生できません。", "error");
                        }
                    }
                });
                fragment.appendChild(entry);
            });
            panelElement.appendChild(fragment);
        }

        function showLoadingInPanelJG(panelElement, isLoading) {
            if (!panelElement) return;
            if (isLoading) {
                panelElement.innerHTML = `<div class="flex justify-center items-center h-full text-jg-text-shadow"><i class="fas fa-spinner fa-spin fa-2x"></i><p class="ml-2">探検中...</p></div>`;
            }
        }

        function showEmptyMessageInPanelJG(panelElement, title, message) {
            if (!panelElement) return;
            panelElement.innerHTML = `
                <div class="text-center p-8 text-jg-text-shadow">
                    <i class="fas fa-map-marked-alt fa-3x mb-4 opacity-50"></i>
                    <h4 class="font-display-jg text-xl text-jg-text-earth mb-2">${escapeHTMLJG(title)}</h4>
                    <p class="text-sm">${escapeHTMLJG(message)}</p>
                </div>`;
        }

        function updatePlayerUIGJ(song) {
            const playerElement = document.querySelector('.watering-hole-player');
            if (song) {
                elementsJG.mainAlbumArt.src = song.thumbnail || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                if (!song.thumbnail) {
                    elementsJG.mainAlbumArt.classList.add('album-art-placeholder');
                    elementsJG.mainAlbumArt.innerHTML = '<i class="fas fa-music"></i>'; // Example placeholder icon
                } else {
                    elementsJG.mainAlbumArt.classList.remove('album-art-placeholder');
                    elementsJG.mainAlbumArt.innerHTML = '';
                }
                elementsJG.songTitleDisplay.textContent = song.title || "Wild Rhythms";
                elementsJG.artistNameDisplay.textContent = song.artist || "The Jungle Cats"; // Use song's artist
                playerElement?.classList.add('has-song');
            } else {
                elementsJG.mainAlbumArt.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                elementsJG.mainAlbumArt.classList.add('album-art-placeholder');
                elementsJG.mainAlbumArt.innerHTML = '<i class="fas fa-music"></i>';
                elementsJG.songTitleDisplay.textContent = "Wild Rhythms";
                elementsJG.artistNameDisplay.textContent = "The Jungle Cats";
                elementsJG.currentTimeDisplay.textContent = "0:00";
                elementsJG.totalTimeDisplay.textContent = "0:00";
                elementsJG.progressSlider.value = 0;
                playerElement?.classList.remove('has-song');
            }
            updatePlayPauseButtonJG();
            updateActiveListItemJG();
        }

        function updatePlayPauseButtonJG() {
            if (!elementsJG.btnPlay) return;
            const iconClass = appStateJG.isPlaying ? 'fa-pause' : 'fa-play';
            elementsJG.btnPlay.innerHTML = `<i class="fas ${iconClass}"></i>`;
            document.querySelector('.watering-hole-player')?.classList.toggle('is-playing', appStateJG.isPlaying);
        }

        function updateActiveListItemJG() {
            document.querySelectorAll('.log-entry-jg.active-song').forEach(el => el.classList.remove('active-song'));
            if (appStateJG.currentSongIndex !== -1 && appStateJG.songs && appStateJG.currentSongIndex < appStateJG.songs.length) {
                const currentSongId = appStateJG.songs[appStateJG.currentSongIndex]?.id;
                if (currentSongId) {
                    // This needs to select based on dataset.id
                    const activeItems = document.querySelectorAll(`.log-entry-jg[data-id="${currentSongId}"]`);
                    activeItems.forEach(item => item.classList.add('active-song'));
                }
            }
        }

        // ==========================================================================
        // Player Controls
        // ==========================================================================
        function playSongAtIndexJG(index) {
            if (index < 0 || !appStateJG.songs || index >= appStateJG.songs.length) {
                console.warn("Invalid song index:", index, "Song list length:", appStateJG.songs?.length);
                return;
            }
            appStateJG.currentSongIndex = index;
            const song = appStateJG.songs[index];
            if (!song) {
                console.error("Song not found at index:", index);
                return;
            }

            console.log("Playing song:", song.title, "at index:", index, "ID:", song.id);
            updatePlayerUIGJ(song);

            if (appStateJG.player && appStateJG.isPlayerReady && song.id) {
                try {
                    appStateJG.player.loadVideoById(song.id);
                    // Play is handled by onStateChange:YT.PlayerState.PLAYING
                } catch (error) {
                    console.error("Error loading video in player:", error);
                    showSnackbarJG("動画の読み込みに失敗しました。", "error");
                }
            } else {
                console.warn("Player not ready or song ID missing. Player:", !!appStateJG.player, "Ready:", appStateJG.isPlayerReady, "Song ID:", song.id);
                 if (!appStateJG.isPlayerReady) showSnackbarJG("プレイヤーの準備ができていません。", "warning");
            }
            addToHistoryJG(song);
            if (appStateJG.currentPanel === 'log-history' && elementsJG.historyPanel) renderHistoryListJG();

            appStateJG.playMode = 'library'; // Default to library, can be overridden if playing from queue
        }

        function togglePlayPauseJG() {
            if (!appStateJG.player || !appStateJG.isPlayerReady) {
                showSnackbarJG("プレイヤーの準備ができていません。", "warning");
                return;
            }
            if (appStateJG.currentSongIndex === -1 && appStateJG.songs && appStateJG.songs.length > 0) {
                playSongAtIndexJG(0); // Play first song if none selected
                return;
            }
            if (appStateJG.currentSongIndex === -1 && (!appStateJG.songs || appStateJG.songs.length === 0)) {
                showSnackbarJG("再生する曲がありません。", "info");
                return;
            }

            if (appStateJG.isPlaying) {
                appStateJG.player.pauseVideo();
            } else {
                appStateJG.player.playVideo();
            }
        }

        function playNextJG() {
            if (!appStateJG.songs || appStateJG.songs.length === 0) return;
            let nextIndex;

            if (appStateJG.playMode === 'queue' && appStateJG.queue.length > 0) {
                appStateJG.currentQueueIndex++;
                if (appStateJG.currentQueueIndex < appStateJG.queue.length) {
                    const nextSongIdInQueue = appStateJG.queue[appStateJG.currentQueueIndex];
                    nextIndex = appStateJG.songs.findIndex(s => s.id === nextSongIdInQueue);
                    if (nextIndex === -1) { // Song from queue not found in main list, fallback
                        console.warn("Song from queue not found, playing next from library logic.");
                        return playNextGeneralLogic(); // Use general logic
                    }
                } else { // End of queue
                    if (appStateJG.loopMode === 'all' || appStateJG.loopMode === 'one') { // Loop queue if 'all' or 'one' (treats queue as the 'all')
                        appStateJG.currentQueueIndex = 0;
                        const nextSongIdInQueue = appStateJG.queue[appStateJG.currentQueueIndex];
                        nextIndex = appStateJG.songs.findIndex(s => s.id === nextSongIdInQueue);
                        if (nextIndex === -1) return playNextGeneralLogic();
                    } else {
                        showSnackbarJG("キューの再生が終わりました。", "info");
                        appStateJG.isPlaying = false;
                        updatePlayPauseButtonJG();
                        return;
                    }
                }
            } else {
                // Standard library playback or if queue is empty/not active
                nextIndex = playNextGeneralLogic(true); // Pass true to indicate it can stop
                if (nextIndex === -1) return; // Means playback stopped
            }
            playSongAtIndexJG(nextIndex);
        }

        function playNextGeneralLogic(canStop = false) {
            let nextIndex = appStateJG.currentSongIndex;
            if (appStateJG.isShuffle) {
                if (appStateJG.songs.length <= 1) nextIndex = 0;
                else do { nextIndex = Math.floor(Math.random() * appStateJG.songs.length); } while (nextIndex === appStateJG.currentSongIndex && appStateJG.songs.length > 1);
            } else {
                nextIndex = (appStateJG.currentSongIndex + 1);
                if (nextIndex >= appStateJG.songs.length) {
                    if (appStateJG.loopMode === 'all') nextIndex = 0;
                    else if (canStop) { // Only stop if canStop is true (e.g. end of library, no loop)
                        showSnackbarJG("探検の終わりです！", "info");
                        appStateJG.isPlaying = false;
                        updatePlayPauseButtonJG();
                        return -1; // Indicate stop
                    } else {
                        nextIndex = 0; // Loop if not allowed to stop (e.g. from queue that fell through)
                    }
                }
            }
            return nextIndex;
        }


        function playPrevJG() {
            if (!appStateJG.songs || appStateJG.songs.length === 0) return;

            // If playing from queue, previous means previous in queue
            if (appStateJG.playMode === 'queue' && appStateJG.queue.length > 0 && appStateJG.currentQueueIndex > 0) {
                 appStateJG.currentQueueIndex--;
                 const prevSongIdInQueue = appStateJG.queue[appStateJG.currentQueueIndex];
                 const originalIndex = appStateJG.songs.findIndex(s => s.id === prevSongIdInQueue);
                 if (originalIndex !== -1) {
                     playSongAtIndexJG(originalIndex);
                     return;
                 }
                 // If song not found, fall through to general logic
            }


            if (appStateJG.player && appStateJG.player.getCurrentTime && appStateJG.player.getCurrentTime() > 3) {
                appStateJG.player.seekTo(0);
                return;
            }

            let prevIndex;
            if (appStateJG.isShuffle) {
                if (appStateJG.songs.length <= 1) prevIndex = 0;
                else do { prevIndex = Math.floor(Math.random() * appStateJG.songs.length); } while (prevIndex === appStateJG.currentSongIndex && appStateJG.songs.length > 1);
            } else {
                prevIndex = (appStateJG.currentSongIndex - 1 + appStateJG.songs.length) % appStateJG.songs.length;
            }
            playSongAtIndexJG(prevIndex);
        }

        function handleSongEndJG() {
            if (appStateJG.loopMode === 'one') {
                playSongAtIndexJG(appStateJG.currentSongIndex); // Replay current song
            } else {
                playNextJG(); // This will handle queue, shuffle, and 'all' loop correctly
            }
        }

        function updateProgressJG() {
            if (!appStateJG.player || typeof appStateJG.player.getDuration !== 'function' || !elementsJG.progressSlider) return;
            const currentTime = appStateJG.player.getCurrentTime ? appStateJG.player.getCurrentTime() : 0;
            const duration = appStateJG.player.getDuration ? appStateJG.player.getDuration() : 0;

            if (elementsJG.progressSlider && elementsJG.currentTimeDisplay && elementsJG.totalTimeDisplay) {
                if (duration > 0) {
                    const progressPercent = (currentTime / duration) * 100;
                    elementsJG.progressSlider.value = progressPercent;
                    elementsJG.currentTimeDisplay.textContent = formatTimeJG(currentTime);
                    elementsJG.totalTimeDisplay.textContent = formatTimeJG(duration);

                    // Update duration in the song list if it was "--:--"
                    const currentSong = appStateJG.songs[appStateJG.currentSongIndex];
                    if (currentSong && currentSong.duration === "--:--") {
                        currentSong.duration = formatTimeJG(duration);
                        // Find ALL list items for this song and update their duration
                        document.querySelectorAll(`.log-entry-jg[data-id="${currentSong.id}"] .duration`).forEach(el => {
                           el.textContent = currentSong.duration;
                        });
                    }
                } else {
                    elementsJG.progressSlider.value = 0;
                    elementsJG.currentTimeDisplay.textContent = "0:00";
                    // elementsJG.totalTimeDisplay.textContent = "0:00"; // Keep last known or API provided duration
                }
            }
        }
        // ==========================================================================
        // YouTube Player Event Handlers
        // ==========================================================================
        function onPlayerReadyJG(event) {
            console.log("Jungle Groove Player Ready! (onPlayerReadyJG called). Player object available:", !!event.target);
            appStateJG.isPlayerReady = true;
            if (event.target && typeof event.target.setVolume === 'function') {
                try {
                    event.target.setVolume(appStateJG.volume);
                    console.log("onPlayerReadyJG: Volume set to", appStateJG.volume);
                } catch(e){
                    console.warn("onPlayerReadyJG: Could not set volume on ready", e);
                }
            } else {
                console.warn("onPlayerReadyJG: event.target or setVolume not available for volume setting.");
            }

            const apiKey = youtubeAPI_JG.apiKey;
            if (apiKey && apiKey !== 'YOUR_YOUTUBE_API_KEY_HERE' && !apiKey.includes('_PLACEHOLDER_') && apiKey.length > 10) {
                console.log("onPlayerReadyJG: API Key seems to be set correctly. Calling loadInitialSongsJG...");
                loadInitialSongsJG();
            } else {
                console.error("onPlayerReadyJG: API Key is missing, still a placeholder, or too short! API Key found:", `"${apiKey}"`);
                showSnackbarJG("APIキーが正しく設定されていません。曲をロードできません。", "error");
                if (elementsJG.libraryPanel) {
                    showEmptyMessageInPanelJG(elementsJG.libraryPanel, "APIキー未設定", "曲をロードするには、スクリプト内のAPIキーを有効なものに置き換えてください。");
                }
            }
        }

        function onPlayerStateChangeJG(event) {
            console.log("onPlayerStateChangeJG - Player state:", event.data, "(Playing:", YT.PlayerState.PLAYING, "Paused:", YT.PlayerState.PAUSED, "Ended:", YT.PlayerState.ENDED, ")");
            const playerState = event.data;
            const previouslyPlaying = appStateJG.isPlaying;
            appStateJG.isPlaying = (playerState === YT.PlayerState.PLAYING);

            if (previouslyPlaying !== appStateJG.isPlaying) {
                updatePlayPauseButtonJG();
            }

            if (appStateJG.isPlaying) {
                if (appStateJG.progressInterval) clearInterval(appStateJG.progressInterval);
                appStateJG.progressInterval = setInterval(updateProgressJG, 250);
                updateProgressJG();
            } else {
                clearInterval(appStateJG.progressInterval);
                 if (playerState === YT.PlayerState.PAUSED || playerState === YT.PlayerState.BUFFERING || playerState === YT.PlayerState.ENDED || playerState === YT.PlayerState.CUED) {
                    updateProgressJG(); // Update progress one last time
                }
            }

            if (playerState === YT.PlayerState.ENDED) {
                handleSongEndJG();
            }
            if (playerState === YT.PlayerState.PLAYING) {
                updateActiveListItemJG(); // Ensure active item is highlighted on play
            }
        }

        function onPlayerErrorJG(event) {
            console.error("onPlayerErrorJG - Error code:", event.data, "for song ID:", appStateJG.songs[appStateJG.currentSongIndex]?.id);
            let msg = `動画の再生エラー (コード: ${event.data})`;
            if (event.data === 2) msg = "無効な動画ID、またはリクエストに問題があります。"; // Invalid parameter
            if (event.data === 5) msg = "HTML5プレイヤーで内部エラーが発生しました。";
            if (event.data === 100) msg = "要求された動画が見つかりませんでした。(非公開または削除された可能性)";
            if (event.data === 101 || event.data === 150) msg = "この動画の埋め込み再生は、所有者によって許可されていません。";
            showSnackbarJG(msg, "error");
            appStateJG.isPlaying = false;
            updatePlayPauseButtonJG();
            // Optionally, try to play the next song
            // setTimeout(playNextJG, 1000); // Give a small delay before trying next
        }
        // ==========================================================================
        // Event Listeners Setup
        // ==========================================================================
        function setupEventListenersJG() {
            elementsJG.btnPlay?.addEventListener('click', togglePlayPauseJG);
            elementsJG.btnNext?.addEventListener('click', playNextJG);
            elementsJG.btnPrev?.addEventListener('click', playPrevJG);
            elementsJG.btnShuffle?.addEventListener('click', toggleShuffleJG);
            elementsJG.btnLoop?.addEventListener('click', toggleLoopJG);

            elementsJG.progressSlider?.addEventListener('input', (e) => {
                if (!appStateJG.player || !appStateJG.isPlayerReady || typeof appStateJG.player.getDuration !== 'function') return;
                const duration = appStateJG.player.getDuration();
                if (duration > 0) {
                    const seekTime = (parseFloat(e.target.value) / 100) * duration;
                    appStateJG.player.seekTo(seekTime, true);
                    updateProgressJG(); // Update UI immediately
                }
            });

            elementsJG.volumeSlider?.addEventListener('input', (e) => {
                appStateJG.volume = parseInt(e.target.value);
                if (appStateJG.player && appStateJG.isPlayerReady && typeof appStateJG.player.setVolume === 'function') {
                    appStateJG.player.setVolume(appStateJG.volume);
                }
                if (elementsJG.volumeIconMute && elementsJG.volumeIconUp) {
                    elementsJG.volumeIconMute.style.opacity = appStateJG.volume === 0 ? '1' : '0.5';
                    elementsJG.volumeIconUp.style.opacity = appStateJG.volume > 0 ? '1' : '0.5';
                }
            });

            elementsJG.themeToggle?.addEventListener('click', toggleThemeJG);

            elementsJG.logTabs.forEach(tab => {
                tab.addEventListener('click', () => switchLogPanelJG(tab.dataset.panel));
            });
            
            elementsJG.searchInput?.addEventListener('input', handleSearchJG);

            elementsJG.btnRefreshFeed?.addEventListener('click', () => {
                showSnackbarJG("ジャングルの最新情報を取得中...", "info");
                loadInitialSongsJG();
            });

            elementsJG.btnCreatePlaylist?.addEventListener('click', () => {
                showSnackbarJG("新しい道の作成はまだ探検の途中...", "info");
                // Placeholder for create playlist functionality
            });
        }
        // ==========================================================================
        // UI & Control Logic Helpers
        // ==========================================================================
        function toggleThemeJG() {
            if (!elementsJG.body || !elementsJG.themeToggle) return;
            elementsJG.body.classList.toggle('light-mode-jg'); // This class should exist in CSS
            appStateJG.currentTheme = elementsJG.body.classList.contains('light-mode-jg') ? 'light' : 'dark';
            elementsJG.themeToggle.innerHTML = `<i class="fas ${appStateJG.currentTheme === 'light' ? 'fa-moon' : 'fa-sun'}"></i>`;
            saveToLocalStorageJG(LS_KEYS_JG.THEME, appStateJG.currentTheme);
            showSnackbarJG(`天候が「${appStateJG.currentTheme === 'light' ? '昼のジャングル' : '夜のジャングル'}」に！`);
        }

        function switchLogPanelJG(panelId) {
            if (!panelId || appStateJG.currentPanel === panelId) return;
            appStateJG.currentPanel = panelId;

            elementsJG.logTabs.forEach(t => t.classList.toggle('active', t.dataset.panel === panelId));
            elementsJG.logPanels.forEach(p => {
                if (p) p.classList.toggle('active', p.id === panelId);
            });

            // Render content for the switched panel
            switch (panelId) {
                case 'log-library':
                    if (elementsJG.libraryPanel) renderSongListJG(elementsJG.libraryPanel, appStateJG.filteredSongs, 'library');
                    break;
                case 'log-discoveries': // Queue
                    if (elementsJG.queuePanel) renderSongListJG(elementsJG.queuePanel, appStateJG.queue.map(id => findSongByIdJG(id)).filter(s => s), 'queue');
                    break;
                case 'log-trophies': // Favorites
                    if (elementsJG.favoritesPanel) renderSongListJG(elementsJG.favoritesPanel, appStateJG.favorites, 'favorites');
                    break;
                case 'log-history':
                    if(elementsJG.historyPanel) renderHistoryListJG();
                    break;
                case 'log-paths': // Playlists
                    if(elementsJG.playlistsPanel) {
                        // For now, show empty or placeholder. Implement playlist rendering when ready.
                        showEmptyMessageInPanelJG(elementsJG.playlistsPanel, "まだ道は描かれていない", "自分だけの音楽の道を作ろう！");
                    }
                    break;
            }
        }

        function handleSearchJG() {
            if (!elementsJG.searchInput) return;
            const searchTerm = elementsJG.searchInput.value.toLowerCase().trim();
            if (searchTerm === "") {
                appStateJG.filteredSongs = [...appStateJG.songs];
            } else {
                appStateJG.filteredSongs = appStateJG.songs.filter(song =>
                    (song.title && song.title.toLowerCase().includes(searchTerm)) ||
                    (song.artist && song.artist.toLowerCase().includes(searchTerm))
                );
            }

            if (appStateJG.currentPanel === 'log-library' && elementsJG.libraryPanel) {
                renderSongListJG(elementsJG.libraryPanel, appStateJG.filteredSongs, 'library');
            }
        }

        function toggleShuffleJG() {
            if (!elementsJG.btnShuffle) return;
            appStateJG.isShuffle = !appStateJG.isShuffle;
            elementsJG.btnShuffle.classList.toggle('active-control', appStateJG.isShuffle);
            showSnackbarJG(`シャッフル・ビート ${appStateJG.isShuffle ? 'ON' : 'OFF'}!`);
        }

        function toggleLoopJG() {
            if (!elementsJG.btnLoop) return;
            if (appStateJG.loopMode === 'none') appStateJG.loopMode = 'all';
            else if (appStateJG.loopMode === 'all') appStateJG.loopMode = 'one';
            else appStateJG.loopMode = 'none';

            elementsJG.btnLoop.classList.toggle('active-control', appStateJG.loopMode !== 'none');
            const loopIcon = elementsJG.btnLoop.querySelector('i');
            let loopIndicator = elementsJG.btnLoop.querySelector('.loop-indicator-jg');

            if (appStateJG.loopMode === 'one') {
                if (!loopIndicator) {
                    loopIndicator = document.createElement('span');
                    loopIndicator.className = 'loop-indicator-jg';
                    elementsJG.btnLoop.appendChild(loopIndicator);
                }
                loopIndicator.textContent = '1';
            } else {
                if (loopIndicator) loopIndicator.remove();
            }

            let loopMsg = "リピート: ";
            if(appStateJG.loopMode === 'none') loopMsg += "OFF";
            if(appStateJG.loopMode === 'all') loopMsg += "ジャングル全体";
            if(appStateJG.loopMode === 'one') loopMsg += "この一本の木";
            showSnackbarJG(loopMsg);
        }
        // ==========================================================================
        // History, Favorites, Queue
        // ==========================================================================
        function addToHistoryJG(song) {
            if (!song || !song.id) return;
            appStateJG.history = appStateJG.history.filter(s => s.id !== song.id); // Remove if already exists
            appStateJG.history.unshift(song); // Add to the beginning (most recent)
            if (appStateJG.history.length > MAX_HISTORY_JG) appStateJG.history.pop(); // Keep max size
            saveToLocalStorageJG(LS_KEYS_JG.HISTORY, appStateJG.history);
        }

        function renderHistoryListJG() {
            if (elementsJG.historyPanel) {
                 // History is stored most recent first, so display as is.
                 renderSongListJG(elementsJG.historyPanel, appStateJG.history, 'history');
            }
        }

        function toggleFavoriteJG(songId, iconElement) {
            const songIndexInFavorites = appStateJG.favorites.findIndex(s => s.id === songId);
            const song = findSongByIdJG(songId); // Get full song object from main list
            if (!song) {
                console.warn("Cannot favorite: song not found in main list with ID", songId);
                return;
            }

            let isNowFavorite = false;
            if (songIndexInFavorites > -1) { // Already a favorite, remove it
                appStateJG.favorites.splice(songIndexInFavorites, 1);
                showSnackbarJG(`「${escapeHTMLJG(song.title)}」をジャングルの秘宝から外した...`);
            } else { // Not a favorite, add it
                appStateJG.favorites.push(song); // Add the full song object
                isNowFavorite = true;
                showSnackbarJG(`「${escapeHTMLJG(song.title)}」を秘宝として発見！`, "success");
            }

            // Update the icon on the clicked element immediately
            if (iconElement) {
                iconElement.className = `fas ${isNowFavorite ? 'fa-heart text-jg-accent-sunburst' : 'fa-feather-alt'}`;
                iconElement.closest('button').setAttribute('aria-label', isNowFavorite ? 'お気に入りから削除' : 'お気に入りに追加');
            }
            saveToLocalStorageJG(LS_KEYS_JG.FAVORITES, appStateJG.favorites);

            // If the favorites panel is active, re-render it
            if (appStateJG.currentPanel === 'log-trophies' && elementsJG.favoritesPanel) {
                 renderSongListJG(elementsJG.favoritesPanel, appStateJG.favorites, 'favorites');
            }
            // Update icons on all instances of this song in any visible list
            document.querySelectorAll(`.log-entry-jg[data-id="${songId}"] .song-item-action-jg i`).forEach(icon => {
                icon.className = `fas ${isNowFavorite ? 'fa-heart text-jg-accent-sunburst' : 'fa-feather-alt'}`;
                icon.closest('button').setAttribute('aria-label', isNowFavorite ? 'お気に入りから削除' : 'お気に入りに追加');
            });
        }

        function updateQueueCountBadgeJG() {
            if (elementsJG.queueCountBadge) {
                elementsJG.queueCountBadge.textContent = appStateJG.queue.length;
                elementsJG.queueCountBadge.style.display = appStateJG.queue.length > 0 ? 'inline-block' : 'none';
            }
        }
        // ==========================================================================
        // Utility Functions
        // ==========================================================================
        function findSongByIdJG(songId) {
            if (!songId || !appStateJG.songs) return null;
            return appStateJG.songs.find(s => s && s.id === songId);
        }

        function formatTimeJG(seconds) {
            if (isNaN(seconds) || seconds < 0) return '0:00';
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        function escapeHTMLJG(str) {
            if (typeof str !== 'string' || !str) return '';
            const map = {
                '&': '&',
                '<': '<',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&apos;' // HTML5, or use &#39; for wider compatibility
            };
            return str.replace(/[&<>"']/g, function(m) { return map[m]; });
        }

        function saveToLocalStorageJG(key, data) {
            try {
                localStorage.setItem(key, JSON.stringify(data));
            } catch (e) {
                console.error("Error saving to localStorage:", key, e);
                showSnackbarJG("設定の保存に失敗しました...", "error");
            }
        }

        function loadFromLocalStorageJG(key) {
            try {
                const data = localStorage.getItem(key);
                return data ? JSON.parse(data) : null;
            } catch (e) {
                console.error("Error loading from localStorage:", key, e);
                return null;
            }
        }

        function showSnackbarJG(message, type = 'info', duration = 3000) {
            const snackbarId = 'snackbar-jg-dynamic';
            let snackbar = document.getElementById(snackbarId);
            if (!snackbar) {
                snackbar = document.createElement('div');
                snackbar.id = snackbarId;
                Object.assign(snackbar.style, {
                    position: 'fixed',
                    bottom: '20px',
                    left: '50%',
                    transform: 'translateX(-50%) translateY(100px)', // Start off-screen
                    padding: '12px 25px',
                    backgroundColor: '#2c3e50', // Default dark
                    color: '#ecf0f1',
                    borderRadius: '8px',
                    boxShadow: '0 4px 15px rgba(0,0,0,0.3)',
                    zIndex: '10001', // High z-index
                    opacity: '0',
                    transition: 'opacity 0.3s ease, transform 0.3s ease-out',
                    fontSize: '0.9rem',
                    fontFamily: 'var(--font-body-jg, sans-serif)', // Use CSS var with fallback
                    textAlign: 'center',
                    minWidth: '280px',
                    maxWidth: '90%'
                });
                document.body.appendChild(snackbar);
            }

            snackbar.textContent = message;
            let bgColor = '#34495e'; // Info
            if (type === 'error') bgColor = '#c0392b'; // Red
            if (type === 'success') bgColor = '#27ae60'; // Green
            if (type === 'warning') bgColor = '#f39c12'; // Orange
            snackbar.style.backgroundColor = bgColor;

            // Ensure transition happens after style changes
            requestAnimationFrame(() => {
                snackbar.style.opacity = '1';
                snackbar.style.transform = 'translateX(-50%) translateY(0)';
            });

            if (appStateJG.snackbarTimeoutId) clearTimeout(appStateJG.snackbarTimeoutId);
            appStateJG.snackbarTimeoutId = setTimeout(() => {
                snackbar.style.opacity = '0';
                snackbar.style.transform = 'translateX(-50%) translateY(100px)';
            }, duration);
        }
        // ==========================================================================
        // Initialization on DOM Load
        // ==========================================================================
        function loadInitialDataJG() {
            console.log("loadInitialDataJG - START: Loading data from localStorage and setting theme.");
            appStateJG.history = loadFromLocalStorageJG(LS_KEYS_JG.HISTORY) || [];
            appStateJG.favorites = loadFromLocalStorageJG(LS_KEYS_JG.FAVORITES) || [];
            appStateJG.queue = loadFromLocalStorageJG(LS_KEYS_JG.QUEUE) || [];
            appStateJG.currentTheme = loadFromLocalStorageJG(LS_KEYS_JG.THEME) || 'dark';

            if (elementsJG.body && elementsJG.themeToggle) {
                if (appStateJG.currentTheme === 'light') {
                    elementsJG.body.classList.add('light-mode-jg');
                    elementsJG.themeToggle.innerHTML = `<i class="fas fa-moon"></i>`;
                } else {
                    elementsJG.body.classList.remove('light-mode-jg'); // Ensure it's not there if dark
                    elementsJG.themeToggle.innerHTML = `<i class="fas fa-sun"></i>`;
                }
            } else {
                console.warn("loadInitialDataJG: Body or themeToggle element not found for theme setup.");
            }

            // Initial render of lists that depend on localStorage.
            // Songs are loaded after player is ready, so some lists might be empty if they need song details.
            if (elementsJG.favoritesPanel) renderSongListJG(elementsJG.favoritesPanel, appStateJG.favorites, 'favorites');
            if (elementsJG.historyPanel) renderHistoryListJG();

            // Queue needs song details. Map stored IDs to full song objects if appStateJG.songs is populated.
            // This might be re-rendered after songs load if necessary.
            if (elementsJG.queuePanel) {
                const queueSongs = appStateJG.queue.map(id => findSongByIdJG(id)).filter(s => s);
                renderSongListJG(elementsJG.queuePanel, queueSongs, 'queue');
            }
            updateQueueCountBadgeJG();
            // Set initial volume slider position
            if(elementsJG.volumeSlider) elementsJG.volumeSlider.value = appStateJG.volume;
            if (elementsJG.volumeIconMute && elementsJG.volumeIconUp) {
                elementsJG.volumeIconMute.style.opacity = appStateJG.volume === 0 ? '1' : '0.5';
                elementsJG.volumeIconUp.style.opacity = appStateJG.volume > 0 ? '1' : '0.5';
            }


            console.log("loadInitialDataJG - END");
        }


        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded - START. Initializing Jungle Groove...");
            initializeElementsJG(); // Initialize DOM elements first
            loadInitialDataJG();    // Load preferences, history, favorites from localStorage, set theme
            setupEventListenersJG(); // Setup all static event listeners
            // Set initial UI state for player controls that depend on appStateJG
            updatePlayerUIGJ(null); // Set to default state initially
            if (elementsJG.btnShuffle) elementsJG.btnShuffle.classList.toggle('active-control', appStateJG.isShuffle);
            if (elementsJG.btnLoop) {
                elementsJG.btnLoop.classList.toggle('active-control', appStateJG.loopMode !== 'none');
                 if (appStateJG.loopMode === 'one') {
                    elementsJG.btnLoop.innerHTML = '<i class="fas fa-redo-alt"></i><span class="loop-indicator-jg">1</span>';
                } else {
                    elementsJG.btnLoop.innerHTML = '<i class="fas fa-redo-alt"></i>';
                }
            }


            console.log("DOMContentLoaded - END. UI initialized. Waiting for YouTube API to call onYouTubeIframeAPIReady to load songs and player.");
            // Song loading (loadInitialSongsJG) is triggered by onPlayerReadyJG which is called by the YouTube API
        });
    </script>
</body>
</html>
